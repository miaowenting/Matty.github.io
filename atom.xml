<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Matty&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-06-05T17:11:57.711Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>miaowenting</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Apache Pulsar</title>
    <link href="http://yoursite.com/2021/05/25/Apache-Pulsar/"/>
    <id>http://yoursite.com/2021/05/25/Apache-Pulsar/</id>
    <published>2021-05-25T05:09:47.000Z</published>
    <updated>2021-06-05T17:11:57.711Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Hey, password is required here.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="ea6a274e8b73cbb2d8e120274f7fae4dbe4df2b8ee2ccd83dba076d59d393ffb">331e92e91546390ea2a7ca460eced6e385c433d348b69056bbdb771db81f0205762d6887a247fc5ce727007104dba0b9a9e2576643c812bd75207b57313411371102efeeced6cbb2e0b2a4c748d367997f3baca5a326acfb65c214075478d709542ea8eec5616d154ce9d7d126e6e43dced6780485ececab47482a18e5b42d674589f8a515792dedced8f9f2ec0100ec1d91c98957a5e313e588d7bd308a479fe72ff00b33dde8c142051aba191be43661bf85c02d06d1e4c35c6216ea1661e4cc1528a645c193b0bb7d635ff3410ed4115876f3934d912ed58c5167da963bb5f8e734ffa9ebfb2a09a0ce7fc3a0070c6c92fc775f44b754aafdfe89056b2dd586afb737b2f0e4aa8d94a641b2bdce792cc654505d7d44fed7c1b65d247e86a05c86722f7fecb4517c7b7da8ab4a5ae765106e21ce26e3435db73473528ff3ff58d7dce6185e42122506d26afe03f2e500a24f7f2a63b8fcd28409b701a7b0f51866a3f65d5d8a372440f03df687b0c835211e964bc226431ec083b21c4eb2eea99a4a99fd9178253e3deb94422e575a28d1884c0103db1a348c441bc6b12b2d09a45d55276debcee9d5eb009648bfaf6a2d61345352d55fca61657a5a545055f3ce1ffef3f4b41fbeb62259b89df76393dcc618c104d10f1fb3ec5166973dedb8384965c18761cc061f17b5fb9cca31780de4f31985e2197b10a73e3f1ab731f82d3b8f43612c0147acdf22452d6539c5da0195b99ccb66d6f80446a1bf74422e7c802c771ebd17a296852094da9f91a3fd1445ceaaa4e27425a47b1bb0ddd3e515d9781bdbe147b670bea7444364d3943f114dace39033343e06cf7bdfafc354a3acce0ed6ea1909fb5fb9b97150785fe63c8b3b2d1a0245f5ef8a3c20cafb02f1aed97294c522409d2363574cb1159d308d72aca67949cd553d4dfb403146444d918717e9fff0dcfd8dd16271d186f6a39a12c65709945678f68cd1ab5a82e9408d6a9f991c764f475568e5e1110b0cd7c3ff7ec3b9cd081e56054922498f7f29ab4c2136184cadf183de44da1755e3ede0ec80bf835b62720c5fd6530e121b37a89bc388b7430ccc97982c0710468258864001d9feed49b0a79817a5910c99583f67a6978010dce93fa48b7e24784c6d838454b5fda6fb00c109ac4100b3cecc7b43e010fb3d3b4f4ace58d47852553503091198d11bb65ae5034304d44fe9d41db80e9ad59423e0ed42584695e65d258b98f7383e830c78a355a1b7ce3c9f4a009e9f72458a194e84492ae785254b75eb93c9c84f0d1599cfa993de0c77</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      Here&#39;s something encrypted, password is required to continue reading.
    
    </summary>
    
      <category term="MQ" scheme="http://yoursite.com/categories/MQ/"/>
    
      <category term="Pulsar" scheme="http://yoursite.com/categories/MQ/Pulsar/"/>
    
    
  </entry>
  
  <entry>
    <title>Hologres</title>
    <link href="http://yoursite.com/2021/05/25/Hologres/"/>
    <id>http://yoursite.com/2021/05/25/Hologres/</id>
    <published>2021-05-25T04:56:14.000Z</published>
    <updated>2021-06-03T17:41:30.749Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Hey, password is required here.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="d86f7dbf17f1668745815bfb46f16a685e09e6d364195037659f61199612e210">09eee18b405207af8c1b71039cebd149</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      Here&#39;s something encrypted, password is required to continue reading.
    
    </summary>
    
      <category term="OLAP" scheme="http://yoursite.com/categories/OLAP/"/>
    
      <category term="Hologres" scheme="http://yoursite.com/categories/OLAP/Hologres/"/>
    
    
  </entry>
  
  <entry>
    <title>大数据发展趋势</title>
    <link href="http://yoursite.com/2021/05/24/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%8F%91%E5%B1%95%E8%B6%8B%E5%8A%BF/"/>
    <id>http://yoursite.com/2021/05/24/大数据发展趋势/</id>
    <published>2021-05-24T07:30:57.000Z</published>
    <updated>2021-05-25T05:06:53.186Z</updated>
    
    <content type="html"><![CDATA[<p>现代企业的大数据平台大多是基于 Hadoop 构建的”一存多算”的多元化架构，以 HDFS 为统一存储，通过 Spark、HBase、Flink、Presto 等多种计算引擎满足不同场景的处理需求。<br>如今，高弹性和可扩展的计算与存储俨然已经非常成熟了，未来云原生、一体化将是大数据的技术发展趋势，并且依附于小程序IoT等业务载体，以 Saas 带动 IaaS 必将成为大势所趋。</p><a id="more"></a><h2 id="云原生"><a href="#云原生" class="headerlink" title="云原生"></a>云原生</h2><p>上云已经成为企业数字化的共识，上云之后如何用好云是当前大家的重点讨论和思考，如果仍然按照过去线下机房的模式去部署和使用大数据，不仅无法获得云计算的红利，甚至在成本效率上可能面临诸多不适。所以，以”存储计算分离+弹性Serverless”为代表的云原生大数据架构，实现存储的计算伸缩、资源弹性按需使用，大幅提升资源利用率、系统运维灵活性，成为接下来的主要趋势。在阿里云平台，以 Lindorm (兼容HDFS、HBase等多摸的 Serverless 存储) + DLA (提供 Spark、Presto等多模态的 Serverless 计算)向企业提供了云原生的大数据最佳实践。</p><h2 id="一体化"><a href="#一体化" class="headerlink" title="一体化"></a>一体化</h2><p>开源大数据技术在经过十多年的快速发展，在采集、存储、计算、调度、管理等各个方面的整体版图已经相当完善，同时面向各个场景的存储计算引擎也呈现百花齐放的景象，但这也加大了用户的使用门槛和维护复杂度，多种系统的一体化也越来越成为下一个大的发展趋势，比如多种模型数据库的一体化、大数据与数据库的一体化、批计算与流计算的一体化、数据湖与数据仓库的一体化等，这些技术上的整合，可以帮助企业更加经济高效的用好数据。</p><ul><li><p>结果的批流一体<br>用户不需要关心批或者流，在用户提交查询的时候得到的结果就是截止那一刻的统计结果。</p></li><li><p>存储的批流一体：统计场景<br>如 Hologres<br>高性能的实时/批量 append 和 update 的能力，读写互不影响，比如目前比较火的数据湖的概念<br>增量订阅读取、批量读取的能力，类似 Apache Pulsar<br>和 OLAP 引擎（impala、presto、clickhouse）对接的能力，列式存储具备较强 SCAN 和 filter 的能力</p></li><li><p>计算引擎的批流一体<br>一套代码搞定批流统计场景，降低开发运维成本</p></li></ul><h2 id="SaaS-带动-IaaS"><a href="#SaaS-带动-IaaS" class="headerlink" title="SaaS 带动 IaaS"></a>SaaS 带动 IaaS</h2><p>与美国相比，中国的云计算市场是”本末倒置”的。美国是以 SaaS 为主，中国现在还是以 IaaS 为主，处于大建数据中心阶段。</p><p>但数据中心里躺着的那些服务器是需要用户买单的，而 SaaS 应用是消耗这些服务器的不二法门。用 SaaS 带动 IaaS，是主流云厂商非常重要的竞争策略。阿里云力推的”云钉一体”就是一个典型案例，可以预见，腾讯云、华为云都将走这一条路。</p><p>要有足够繁荣的生态，才能消耗那些躺在数据中心里的上百万台云服务器。不然，服务器利用率上不去，盲目上规模无异于自杀。</p><p>虽然业内对阿里云+钉钉、腾讯云+企业微信的组合介绍已经很多了，但他们的手里还有第二张王牌。支付宝是阿里云手里的第二张王牌，微信是腾讯云手里的第二张王牌。</p><p>在 PC 时代，大一点的企业以及政府、学校等机构都有一个官方网站，是这些机构对外进行品牌展示、办理业务的窗口。在移动互联网时代，手机替换了电脑。人们越来越多用手机来了解信息和办理业务，网页端的官方网站日渐式微。</p><p>随着 5G 网络的建设普及，小程序将成为 PC 时代”官网”一样的存在。并且，小程序的互动性、及时性会更强。大量的企业和政府单位，将通过小程序的方式来进行信息传递、业务办理，并与用户进行直接、实时的沟通。</p><p>一旦小程序更多地承载业务场景，那其承载的信息流和业务流将出现指数级增长，这需要消耗大量的计算、网络资源，也将成为消耗云计算的关键渠道。</p><p>届时，得小程序者得云计算天下。</p><p>谁会是小程序的赢家，第一是微信，第二是支付宝。百度、华为、字节跳动都得靠边站，UCloud、青云这些云计算小巨头更没戏，而支付宝将成为政府服务的主要渠道，越来越多的政府事务将会可以通过支付宝办理。</p><p>通过手机办理政府业务，将成为大势所趋。并且，没必要每个政府部门都开发一款 App。比如个人所得税 APP，一年也就用一两次。像这类应用，本身业务场景不复杂，通过小程序来实现完全可以。随着 5G 网络的成熟，小程序的流畅度会进一步提升，能够承载的业务场景也会更多。</p><p>支付宝很可能会垄断政府对外业务，随之而来的，阿里云则可能会垄断政务云市场。政府不仅要关注内部系统，更重要的是要与公民进行交互，而这需要一个国民级的 APP 来进行承载。<br>这个国民级 APP，主要是支付宝，其次是微信。</p><p>前端通过支付宝来作为政府服务窗口，后端通过阿里云承载政务云系统，并且实现不同政府部门业务系统和数据的打通，将是未来的发展趋势。因此，阿里云在政务云的市场份额会进一步扩大，这对 UCloud 这样的小巨头而言不是个好消息。</p><p>另一方面，微信小程序的发展空间则更大，并且不局限于政务领域。将来，大部分企业对外服务的主阵地都将由官网转移到微信小程序上。与之配套的，腾讯云很可能会成为最大的赢家。</p><p>以这个角度来看，阿里云可以通过钉钉+支付宝来构建应用生态，腾讯云可以借助微信+企业微信来构建应用生态，以 SaaS 带动 IaaS 消耗。这是横跨C端和B端的顶级巨头玩法，UCloud完全没有可能建立这样的生态系统。未来，UCloud面临阿里云、腾讯云的生态战压力会越来越大。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.infoq.cn/article/0vipwxcltrcc85xojnxe" target="_blank" rel="noopener">阿里为什么要做多模数据库？</a><br><a href="http://www.woshipm.com/it/2795621.html" target="_blank" rel="noopener">小程序生态之路：阿里向左，腾讯向右 – 行业深度战略分析报告</a><br><a href="https://mp.weixin.qq.com/s/1sn6zkNUa7lkR4H_Cij0yw" target="_blank" rel="noopener">UCloud，创业公司死磕公有云的悲壮</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现代企业的大数据平台大多是基于 Hadoop 构建的”一存多算”的多元化架构，以 HDFS 为统一存储，通过 Spark、HBase、Flink、Presto 等多种计算引擎满足不同场景的处理需求。&lt;br&gt;如今，高弹性和可扩展的计算与存储俨然已经非常成熟了，未来云原生、一体化将是大数据的技术发展趋势，并且依附于小程序IoT等业务载体，以 Saas 带动 IaaS 必将成为大势所趋。&lt;/p&gt;
    
    </summary>
    
      <category term="思考总结" scheme="http://yoursite.com/categories/%E6%80%9D%E8%80%83%E6%80%BB%E7%BB%93/"/>
    
    
  </entry>
  
  <entry>
    <title>Presto技术内幕</title>
    <link href="http://yoursite.com/2021/03/04/Presto%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/"/>
    <id>http://yoursite.com/2021/03/04/Presto技术内幕/</id>
    <published>2021-03-03T17:18:43.000Z</published>
    <updated>2021-06-06T16:46:37.235Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Hey, password is required here.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="42deb763f239dd8df9f2339ff653c170bb58b531ec6dd5de8597ce3580d3e56d">843055208f22868ddd45c42da67b5455f4e407510ece7e4a5c1116e1b3af88df21c25ed2e6ade1cbc16bd5688aae665ad1744a4431b068531ff0d1a5febbf6f54a61eb8ba36d4ca121942564b40f7d029cd5913c922a83b991a55783fc5adb89fa680cb2785c3cd8f337d440060f67477de4d798073c3654a178a5ab644732bce773bede502af0ada5fafd79dc44288a1b32952a2d7672b60e290b7f7886261641532f85c409a83af6bbb320db5ffa0e531c0b457a0e298a25ba6cabc9643b41017de42dcd7ede61d25a347bea2ab8985b091d453ec6e5bcf14836d49d35c0ba38f057349e28059fdcd539983e0e7e8449da6d042d41d3d330668549c14dc533bb0d4065b2080fa2b56017afbf639c0b5b67b5a802b3d89c69594254a96988888b2df470b6b7413d321a34a0a9eac02ac0e171906a6bae6bff59b842ade239a23e3eb66fc78061d4e72a41bc1349dd29341d2f544ed31c549ad18237a824a58efe07b6d748f87337be94beb05c32a624865e56b18fb13856e5f849738937fa90028b7e16c81156ab50738e28fcd851b17796a7043ab820016715cd8b52c06581a66e734c4f8d05ceccb6f0b2b4893a66199da5ac756dfa170ce3cf907a728883000fee8e7da41e60c48d96cdb514aeb15343405dab951d70d9bd583fd03ea018e10754bf239e5739a2de20d726aeab23da8912507471cc8bfb03d73b0aa7560d93730194598f82206a0b4e2ded6ba9fa8d72f1f3f94fc55a4380111e957eeb4b612acf6d7f0438bc9a28ac1cf393791353c9f234a8edd61216840c99f5b94e254d730a0fc0e381ac2365e4ead1d8f1e260906eb5fa785a25ebf6a4521f313739f8dc3cc68c84ecc7f91d7f7f6eb05bce6a7cf2cc14a807f36ee29522c6ea4c861714af2b929afa1dab38311bc3a0ab2f833f67ddcd97a9b86473798d94119e6b0b74e7ed7cfecb4acacb1f9c02d0b6ba78f541dfc86a8de200a2229684b998cd4679c9e4d7d61a8cd50a13ce93f0d7cca4bc6d0e1104ecdd1c14f33bcd395371efa07718b6bd6995ea9ad8d4dab28e0b9426059e1c71bd492fabe2370d49340c94ca25fc7b2cd44e14ff10e8de3a343676fcc114e49960133006bdad7bb0f494adb7909cf41e97b670c585faca9085dffa3ac99fccbdd09b7dd34492786679ec7d365fcaba82efe8c8c5858e6e49a6cff1e6f81ecf4b1a9c164d168d77069d3212ba73749decb599ec1ee1e2242e989c29fc45f3917ff360070aa624612e9575b5194b1c228d2f6a1701a01502e2e7c197da193719a7baa56e482564086a182804f2fdb5c52dc025ca92f7c767c1c8cdf15678a8bde8bad5ecee20bc417dbf76b34e3d17befed33782b1fe664dc4cc96fd01a20157aaec6723d1288a8289e0daf03ec7e2c16921fd6526b16652953d87cc9774058a77af1a41b060caf55ccff8bd57d7b5d2efce1cef635fef1bdeb5479373a1fa1b4a5374039b225e5a0a8e2e7c821ae98f914dfcbca6f656db5265137b2ce34156fcdaa2890da197a379c90027acc3ec979e23aed67dee24a4fafd07fa9c88f5b05da7b58927451238cc6825e184784465862a8cda55c9c5b45d8daa3787029edccca6058df11f834d6462c95969456f01b6e1ce32d812ef37da0caa6510a79202f589ddf04a2d574071c29aa4b74e5049db5640b0738e618158b8685ca5f57f0e2e891006b7ffbc28ae1ef98a16d2bd3350bb4a8d8b68041f87dc622a16c53cb9b273cf2bdfe1b8fb54df24407a3ad8aec654df414789b19d170eca413605f685a2f61be0fa29c8c77b7a98beaa000d6723095c229086c4b4c4d211ceadadd4d4bf0febf9d1f0f2f9f12ad52601eda5a12b9e7a2d83bcd265ebfb204192a36a2780ffaf11c7198c81b73085701af2f04ca63645e3cc198d99a883df7e6398685d6ab06eefa6f2d5ecc4dd06b05fe95433e27409134906facabdf4e98945910053d5c61d7b020662a58e4ffc8b1ccb0ac5fd50ff2f99db167695e8e15b1ae7cc74f360570849473ef5cd0b5080e5a3e7929c286ce8636c4c71ad5eb09ed3911d87f9355aba5802a3a58745c7d9ce8dba6d89826f8c1c85d3add7f7cb369d904882f08428dc8d2bc10bb6e8542be126f82c07357a770bb90e8b2c545ce6d1189e04d75e6d1bfd070d31b5b42720aeb194b4c710ed5f28957f6aeaeb0a76529941cdc3f2db08a9905ca57b33d6b167a63315dd95a9a95e7d64b424aa771e6f5030d5fec36a178bbf5704dd82b8a523413e2cedf77e1789ecb6aacbc5af4b6cc1dbdce40e2bd37aa42b1bbc8aa408b4cde448562d071c0a343b34bfb2c1e1aa6acda490c5b16f59e7003f4bd9f73e245247503fab4e0869704bee725984fa8e40d35cc79fe08f05eb963749ce5043f6f3a77cd21f5459d14bfbb3a34b88d9a023e97afafceefb2d9d4474ba5cbcd2c74640b60b5f7c2242361501df36a9b3a1bd2362e020b5d89cf11a6d2c7dbd9477a16c775f15e388e8bcb955020f9776a4be813db14f902bb1bfdc3c1f45c5ee0bcba38413c640e4cd330c7c0848dcedd0febcd9fd77d2e0179cfa933cdb5a7961277764aafa4497ea23a2f1b9e1cb8d203c06b063d2fcdee4c7d8f8c0788e7a77cf3a47bfa50edc3746138b1ef1ce20c02f0a33a68d1a6c2183aba72035e25f5f447af68c81bb6f1c5168f6c5f5af98d0259e311dc896e2cb4924ae17347742686af8815c149bf35da6082da5ef31476e4defbccabf85dab2b23ac3c41f8d7103df28f4b138f83544b05c07feb87513562f8893854644291b22862c95a9d7477a13163904ab7b5623ec40f77e9609ccf6e2ae80bf99d757215075b1cfae02cb4efbbead9ef7167dbc670bb74bb4576e6d8c32437c96fc5bfcf2a73941b185c934acb15c55b803d2631c9a005ba203871f56718d64d60ffe093e5d9ba214295e638010044aa8013c2ef8cda287ee04bd194bbf25509f6193e3cfd418472b9851201e5ed60887e660e85342925b57802eda429dcc4c0403356f784d5b80112082475f8a6469c0757318a5d6d320c757a63b2c62b42d1f022b50d0d9ee79c777f534df9c1ba15f001c1e88fd01d4d52a438b78796f15598c6a55fe743f45cc8ea09d2a260bdee81136207c5ec2faab333d9579d0002520d433b761991f8c97f86f0e454ad48e9445f1fd2a77c3caefc585b275eb05fd21ec32ed244305242de019e8c08d39f86cd5422f7326e225a6fa41c6311f2a8018f3ff40eeafa13452dec34f261164f79536a07cc4eaf22664009da334028ad648897bd16009753142170a839f3d31720470bbf3bedd8cc7d225a4eb6ac855ec45f0b68b6c87442f8d636230f1d70ca15e7803058bb0ab6378ac3b079352689ad2287d94f88663a5eb55fa0dde1eff21f83aaabbbb86ea1d845762e9b4bc3c1de93be328fdc5ba412cbe775dc514a02e305ecc7259fda1520f72a785f56b5774d14f4a1672134639fd73263a2adee4af9910be06ccaaf7022a8092d9d0bc897006f5b76267a89ec402b438259039ce65a77ad239a8552216b0dcf7e18f9fbaf4b5ed2a4dc3135ce669eb4dd75203a19294ddd584258e732c401204ac1e1b22dc65470298981582c190ea9beddbe554d7b998944d730ec959395b13ed307b84bd5861facb1c8be9bff13425268a681de4aa01321f82a8b66f3ee8</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      Here&#39;s something encrypted, password is required to continue reading.
    
    </summary>
    
      <category term="OLAP" scheme="http://yoursite.com/categories/OLAP/"/>
    
      <category term="Presto" scheme="http://yoursite.com/categories/OLAP/Presto/"/>
    
    
  </entry>
  
  <entry>
    <title>初识Presto</title>
    <link href="http://yoursite.com/2021/03/04/%E5%88%9D%E8%AF%86Presto/"/>
    <id>http://yoursite.com/2021/03/04/初识Presto/</id>
    <published>2021-03-03T17:17:43.000Z</published>
    <updated>2021-06-06T16:51:53.639Z</updated>
    
    <content type="html"><![CDATA[<p>  本文为 Presto 的入门学习笔记。 Presto 是一个开源的分布式 SQL 查询引擎，它是为了高效查询不同系统和各种规模的数据源而从头开始设计和编写的一套系统。</p><a id="more"></a><h2 id="Presto-简介"><a href="#Presto-简介" class="headerlink" title="Presto 简介"></a>Presto 简介</h2><h3 id="背景及发展"><a href="#背景及发展" class="headerlink" title="背景及发展"></a>背景及发展</h3><p>Hadoop 提供的大数据解决方案使用的是 MR 计算框架，这种计算框架适用于大数据的离线和批量计算，因为该计算框架强调的是吞吐率而不是计算效率，所以其不能满足大数据快速实时 Ad-Hoc 查询计算的性能要求。</p><p>因此，开源社区和各大互联网公司纷纷进行大数据实时 Ad-Hoc 查询计算产品的研发 ， Facebook 于2012年秋季开始开发 Presto，目前该产品已经在超过 1000 名 Facebook 雇员中使用，每天运行超过 30000 个查询，每日查询数据量在 1PB 级别。Facebook 称 Presto 的性能比 Hive 要好上 10 倍还多，2013年 Facebook 正式宣布开源 Presto。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li><p>多数据源<br>目前 Presto 可以支持 Mysql、PostgreSql、Cassandra、Hive、Kafka、JMX、Iceberg 等多种 Connector，并且可以支持分库分表以及快速读取的功能。</p></li><li><p>支持 SQL<br>Presto 已经可以完全支持 ANSI SQL，并提供了一个 SQL Shell 给用户，用户可以直接使用 ANSI SQL 进行数据查询和计算。</p></li><li><p>扩展性<br>开发人员可以很容易的开发出适用于自己特定数据源的 Connector，并且可以使用 SQL 语句查询和分析自定义 Connector 中的数据。</p></li><li><p>混合计算<br>每种类型的数据源都对应于一种特定类型的 Connector，用户可以根据业务需要在 Presto 中针对于一种类型的 Connector 配置一个或多个 Catalog 并查询其中的数据，用户可以混合多个 Catalog 进行 join 查询和计算。</p></li><li><p>高性能<br>经过 Facebook 和 京东商城的测试，Presto 的查询平均性能是 Hive 的10倍以上。</p></li><li><p>流水线<br>由于 Presto 是基于 pipeline 进行设计的，因此在进行海量数据处理的过程中，终端用户不用等到所有的数据都处理完毕才能看到结果，而是可以像自来水管道一样，一旦开始计算，就可以立即产生一部分结果数据，并且结果数据会一部分接一部分地呈现在终端客户面前。</p></li></ul><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="Presto-服务进程"><a href="#Presto-服务进程" class="headerlink" title="Presto 服务进程"></a>Presto 服务进程</h4><ul><li><p>Coordinator<br>Coordinator 服务进程部署于集群中一个单独的节点上，是整个 Presto 集群的管理节点。主要用于接收客户端提交的查询，查询语句解析，生成查询执行计划、Stage、Task，对生成的 Task 进行调度。<br>此外，Coordinator 还对集群中的所有 Worker 进行管理，是整个 Presto 集群的 Master 进程，该进程既与 Worker 进行通信从而获得最新的 Worker 信息，又与 Client 进行通信，从而接收查询请求。</p></li><li><p>Worker<br>在每个 Worker 节点上都存在一个 Worker 服务进程，主要进行数据的处理以及 Task 的执行。Worker 进程每隔一定的时间会向 Coordinator 上的 restful<br>服务发送心跳。当客户端提交一个查询时，Coordinator 则会从当前存活的 Worker 列表中选择出合适的 Worker 节点去运行 Task。Worker 在执行每个 Task 时会进一步对当前 Task 读入的每个 Split 进行一系列的操作和处理。</p></li></ul><h4 id="Presto-模型"><a href="#Presto-模型" class="headerlink" title="Presto 模型"></a>Presto 模型</h4><ul><li>Connector</li></ul><p>使 Presto 适配一个数据源，每一个 Catalog 对应于一个特定的连接器。</p><ul><li>Catalog</li></ul><p>定义连接到一个数据源的细节，它包含了 Schema 并配置了一个连接器来使用。</p><ul><li>Schema</li></ul><p>组织表的一种方式。Catalog 和 Schema 一起定义了一个集合的表，这些表可以查询。</p><ul><li>Table</li></ul><p>表是无序的行的集合。这些行内容被组织成带有数据类型的有名称的列。</p><h4 id="Presto-查询执行模型"><a href="#Presto-查询执行模型" class="headerlink" title="Presto 查询执行模型"></a>Presto 查询执行模型</h4><p>在 Presto 中一次查询执行会被分解为多个 Stage ，Stage 与 Stage 之间是有前后依赖关系的。每个 Stage 内部又会被分解为多个 Task，属于每个 Stage 的 Task 被均分在每个 Worker 上并行执行。在每个 Task 内部又会被分解为多个 Driver ，每个 Driver 负责处理一个 Split ，而且每个 Driver 由一系列前后相连的 Operator 组成，这里的每个 Operator 都代表针对于一个 Split 的操作。</p><ul><li><p>Statement<br>Statement 语句，指的是终端用户输入的用文字表示的 SQL 语句，由子句（Clause）、表达式（Expression）和断言（Predicate）组成。</p></li><li><p>Query<br>Query 即查询执行。当 Presto 接收一个 SQL 语句并执行时，会解析该 SQL 语句，将其转变成一个查询执行和相关的查询执行计划。一个查询执行代表可以在 Presto 集群中运行的查询，是由运行在各个 Worker 上且各自之间相互关联的阶段（Stage）组成的。<br>查询执行是为了完成 SQL 语句所表述的查询而实例化的配置信息、组件、查询执行计划和优化信息等。一个查询执行由 Stage、Task、Driver、Split、Operator 和 DataSource 组成，</p></li><li><p>Stage<br>Stage 即查询执行阶段。当 Presto 运行 Query 时，Presto 会将一个 Query 拆分成具有层级关系的多个 Stage，一个 Stage 就代表查询计划的一部分。</p></li><li><p>Exchange<br>Presto 的 Stage 是通过 Exchange 来连接另一个 Stage 的，Exchange 用于完成有上下游关系的 Stage 之间的数据交换。</p></li><li><p>Task<br>Stage 并不会在 Presto 集群中实际运行，仅代表针对于一个 SQL 语句查询执行计划中的一部分查询的执行过程，只是用来对查询执行计划进行管理和建模。Stage 在逻辑上又被分为一系列的 Task，这些 Task 则需要实际运行在 Presto 的各个 Worker 节点上。</p></li><li><p>Driver<br>一个 Task 包含一个或多个 Driver。一个 Driver 其实就是作用于一个 Split 的一系列 Operator 的集合。因此一个 Driver 用于处理一个 Split，并且生成相应的输出，这些输出由 Task 收集并传送给下游 Stage 中的一个 Task。一个 Driver 拥有一个输入和一个输出。</p></li><li><p>Operator<br>一个 Operator 代表一个 Split 的一种操作，例如过滤、加权、转换等。一个 Operator 依次读取一个 Split 中的数据，将 Operator 所代表的计算和操作作用于 Split 的数据上，并产生输出。每个 Operator 均会以 Page 为最小处理单位分别读取输入数据和产生输出数据。Operator 每次只会读取一个 Page 对象，相应地，每次也只会产生一个 Page 对象。</p></li><li><p>Split<br>Split 即分片。一个分片是一个大的数据集中的一个小的子集。而 Driver 则是作用于一个分片上的一系列操作的集合，而每个节点上运行的 Task，又包含多个 Driver，从而一个 Task 可以处理多个 Split。</p></li><li><p>Page<br>Page 是 Presto 中处理的最小数据单元。一个 Page 对象包含多个 Block 对象，每个 Block 对象是一个字节数组，存储一个字段的若干行。多个 Block 横切的一行是真实的一行数据。一个 Page 最大为 1MB ，最多 16 * 1024 行数据。</p></li></ul><h3 id="Presto-使用场景"><a href="#Presto-使用场景" class="headerlink" title="Presto 使用场景"></a>Presto 使用场景</h3><h4 id="单一的-SQL-分析访问点"><a href="#单一的-SQL-分析访问点" class="headerlink" title="单一的 SQL 分析访问点"></a>单一的 SQL 分析访问点</h4><p>作为一个消费者和分析师，你可能会遇到数不清的问题：</p><ul><li>有时你甚至不知道数据在哪儿，只有凭借公司某个部门的内部知识或者组织内多年的工作经验，你才能找到正确的数据。</li><li>为了查询多个数据库，你需要使用不同的连接和运行多种 SQL 方言的不同查询。这些查询看起来相似，行为上却不同。</li><li>若不使用数据仓库，就无法使用查询合并来自不同系统的数据。</li></ul><p>可以使用 Presto 对接这些数据库，使用一个 SQL 标准来查询所有的系统。所有的仪表盘和分析工具以及其他商业智能系统都可以指向一个系统 – Presto，并访问组织当中的所有数据。</p><h4 id="数据仓库和数据源系统的访问点"><a href="#数据仓库和数据源系统的访问点" class="headerlink" title="数据仓库和数据源系统的访问点"></a>数据仓库和数据源系统的访问点</h4><p>当一个组织需要更好的理解和分析存放在无数 RDBMS 中的数据时，就可以创建和维护数据仓库系统。从多个系统中抽取的数据通过一个复杂的 ETL 过程，最终进入一个严格受控的、巨大的数据仓库。</p><p>尽管数据仓库在很多情况下非常有用，但作为一个数据分析师，你会面临很多新问题：</p><ul><li>除了原来的那些数据库，你的工具和查询现在又多了一个数据接入点。</li><li>你今天就要用的数据还没放入数据仓库。加载数据的过程痛苦、昂贵又困难重重重。</li></ul><p>Presto 允许你添加任何数据仓库作为数据源，就像其他关系数据库一样。如果想深入研究数据仓库的查询，可以在 Presto 里直接完成，也可以在这里访问数据仓库及其源数据库系统，甚至可以编写将它们组合在一起查询。</p><h4 id="提供对任何内容的-SQL-访问"><a href="#提供对任何内容的-SQL-访问" class="headerlink" title="提供对任何内容的 SQL 访问"></a>提供对任何内容的 SQL 访问</h4><p>Presto 允许将所有支持的系统作为数据源进行连接。它使用标准的 ANSI SQL 和使用 SQL 的所有工具对外暴露要查询的数据。</p><h4 id="联邦查询"><a href="#联邦查询" class="headerlink" title="联邦查询"></a>联邦查询</h4><p>将所有的数据孤岛都暴露给 Presto 是向理解数据迈出的一大步。可以使用 SQL 和标准工具来联邦查询所有内容。 在一个语句中引用并使用不同数据库和模式的 SQL 查询，这些数据库和 Schema 来自于完全不同的系统。在同一条 SQL 查询中，可以查询 Presto 中可用的所有数据源。</p><h4 id="虚拟数据仓库的语义层"><a href="#虚拟数据仓库的语义层" class="headerlink" title="虚拟数据仓库的语义层"></a>虚拟数据仓库的语义层</h4><p>数据仓库系统为用户创造了巨大的价值，对组织来说确实一个负担。</p><ul><li>运行和维护数据仓库是一个巨大且昂贵的项目。</li><li>需要专门的团队运行与管理数据仓库和相关的 ETL 过程。</li><li>将数据导入数据仓库需要用户执行繁琐的操作，并且通常非常耗时。</li></ul><p>Presto 可用作虚拟仓库。使用这一工具和标准的 ANSI SQL ，就可以定义语义层。一旦所有的数据库都设置成 Presto 的数据源，就可以直接查询它们。Presto 提供了查询这些数据库所需的计算能力。使用 SQL 和 Presto 支持的函数和运算符，可以直接从数据源获得想要的数据。在使用数据进行分析之前，无需复制、移动或转换它们。</p><h4 id="数据湖查询引擎"><a href="#数据湖查询引擎" class="headerlink" title="数据湖查询引擎"></a>数据湖查询引擎</h4><p>在数据被存储到数据湖的存储系统时，并没有特别考虑接下来应该如何访问它们，Presto 可以使它们成为有用的数据仓库。现代数据湖通常使用 HDFS 以外的其他对象存储系统，这些系统来自云供应商或其他开源项目。 Presto 能使用 Hive 连接器连接它们，无论数据在哪里、如何存储，都可以在数据湖上使用基于 SQL 的数据分析。</p><h4 id="SQL-转换和-ETL"><a href="#SQL-转换和-ETL" class="headerlink" title="SQL 转换和 ETL"></a>SQL 转换和 ETL</h4><p>Presto 也可用于迁移数据，它所提供的丰富的 SQL 函数，可以查询数据，转换数据，并将数据写入同一个数据源或任何其他数据源。</p><h4 id="更快的响应带来更好的数据见解"><a href="#更快的响应带来更好的数据见解" class="headerlink" title="更快的响应带来更好的数据见解"></a>更快的响应带来更好的数据见解</h4><p>复杂的问题和海量数据集带来了诸多限制。将数据复制并加载到数据仓库并在其中分析它们的整个过程会过于昂贵。计算可能消耗太多的计算资源而无法处理全部数据，或者要消耗数天才能得到答案。</p><p>Presto 一开始就避免了数据复制。Presto 的并行计算和重度优化通常能为数据分析带来性能提升。</p><p>如果原来需要 3 天的查询现在只需要 15 分钟就可以完成，那么执行这个查询便是有价值的。从这些结果中获得的知识可以执行更多的查询。</p><h2 id="安装和配置-Presto"><a href="#安装和配置-Presto" class="headerlink" title="安装和配置 Presto"></a>安装和配置 Presto</h2><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn -T2C install -DskipTests</span><br></pre></td></tr></table></figure><h3 id="服务端部署"><a href="#服务端部署" class="headerlink" title="服务端部署"></a>服务端部署</h3><ul><li>从编译后的源码中拷贝jar和配置文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mkdir /usr/<span class="built_in">local</span>/presto</span><br><span class="line"></span><br><span class="line">cp -r ～workspace/presto/presto-server/target/presto-server-0.255-SNAPSHOT /usr/<span class="built_in">local</span>/presto</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/presto/presto-server-0.255-SNAPSHOT</span><br><span class="line"></span><br><span class="line">cp ～workspace/presto/presto-server/target/presto-main/etc ./presto-server-0.255-SNAPSHOT/</span><br><span class="line"></span><br><span class="line">ln -s presto-server-0.255-SNAPSHOT server</span><br></pre></td></tr></table></figure><ul><li>设置环境变量</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> PRESTO_SERVER_HOME=/usr/<span class="built_in">local</span>/presto/server</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$PRESTO_SERVER_HOME</span>/bin</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><ul><li>修改 config.properties</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">coordinator=true</span><br><span class="line">node-scheduler.include-coordinator=true</span><br><span class="line">http-server.http.port=8086</span><br><span class="line">discovery-server.enabled=true</span><br><span class="line">discovery.uri=http://localhost:8086</span><br></pre></td></tr></table></figure><ul><li>修改 node.properties</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">node.id=562e42e2-e874-431f-8da5-cb779744cf7c</span><br><span class="line">node.data-dir=/usr/local/presto/data</span><br><span class="line">catalog.config-dir=/usr/local/presto/server/etc/catalog</span><br><span class="line">plugin.dir=/usr/local/presto/server/plugin</span><br><span class="line">node.server-log-file=/usr/local/presto/server/var/log/server.log</span><br><span class="line">node.launcher-log-file=/usr/local/presto/server/var/log/launcher.log</span><br></pre></td></tr></table></figure><ul><li>修改 jvm.config</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-server</span><br><span class="line">-Xmx4G</span><br><span class="line">-XX:-UseBiasedLocking</span><br><span class="line">-XX:+UseG1GC</span><br><span class="line">-XX:+ExplicitGCInvokesConcurrent</span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line">-XX:+UseGCOverheadLimit</span><br><span class="line">-XX:+ExitOnOutOfMemoryError</span><br><span class="line">-XX:ReservedCodeCacheSize=512M</span><br></pre></td></tr></table></figure><ul><li>修改 log.properties</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.facebook.presto=INFO</span><br></pre></td></tr></table></figure><ul><li>后台启动</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$PRESTO_SERVER_HOME</span>/bin/launcher start</span><br></pre></td></tr></table></figure><ul><li>前台启动</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$PRESTO_SERVER_HOME</span>/bin/launcher run</span><br></pre></td></tr></table></figure><p>[Presto Web UI] <code>http://localhost:8086/ui/)</code></p><p><img src="Presto%E6%9C%AC%E5%9C%B0%E5%90%AF%E5%8A%A8%E7%9A%84Web_UI.png" alt></p><h3 id="Presto-CLI"><a href="#Presto-CLI" class="headerlink" title="Presto CLI"></a>Presto CLI</h3><ul><li>从编译后的源码中拷贝jar</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/presto</span><br><span class="line"></span><br><span class="line">mkdir -p cli/lib</span><br><span class="line"></span><br><span class="line">cp ～workspace/presto/presto-cli/target/presto-cli-0.255-SNAPSHOT-executable.jar /usr/<span class="built_in">local</span>/presto/cli/lib</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/presto/cli/lib</span><br><span class="line"></span><br><span class="line">mv presto-cli-0.255-SNAPSHOT-executable.jar presto</span><br><span class="line"></span><br><span class="line">chmod +x presto</span><br></pre></td></tr></table></figure><ul><li>设置环境变量</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> PRESTO_CLI_HOME=/usr/<span class="built_in">local</span>/presto/cli</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$PRESTO_CLI_HOME</span>/lib</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><ul><li>运行 cli 并查看其版本</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">presto --version</span><br><span class="line">Presto CLI 0.255-SNAPSHOT-9095346</span><br></pre></td></tr></table></figure><ul><li>启动 cli</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">presto --server localhost:8086</span><br></pre></td></tr></table></figure><ul><li>额外诊断，打印调试信息</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">presto --debug</span><br></pre></td></tr></table></figure><ul><li>执行查询</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">presto --server localhost:8086 --catalog tpch --schema sf1 --execute <span class="string">'select nationkey,name,regionkey from nation limit 5'</span></span><br><span class="line"><span class="string">"0"</span>,<span class="string">"ALGERIA"</span>,<span class="string">"0"</span></span><br><span class="line"><span class="string">"1"</span>,<span class="string">"ARGENTINA"</span>,<span class="string">"1"</span></span><br><span class="line"><span class="string">"2"</span>,<span class="string">"BRAZIL"</span>,<span class="string">"1"</span></span><br><span class="line"><span class="string">"3"</span>,<span class="string">"CANADA"</span>,<span class="string">"1"</span></span><br><span class="line"><span class="string">"4"</span>,<span class="string">"EGYPT"</span>,<span class="string">"4"</span></span><br></pre></td></tr></table></figure><h3 id="简单-SQL-语法"><a href="#简单-SQL-语法" class="headerlink" title="简单 SQL 语法"></a>简单 SQL 语法</h3><ul><li>查看 catalogs</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">presto&gt; show catalogs;</span><br><span class="line">  Catalog   </span><br><span class="line">------------</span><br><span class="line"> blackhole  </span><br><span class="line"> druid      </span><br><span class="line"> example    </span><br><span class="line"> hive       </span><br><span class="line"> jmx        </span><br><span class="line"> localfile  </span><br><span class="line"> memory     </span><br><span class="line"> mysql      </span><br><span class="line"> pinot      </span><br><span class="line"> postgresql </span><br><span class="line"> raptor     </span><br><span class="line"> sqlserver  </span><br><span class="line"> system     </span><br><span class="line"> tpcds      </span><br><span class="line"> tpch       </span><br><span class="line">(15 rows)</span><br><span class="line"></span><br><span class="line">Query 20210606_141818_00009_4qtix, FINISHED, 1 node</span><br><span class="line">Splits: 19 total, 19 <span class="keyword">done</span> (100.00%)</span><br><span class="line">0:00 [0 rows, 0B] [0 rows/s, 0B/s]</span><br></pre></td></tr></table></figure><ul><li>查看 tpch Connector 的 schemas</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">presto&gt; show schemas from tpch;</span><br><span class="line">       Schema       </span><br><span class="line">--------------------</span><br><span class="line"> information_schema </span><br><span class="line"> sf1                </span><br><span class="line"> sf100              </span><br><span class="line"> sf1000             </span><br><span class="line"> sf10000            </span><br><span class="line"> sf100000           </span><br><span class="line"> sf300              </span><br><span class="line"> sf3000             </span><br><span class="line"> sf30000            </span><br><span class="line"> tiny               </span><br><span class="line">(10 rows)</span><br><span class="line"></span><br><span class="line">Query 20210606_142008_00010_4qtix, FINISHED, 1 node</span><br><span class="line">Splits: 19 total, 19 <span class="keyword">done</span> (100.00%)</span><br><span class="line">0:00 [10 rows, 119B] [141 rows/s, 1.65KB/s]</span><br></pre></td></tr></table></figure><ul><li>查看 tpch.sf1 的 tables</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">presto&gt; show tables from tpch.sf1;</span><br><span class="line">  Table   </span><br><span class="line">----------</span><br><span class="line"> customer </span><br><span class="line"> lineitem </span><br><span class="line"> nation   </span><br><span class="line"> orders   </span><br><span class="line"> part     </span><br><span class="line"> partsupp </span><br><span class="line"> region   </span><br><span class="line"> supplier </span><br><span class="line">(8 rows)</span><br><span class="line"></span><br><span class="line">Query 20210606_142111_00011_4qtix, FINISHED, 1 node</span><br><span class="line">Splits: 19 total, 19 <span class="keyword">done</span> (100.00%)</span><br><span class="line">0:00 [8 rows, 158B] [85 rows/s, 1.66KB/s]</span><br></pre></td></tr></table></figure><ul><li>查看 tpch.sf1.nation 表中的实际数据</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">presto&gt; select count(name) from tpch.sf1.nation;</span><br><span class="line"> _col0 </span><br><span class="line">-------</span><br><span class="line">    25 </span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">Query 20210606_142214_00012_4qtix, FINISHED, 1 node</span><br><span class="line">Splits: 21 total, 21 <span class="keyword">done</span> (100.00%)</span><br><span class="line">0:00 [25 rows, 0B] [358 rows/s, 0B/s]</span><br></pre></td></tr></table></figure><ul><li>选择使用特定 schema</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">presto&gt; use tpch.sf1;</span><br><span class="line">USE</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《Presto实战》<br>《Presto技术内幕》</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  本文为 Presto 的入门学习笔记。 Presto 是一个开源的分布式 SQL 查询引擎，它是为了高效查询不同系统和各种规模的数据源而从头开始设计和编写的一套系统。&lt;/p&gt;
    
    </summary>
    
      <category term="OLAP" scheme="http://yoursite.com/categories/OLAP/"/>
    
      <category term="Presto" scheme="http://yoursite.com/categories/OLAP/Presto/"/>
    
    
  </entry>
  
  <entry>
    <title>2020年终个人总结</title>
    <link href="http://yoursite.com/2021/02/01/2020%E5%B9%B4%E7%BB%88%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2021/02/01/2020年终个人总结/</id>
    <published>2021-02-01T06:00:40.000Z</published>
    <updated>2021-05-24T06:03:41.127Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Hey, password is required here.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="e8cb66f1889d332bb7f8280f899753257c5a0c67d437076bd79091327dff4dee">49f7eb9bea6cd6a47e660ee8aad95e5f339e339538ece7d1e61ba075caa7780d</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      Here&#39;s something encrypted, password is required to continue reading.
    
    </summary>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>Apache Iceberg</title>
    <link href="http://yoursite.com/2021/01/20/Apache-Iceberg/"/>
    <id>http://yoursite.com/2021/01/20/Apache-Iceberg/</id>
    <published>2021-01-20T08:19:22.000Z</published>
    <updated>2021-06-03T17:41:27.756Z</updated>
    
    <content type="html"><![CDATA[<p>本文为 Apache Iceberg 的入门学习笔记。</p><a id="more"></a><h2 id="Apache-Iceberg-简介"><a href="#Apache-Iceberg-简介" class="headerlink" title="Apache Iceberg 简介"></a>Apache Iceberg 简介</h2><p>官网定义：</p><p>Apache Iceberg is an open table format for huge analytic datasets. Iceberg delivers high query performance for tables with tens of petabytes of data, along with atomic commits, concurrent writes, and SQL-compatible table evolution.</p><ul><li><p>在文件 Format（Parquet/Avro/Orc）之上实现 table 语义<br>支持定义和变更Schema<br>支持 Hidden partition 和 Partition 变更<br>ACID 语义<br>历史版本回溯</p></li><li><p>特点<br>借助 partition 和 columns 统计信息实现分区裁剪<br>不绑定 HDFS，可拓展到 S3/OSS 等<br>容许多个 Writer 并发写入，乐观锁机制解决冲突</p></li></ul><h2 id="数据布局Layout"><a href="#数据布局Layout" class="headerlink" title="数据布局Layout"></a>数据布局Layout</h2><p><img src="Iceberg%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.png" alt></p><p>Layout 分为数据文件和元数据文件两部分。</p><p><img src="Iceberg_layout.png" alt></p><ul><li><p>数据文件（data files）<br>Iceberg 表真实存储数据的文件，一般存储在 data 目录下，以 “.parquet” 结尾。</p></li><li><p>清单文件（manifest file）<br>每行都是每个数据文件的详细描述，包括数据文件的状态、文件路径、分区信息、列级别的统计信息（比如每列的最大最小值、空值数等）。通过该文件，可以过滤掉无关数据，提高检索速度。</p></li><li><p>快照（snapshot）<br>快照代表一张表在某个时刻的状态。每个快照版本包含某个时刻的所有数据文件列表。data files 存储在不同的 manifest files 里， manifest files 存储在一个<br> manifest list 文件里面，而一个 manifest list 文件代表一个快照。</p></li></ul><h2 id="读写原理"><a href="#读写原理" class="headerlink" title="读写原理"></a>读写原理</h2><p><img src="%E8%AF%BB%E5%86%99%E5%8E%9F%E7%90%86_1.png" alt></p><p>绿色表示数据文件，蓝色表示 manifest，黄色表示快照。一次 manifest 可以认为是一次 transaction 的写入，m0 对应写了两个文件，分别落到了 Partiiotn-0 、Partition-1，m1 对应也写了两个文件，分别落到了 Partiiotn-1 、Partition-2。对于 S1 来说，是由 m0 和 m1 两个 manifest 组成的。</p><p><img src="%E8%AF%BB%E5%86%99%E5%8E%9F%E7%90%86_2.png" alt></p><p>基于 1 开始一次新的写入，写了一个 m2 的 transaction，写了一个数据文件 2 到 Partition-1，此时会新增一个 manifest m2 和 Snapshot S2，S2 会引用之前所有的 transaction m0 和 m1。</p><p>此时，如果要进行批量读取，就可以从 S1、S2、S3 中选择一个快照读取，比如选择了 S2，就是会把 m0、m1、m2 对应的数据全部 load 出来进行读取。</p><p>如果要进行增量读取，从 S0 开始把数据 load 出来，到 S1 的时候，会拿着 S1 的数据减去 S0 的数据得到增量的数据，然后交给计算引擎去做增量处理。</p><p><img src="%E8%AF%BB%E5%86%99%E5%8E%9F%E7%90%86_3.png" alt></p><h3 id="查询计划"><a href="#查询计划" class="headerlink" title="查询计划"></a>查询计划</h3><p>查询计划是指在表中“查询所需文件”的过程。</p><ul><li><p>元数据过滤<br>清单文件包括分区数据元组和每个数据文件的列级统计信息。在计划期内，查询谓词会自动转换为分区数据上的谓词，并首先应用于过滤数据文件。接下来，使用列级值计数，<br>空计数，下限和上限来消除与查询谓词不匹配的文件。</p></li><li><p>snapshot id<br>每个 snapshot id 会关联到一组 manifest files，而每一组 manifest files 包含很多 manifest file 。</p></li><li><p>manifest files 文件列表<br>每个 manifest file 文件又记录了当前 data 数据块的元数据信息，其中就包含了文件列的最大值和最小值，然后根据这个元数据信息，索引到具体的文件块，从而更快的查询到数据。</p></li></ul><h2 id="Flink-Iceberg-流式入湖"><a href="#Flink-Iceberg-流式入湖" class="headerlink" title="Flink + Iceberg 流式入湖"></a>Flink + Iceberg 流式入湖</h2><h3 id="入门实践"><a href="#入门实践" class="headerlink" title="入门实践"></a>入门实践</h3><p><a href="https://github.com/apache/iceberg/pull/1464/files" target="_blank" rel="noopener">详细参考文档</a></p><h4 id="本机启动-Hadoop-和-Hive"><a href="#本机启动-Hadoop-和-Hive" class="headerlink" title="本机启动 Hadoop 和 Hive"></a>本机启动 Hadoop 和 Hive</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动Hadoop</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$HADOOP_HOME</span>/sbin</span><br><span class="line">./start-all.sh</span><br><span class="line">hdfs dfs -ls /</span><br><span class="line">drwx-wx-wx   - miaowenting staff          0 2021-05-30 23:27 /tmp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动Hive</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$HIVE_HOME</span>/bin</span><br><span class="line">./hive --service metastore &amp;</span><br><span class="line">./hive --service hiveserver2 &amp;</span><br></pre></td></tr></table></figure><h4 id="本机启动-Flink"><a href="#本机启动-Flink" class="headerlink" title="本机启动 Flink"></a>本机启动 Flink</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动 Flink</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$FLINK_HOME</span>/bin</span><br><span class="line"></span><br><span class="line">./start-cluster.sh</span><br></pre></td></tr></table></figure><h4 id="准备-Flink-SQL-Client-环境"><a href="#准备-Flink-SQL-Client-环境" class="headerlink" title="准备 Flink SQL Client 环境"></a>准备 Flink SQL Client 环境</h4><ul><li>配置 HADOOP_CLASSPATH 环境变量：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> HADOOP_CLASSPATH=`<span class="variable">$HADOOP_HOME</span>/bin/hadoop classpath`</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><ul><li>下载运行时jar：<br><a href="https://repo.maven.apache.org/maven2/org/apache/iceberg/iceberg-flink-runtime/" target="_blank" rel="noopener">iceberg-flink-runtime.jar下载地址</a><br><a href="https://repo.maven.apache.org/maven2/org/apache/flink/" target="_blank" rel="noopener">flink-sql-connector-hive.jar下载地址</a></li></ul><ul><li>启动命令行：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$FLINK_HOME</span>/bin</span><br><span class="line"></span><br><span class="line">./sql-client.sh embedded \</span><br><span class="line">    -j /usr/<span class="built_in">local</span>/external/iceberg-flink-runtime-0.10.0.jar \</span><br><span class="line">    -j /usr/<span class="built_in">local</span>/external/flink-sql-connector-hive-2.2.0_2.11-1.11.2.jar \</span><br><span class="line">    shell</span><br></pre></td></tr></table></figure><p><img src="%E6%89%93%E5%BC%80SQL_Client.png" alt></p><h4 id="创建-Iceberg-的-Catalog"><a href="#创建-Iceberg-的-Catalog" class="headerlink" title="创建 Iceberg 的 Catalog"></a>创建 Iceberg 的 Catalog</h4><h5 id="创建-Hive-Catalog"><a href="#创建-Hive-Catalog" class="headerlink" title="创建 Hive Catalog"></a>创建 Hive Catalog</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">CATALOG</span> hive_catalog <span class="keyword">WITH</span>(</span><br><span class="line"><span class="string">'type'</span>=<span class="string">'iceberg'</span>,</span><br><span class="line"><span class="string">'catalog-type'</span>=<span class="string">'hive'</span>,</span><br><span class="line"><span class="string">'uri'</span>=<span class="string">'thrift://localhost:9083'</span>,</span><br><span class="line"><span class="string">'clients'</span>=<span class="string">'5'</span>,</span><br><span class="line"><span class="string">'property-version'</span>=<span class="string">'1'</span>,</span><br><span class="line"><span class="string">'warehouse'</span>=<span class="string">'hdfs://localhost:9000/user/hive/warehouse'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>可能出现以下报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; org.apache.flink.table.client.SqlClientException: Unexpected exception. This is a bug. Please consider filing an issue.</span><br><span class="line">at org.apache.flink.table.client.SqlClient.main(SqlClient.java:213)</span><br><span class="line">Caused by: org.apache.flink.table.client.gateway.SqlExecutionException: Could not create execution context.</span><br><span class="line">at org.apache.flink.table.client.gateway.local.ExecutionContext$Builder.build(ExecutionContext.java:870)</span><br><span class="line">at org.apache.flink.table.client.gateway.local.LocalExecutor.openSession(LocalExecutor.java:227)</span><br><span class="line">at org.apache.flink.table.client.SqlClient.start(SqlClient.java:108)</span><br><span class="line">at org.apache.flink.table.client.SqlClient.main(SqlClient.java:201)</span><br><span class="line">Caused by: java.lang.VerifyError: Stack map does not match the one at exception handler 69</span><br><span class="line">Exception Details:</span><br><span class="line">  Location:</span><br><span class="line">    org/apache/iceberg/hive/HiveCatalog.loadNamespaceMetadata(Lorg/apache/iceberg/catalog/Namespace;)Ljava/util/Map; @69: astore_2</span><br><span class="line">  Reason:</span><br><span class="line">    Type &apos;org/apache/hadoop/hive/metastore/api/NoSuchObjectException&apos; (current frame, stack[0]) is not assignable to &apos;org/apache/thrift/TException&apos; (stack map, stack[0])</span><br><span class="line">  Current Frame:</span><br><span class="line">    bci: @26</span><br><span class="line">    flags: &#123; &#125;</span><br><span class="line">    locals: &#123; &apos;org/apache/iceberg/hive/HiveCatalog&apos;, &apos;org/apache/iceberg/catalog/Namespace&apos; &#125;</span><br><span class="line">    stack: &#123; &apos;org/apache/hadoop/hive/metastore/api/NoSuchObjectException&apos; &#125;</span><br><span class="line">  Stackmap Frame:</span><br><span class="line">    bci: @69</span><br><span class="line">    flags: &#123; &#125;</span><br><span class="line">    locals: &#123; &apos;org/apache/iceberg/hive/HiveCatalog&apos;, &apos;org/apache/iceberg/catalog/Namespace&apos; &#125;</span><br><span class="line">    stack: &#123; &apos;org/apache/thrift/TException&apos; &#125;</span><br><span class="line">  Bytecode:</span><br><span class="line">    0x0000000: 2a2b b700 759a 0015 bb00 c759 12c9 04bd</span><br><span class="line">    0x0000010: 00cb 5903 2b53 b700 cebf 2ab4 0038 2bba</span><br><span class="line">    0x0000020: 0236 0000 b600 9ac0 0238 4d2a 2cb7 023c</span><br><span class="line">    0x0000030: 4eb2 00bd 1302 3e2b 2db9 0204 0100 b900</span><br><span class="line">    0x0000040: c504 002d b04d bb00 c759 2c12 c904 bd00</span><br><span class="line">    0x0000050: cb59 032b 53b7 0229 bf4d bb00 d059 bb00</span><br><span class="line">    0x0000060: d259 b700 d313 022b b600 d92b b600 dc13</span><br><span class="line">    0x0000070: 01a4 b600 d9b6 00e0 2cb7 00e3 bf4d b800</span><br><span class="line">    0x0000080: 40b6 00e6 bb00 d059 bb00 d259 b700 d313</span><br><span class="line">    0x0000090: 022d b600 d92b b600 dc13 01a4 b600 d9b6</span><br><span class="line">    0x00000a0: 00e0 2cb7 00e3 bf                      </span><br><span class="line">  Exception Handler Table:</span><br><span class="line">    bci [26, 68] =&gt; handler: 69</span><br><span class="line">    bci [26, 68] =&gt; handler: 69</span><br><span class="line">    bci [26, 68] =&gt; handler: 89</span><br><span class="line">    bci [26, 68] =&gt; handler: 125</span><br><span class="line">  Stackmap Table:</span><br><span class="line">    same_frame(@26)</span><br><span class="line">    same_locals_1_stack_item_frame(@69,Object[#111])</span><br><span class="line">    same_locals_1_stack_item_frame(@89,Object[#111])</span><br><span class="line">    same_locals_1_stack_item_frame(@125,Object[#113])</span><br><span class="line"></span><br><span class="line">at org.apache.iceberg.flink.CatalogLoader$HiveCatalogLoader.loadCatalog(CatalogLoader.java:95)</span><br><span class="line">at org.apache.iceberg.flink.FlinkCatalog.&lt;init&gt;(FlinkCatalog.java:104)</span><br><span class="line">at org.apache.iceberg.flink.FlinkCatalogFactory.createCatalog(FlinkCatalogFactory.java:132)</span><br><span class="line">at org.apache.iceberg.flink.FlinkCatalogFactory.createCatalog(FlinkCatalogFactory.java:122)</span><br><span class="line">at org.apache.flink.table.client.gateway.local.ExecutionContext.createCatalog(ExecutionContext.java:378)</span><br><span class="line">at org.apache.flink.table.client.gateway.local.ExecutionContext.lambda$null$5(ExecutionContext.java:626)</span><br><span class="line">at java.util.HashMap.forEach(HashMap.java:1289)</span><br><span class="line">at org.apache.flink.table.client.gateway.local.ExecutionContext.lambda$initializeCatalogs$6(ExecutionContext.java:625)</span><br><span class="line">at org.apache.flink.table.client.gateway.local.ExecutionContext.wrapClassLoader(ExecutionContext.java:264)</span><br><span class="line">at org.apache.flink.table.client.gateway.local.ExecutionContext.initializeCatalogs(ExecutionContext.java:624)</span><br><span class="line">at org.apache.flink.table.client.gateway.local.ExecutionContext.initializeTableEnvironment(ExecutionContext.java:523)</span><br><span class="line">at org.apache.flink.table.client.gateway.local.ExecutionContext.&lt;init&gt;(ExecutionContext.java:183)</span><br><span class="line">at org.apache.flink.table.client.gateway.local.ExecutionContext.&lt;init&gt;(ExecutionContext.java:136)</span><br><span class="line">at org.apache.flink.table.client.gateway.local.ExecutionContext$Builder.build(ExecutionContext.java:859)</span><br></pre></td></tr></table></figure><p>解决办法：</p><ol><li><p>iceberg-flink-runtime-0.10.0.jar、flink-sql-connector-hive-2.2.0_2.11-1.11.2.jar 不要放在 $FLINK_HOME/lib 目录下</p></li><li><p>打开 sql-client.sh 文件，在 jar 包启动的地方加上 -noverify 跳过字节码校验。<br><img src="%E5%88%9B%E5%BB%BAhive_catalog%E6%8A%A5%E9%94%99%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%951.png" alt></p></li></ol><p>type：表示 flink-connector 的连接类型<br>catalog-type：表示创建 catalog 的类型。目前支持 hive 和 hadoop 两种类型<br>uri：Hive metastore 的 thrift URI 地址<br>clients：Hive metastore 客户端线程池大小，默认值为2<br>property-version：Connector 的属性值版本号，当前版本为1，这个值主要用来确保 iceberg connector 的 property 向后兼容</p><p><img src="%E5%88%9B%E5%BB%BAhive_catalog%E6%88%90%E5%8A%9F.png" alt></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USE</span> <span class="keyword">CATALOG</span> hive_catalog;</span><br></pre></td></tr></table></figure><h5 id="创建-Hadoop-Catalog"><a href="#创建-Hadoop-Catalog" class="headerlink" title="创建 Hadoop Catalog"></a>创建 Hadoop Catalog</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">CATALOG</span> hadoop_catalog <span class="keyword">WITH</span>(</span><br><span class="line"><span class="string">'type'</span>=<span class="string">'iceberg'</span>,</span><br><span class="line"><span class="string">'catalog-type'</span>=<span class="string">'hadoop'</span>,</span><br><span class="line"><span class="string">'warehouse'</span>=<span class="string">'hdfs://localhost:9000/warehouse/path'</span>,</span><br><span class="line"><span class="string">'property-version'</span>=<span class="string">'1'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USE</span> <span class="keyword">CATALOG</span> hadoop_catalog;</span><br></pre></td></tr></table></figure><p>warehouse：表示 iceberg 的 metadata 的 data 数据存放的文件路径。</p><p><img src="%E5%88%9B%E5%BB%BAhadoop_catalog%E6%88%90%E5%8A%9F.png" alt></p><h5 id="创建-Custom-Catalog"><a href="#创建-Custom-Catalog" class="headerlink" title="创建 Custom Catalog"></a>创建 Custom Catalog</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">CATALOG</span> my_catalog <span class="keyword">WITH</span> (</span><br><span class="line">  <span class="string">'type'</span>=<span class="string">'iceberg'</span>,</span><br><span class="line">  <span class="string">'catalog-impl'</span>=<span class="string">'com.my.custom.CatalogImpl'</span>,</span><br><span class="line">  <span class="string">'my-additional-catalog-config'</span>=<span class="string">'my-value'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="通过-YAML-统一新增-Catalog"><a href="#通过-YAML-统一新增-Catalog" class="headerlink" title="通过 YAML 统一新增 Catalog"></a>通过 YAML 统一新增 Catalog</h5><p>修改 sql-client-defaults.yaml 文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">catalogs:</span>  <span class="comment"># empty list</span></span><br><span class="line"><span class="attr">   - name:</span> <span class="string">hadoop_catalog</span></span><br><span class="line"><span class="attr">     type:</span> <span class="string">iceberg</span></span><br><span class="line"><span class="attr">     catalog-type:</span> <span class="string">hadoop</span></span><br><span class="line"><span class="attr">     warehouse:</span> <span class="attr">hdfs://localhost:9000/warehouse/path</span></span><br><span class="line"><span class="attr">     property-version:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">   - name:</span> <span class="string">hive_catalog</span></span><br><span class="line"><span class="attr">     type:</span> <span class="string">iceberg</span></span><br><span class="line"><span class="attr">     catalog-type:</span> <span class="string">hive</span></span><br><span class="line"><span class="attr">     uri:</span> <span class="attr">thrift://localhost:9083</span></span><br><span class="line"><span class="attr">     clients:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">     warehouse:</span> <span class="attr">hdfs://localhost:9000/user/hive/warehouse</span></span><br><span class="line"><span class="attr">     property-version:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> iceberg_db;</span><br><span class="line"></span><br><span class="line"><span class="keyword">USE</span> <span class="string">`iceberg_db`</span>;</span><br></pre></td></tr></table></figure><p><img src="%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E6%88%90%E5%8A%9F.png" alt></p><h4 id="创建-Iceberg-表"><a href="#创建-Iceberg-表" class="headerlink" title="创建 Iceberg 表"></a>创建 Iceberg 表</h4><ul><li>首先要进入到指定的 catalog 和 database 目录下</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USE</span> <span class="keyword">CATALOG</span> hive_catalog;</span><br><span class="line"></span><br><span class="line"><span class="keyword">USE</span> iceberg_db;</span><br></pre></td></tr></table></figure><ul><li>创建非分区表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建 Iceberg 非分区表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> sample_iceberg (</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">BIGINT</span> <span class="keyword">COMMENT</span> <span class="string">'unique id'</span>,</span><br><span class="line">  <span class="keyword">data</span> <span class="keyword">STRING</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入测试数据1</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> sample_iceberg <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="string">'test1'</span>);</span><br><span class="line"></span><br><span class="line">[INFO] Submitting SQL <span class="keyword">update</span> <span class="keyword">statement</span> <span class="keyword">to</span> the cluster...</span><br><span class="line">[INFO] <span class="keyword">Table</span> <span class="keyword">update</span> <span class="keyword">statement</span> has been successfully submitted <span class="keyword">to</span> the cluster:</span><br><span class="line">Job <span class="keyword">ID</span>: <span class="number">79</span>f18eee231895abd2ab15fbd0641ade</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入测试数据2</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> sample_iceberg <span class="keyword">VALUES</span> (<span class="number">2</span>,<span class="string">'test2'</span>);</span><br><span class="line"></span><br><span class="line">[INFO] Submitting SQL <span class="keyword">update</span> <span class="keyword">statement</span> <span class="keyword">to</span> the cluster...</span><br><span class="line">[INFO] <span class="keyword">Table</span> <span class="keyword">update</span> <span class="keyword">statement</span> has been successfully submitted <span class="keyword">to</span> the cluster:</span><br><span class="line">Job <span class="keyword">ID</span>: c0afa452656f42de5df6bc745fbaf022</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询已插入的数据</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> sample_iceberg;</span><br></pre></td></tr></table></figure><p><img src="%E6%9F%A5%E8%AF%A2Iceberg%E9%9D%9E%E5%88%86%E5%8C%BA%E8%A1%A8%E6%95%B0%E6%8D%AE.png" alt></p><ul><li>创建分区表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建 Iceberg 分区表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> sample_iceberg_partition (</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">BIGINT</span> <span class="keyword">COMMENT</span> <span class="string">'unique id'</span>,</span><br><span class="line">  <span class="keyword">data</span> <span class="keyword">STRING</span></span><br><span class="line">) </span><br><span class="line">PARTITIONED <span class="keyword">BY</span> (<span class="keyword">data</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入测试数据1</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> sample_iceberg_partition <span class="keyword">PARTITION</span>(<span class="keyword">data</span>=<span class="string">'city'</span>) <span class="keyword">SELECT</span> <span class="number">86</span>;</span><br><span class="line"></span><br><span class="line">[INFO] Submitting SQL <span class="keyword">update</span> <span class="keyword">statement</span> <span class="keyword">to</span> the cluster...</span><br><span class="line">[INFO] <span class="keyword">Table</span> <span class="keyword">update</span> <span class="keyword">statement</span> has been successfully submitted <span class="keyword">to</span> the cluster:</span><br><span class="line">Job <span class="keyword">ID</span>: <span class="number">9</span>ff0581b9b16ee01c0c849c50608f1b2</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询已插入的数据</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> sample_iceberg_partition;</span><br></pre></td></tr></table></figure><p><img src="%E6%9F%A5%E8%AF%A2Iceberg%E5%88%86%E5%8C%BA%E8%A1%A8%E6%95%B0%E6%8D%AE.png" alt></p><ul><li>创建带 WITH 参数的表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">-- 创建表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> sample_iceberg_connector (</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">BIGINT</span> <span class="keyword">COMMENT</span> <span class="string">'unique id'</span>,</span><br><span class="line"><span class="keyword">data</span> <span class="keyword">STRING</span></span><br><span class="line">) <span class="keyword">WITH</span> (</span><br><span class="line"><span class="string">'connector'</span>=<span class="string">'iceberg'</span>,</span><br><span class="line">  <span class="string">'catalog-type'</span>=<span class="string">'hive'</span>,</span><br><span class="line">  <span class="string">'uri'</span>=<span class="string">'thrift://localhost:9083'</span>,</span><br><span class="line">  <span class="string">'clients'</span>=<span class="string">'5'</span>,</span><br><span class="line">  <span class="string">'property-version'</span>=<span class="string">'1'</span>,</span><br><span class="line">  <span class="string">'warehouse'</span>=<span class="string">'hdfs://localhost:9000/warehouse/path'</span>,</span><br><span class="line"><span class="string">'write.format.default'</span>=<span class="string">'ORC'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><img src="%E5%88%9B%E5%BB%BAIceberg%E8%A1%A8%E6%88%90%E5%8A%9F.png" alt></p><p>支持 PARTITION BY 子句，用来设置分区字段<br>支持 COMMENT ‘table comment’ 子句<br>支持 WITH(‘key’=’value’,…) 子句，用来设置 table 级别的配置属性</p><p>暂不支持 computed column<br>暂不支持 primary key<br>暂不支持定义 watermark</p><h4 id="Flink-SQL-写入"><a href="#Flink-SQL-写入" class="headerlink" title="Flink SQL 写入"></a>Flink SQL 写入</h4><ul><li>修改 flink-conf.yaml 配置文件，配置 checkpoint<br>因为 flink 提交 Iceberg 的信息是在每次 checkpoint 时提交的，所以需要开启 checkpoint</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启 checkpoint</span></span><br><span class="line"><span class="string">state.backend:</span> <span class="string">filesystem</span></span><br><span class="line"><span class="string">state.backend.async:</span> <span class="literal">true</span></span><br><span class="line"><span class="string">state.backend.fs.memory-threshold:</span> <span class="number">1024</span></span><br><span class="line"><span class="string">state.checkpoints.dir:</span> <span class="attr">hdfs://localhost:9000/flink-checkpoints</span></span><br><span class="line"><span class="string">state.savepoints.dir:</span> <span class="attr">hdfs://localhost:9000/flink-checkpoints</span></span><br><span class="line"><span class="string">state.backend.incremental:</span> <span class="literal">false</span></span><br><span class="line"><span class="string">state.backend.local-recovery:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment"># state.checkpoints.num-retained: 1</span></span><br><span class="line"><span class="string">taskmanager.state.local.root-dirs:</span> <span class="string">none</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># checkpoint 间隔时间</span></span><br><span class="line"><span class="string">execution.checkpointing.interval:</span> <span class="number">10</span><span class="string">s</span></span><br><span class="line"><span class="comment"># checkpoint 失败容忍次数</span></span><br><span class="line"><span class="string">execution.checkpointing.tolerable-failed-checkpoints:</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><ul><li>首先要进入到指定的 catalog 和 database 目录下</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USE</span> <span class="keyword">CATALOG</span> hive_catalog;</span><br><span class="line"></span><br><span class="line"><span class="keyword">USE</span> iceberg_db;</span><br></pre></td></tr></table></figure><ul><li>创建一个 iceberg 的 sink connector</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">-- 创建表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_sink_iceberg (</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">BIGINT</span> <span class="keyword">COMMENT</span> <span class="string">'unique id'</span>,</span><br><span class="line">  <span class="keyword">data</span> <span class="keyword">STRING</span></span><br><span class="line">) <span class="keyword">WITH</span> (</span><br><span class="line">  <span class="string">'connector'</span>=<span class="string">'iceberg'</span>,</span><br><span class="line">  <span class="string">'catalog-type'</span>=<span class="string">'hive'</span>,</span><br><span class="line">  <span class="string">'uri'</span>=<span class="string">'thrift://localhost:9083'</span>,</span><br><span class="line">  <span class="string">'clients'</span>=<span class="string">'5'</span>,</span><br><span class="line">  <span class="string">'property-version'</span>=<span class="string">'1'</span>,</span><br><span class="line">  <span class="string">'warehouse'</span>=<span class="string">'hdfs://localhost:9000/warehouse/path'</span>,</span><br><span class="line">  <span class="string">'write.format.default'</span>=<span class="string">'ORC'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>创建一个 datagen 的 source connector</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_source_datagen (</span><br><span class="line"> userid <span class="built_in">INT</span>,</span><br><span class="line"> f_random_str <span class="keyword">STRING</span></span><br><span class="line">) <span class="keyword">WITH</span> (</span><br><span class="line"> <span class="string">'connector'</span>=<span class="string">'datagen'</span>,</span><br><span class="line"> <span class="string">'rows-per-second'</span>=<span class="string">'5'</span>,</span><br><span class="line"> <span class="string">'fields.userid.kind'</span>=<span class="string">'random'</span>,</span><br><span class="line"> <span class="string">'fields.userid.min'</span>=<span class="string">'1'</span>,</span><br><span class="line"> <span class="string">'fields.userid.max'</span>=<span class="string">'1000'</span>,</span><br><span class="line"> <span class="string">'fields.f_random_str.length'</span>=<span class="string">'10'</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询 source 数据，会有源源不断的数据输出</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_source_datagen;</span><br></pre></td></tr></table></figure><ul><li>通过设置 execution.type 来切换提交流作业和批作业</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 流式</span></span><br><span class="line"><span class="keyword">SET</span> execution.type = streaming;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 批</span></span><br><span class="line"><span class="keyword">SET</span> execution.type = batch;</span><br></pre></td></tr></table></figure><ul><li>借助流式作业（默认）写入数据到 Apache Iceberg 表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_sink_iceberg <span class="keyword">SELECT</span> userid,f_random_str <span class="keyword">FROM</span> table_source_datagen;</span><br><span class="line"></span><br><span class="line">[INFO] Submitting SQL <span class="keyword">update</span> <span class="keyword">statement</span> <span class="keyword">to</span> the cluster...</span><br><span class="line">[INFO] <span class="keyword">Table</span> <span class="keyword">update</span> <span class="keyword">statement</span> has been successfully submitted <span class="keyword">to</span> the cluster:</span><br><span class="line">Job <span class="keyword">ID</span>: <span class="number">52</span>c57f566aa6da61d46ec2fc73b74b59</span><br></pre></td></tr></table></figure><ul><li>查询 sink 到 iceberg 表里的数据</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_sink_iceberg;</span><br></pre></td></tr></table></figure><p><img src="%E6%9F%A5%E8%AF%A2Iceberg%E5%AE%9E%E6%97%B6%E5%86%99%E5%85%A5%E7%9A%84%E6%95%B0%E6%8D%AE.png" alt></p><h4 id="DataStream-写入"><a href="#DataStream-写入" class="headerlink" title="DataStream 写入"></a>DataStream 写入</h4><h5 id="批量读取"><a href="#批量读取" class="headerlink" title="批量读取"></a>批量读取</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">StreamExecutionEnvironment env = StreamExecutionEnvironment.createLocalEnvironment();</span><br><span class="line">TableLoader tableLoader = TableLoader.fromHadooptable(<span class="string">"hdfs://nn:8020/warehouse/path"</span>);</span><br><span class="line">DataStream&lt;RowData&gt; batch = FlinkSource.forRowData()</span><br><span class="line">     .env(env)</span><br><span class="line">     .tableLoader(loader)</span><br><span class="line">     .streaming(<span class="keyword">false</span>)</span><br><span class="line">     .build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Print all records to stdout.</span></span><br><span class="line">batch.print();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Submit and execute this batch read job.</span></span><br><span class="line">env.execute(<span class="string">"Test Iceberg Batch Read"</span>);</span><br></pre></td></tr></table></figure><h5 id="流式读取"><a href="#流式读取" class="headerlink" title="流式读取"></a>流式读取</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">StreamExecutionEnvironment env = StreamExecutionEnvironment.createLocalEnvironment();</span><br><span class="line">TableLoader tableLoader = TableLoader.fromHadoopTable(<span class="string">"hdfs://nn:8020/warehouse/path"</span>);</span><br><span class="line">DataStream&lt;RowData&gt; stream = FlinkSource.forRowData()</span><br><span class="line">     .env(env)</span><br><span class="line">     .tableLoader(loader)</span><br><span class="line">     .streaming(<span class="keyword">true</span>)</span><br><span class="line">     .startSnapshotId(<span class="number">3821550127947089987L</span>)</span><br><span class="line">     .build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Print all records to stdout.</span></span><br><span class="line">stream.print();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Submit and execute this streaming read job.</span></span><br><span class="line">env.execute(<span class="string">"Test Iceberg streaming Read"</span>);</span><br></pre></td></tr></table></figure><h5 id="追加写入"><a href="#追加写入" class="headerlink" title="追加写入"></a>追加写入</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">StreamExecutionEnvironment env = ...;</span><br><span class="line"></span><br><span class="line">DataStream&lt;RowData&gt; input = ... ;</span><br><span class="line">Configuration hadoopConf = <span class="keyword">new</span> Configuration();</span><br><span class="line">TableLoader tableLoader = TableLoader.fromHadoopTable(<span class="string">"hdfs://nn:8020/warehouse/path"</span>, hadoopConf);</span><br><span class="line"></span><br><span class="line">FlinkSink.forRowData(input)</span><br><span class="line">    .tableLoader(tableLoader)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">env.execute(<span class="string">"Test Iceberg DataStream"</span>);</span><br></pre></td></tr></table></figure><h5 id="覆盖写入"><a href="#覆盖写入" class="headerlink" title="覆盖写入"></a>覆盖写入</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">StreamExecutionEnvironment env = ...;</span><br><span class="line"></span><br><span class="line">DataStream&lt;RowData&gt; input = ... ;</span><br><span class="line">Configuration hadoopConf = <span class="keyword">new</span> Configuration();</span><br><span class="line">TableLoader tableLoader = TableLoader.fromHadoopTable(<span class="string">"hdfs://nn:8020/warehouse/path"</span>, hadoopConf);</span><br><span class="line"></span><br><span class="line">FlinkSink.forRowData(input)</span><br><span class="line">    .tableLoader(tableLoader)</span><br><span class="line">    .overwrite(<span class="keyword">true</span>)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">env.execute(<span class="string">"Test Iceberg DataStream"</span>);</span><br></pre></td></tr></table></figure><h4 id="修改表属性"><a href="#修改表属性" class="headerlink" title="修改表属性"></a>修改表属性</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">sample</span> <span class="keyword">SET</span> (<span class="string">'write.format.default'</span>=<span class="string">'avro'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">sample</span> <span class="keyword">RENAME</span> <span class="keyword">TO</span> <span class="string">`hive_catalog.default.new_sample`</span>;</span><br></pre></td></tr></table></figure><ul><li>Flink SQL 目前支持修改 iceberg 表的相关属性</li><li>Flink SQL 暂不支持添加列、修改列、删除列的操作，但可以通过 Iceberg Java API 来完成</li></ul><h4 id="删除表、库和-Catalog"><a href="#删除表、库和-Catalog" class="headerlink" title="删除表、库和 Catalog"></a>删除表、库和 Catalog</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">--  删除表</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">sample</span>；</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除库</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">DATABASE</span> test_db;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除 catalog</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">CATALOG</span> hive_catalog;</span><br></pre></td></tr></table></figure><h3 id="Flink-Sink-写入原理"><a href="#Flink-Sink-写入原理" class="headerlink" title="Flink Sink 写入原理"></a>Flink Sink 写入原理</h3><p><img src="Flink_Sink%E5%8E%9F%E7%90%86.png" alt></p><ul><li><p>IcebergStreamWriter<br>主要用来写入记录到对应的 avro、parquet、orc 文件，生成一个对应的 Iceberg datafile，并发送给下游算子。</p></li><li><p>IcebergFilesCommitter<br>为每个 checkpointId 维护了一个 datafile 文件列表，即 Map&lt;Long,List<datafile>&gt;，这样即使中间有某个 checkpoint 的 transaction 提交失败了，<br>它的 datafile 文件仍然维护在 State 中，依然可以通过后续的 checkpoint 来提交数据到 Iceberg 表中。</datafile></p></li></ul><p><img src="flink_sink_state%E8%AE%BE%E8%AE%A1.png" alt></p><p>Flink Sink State 改进：</p><ol><li><p>多个不同的 Flink Job 写入同一个 Iceberg 表时，如何保证写入数据的正确性？</p></li><li><p>在云端环境下，metastore 所在的数据中心和日志数据中心是两个数据中心。这时候，可能导致 Commit Transaction 到 Iceberg 经常失败的现象，长期失败会导致 State 膨胀。<br>如何解决这个问题。</p></li></ol><h3 id="Flink-Sink-小文件处理"><a href="#Flink-Sink-小文件处理" class="headerlink" title="Flink Sink 小文件处理"></a>Flink Sink 小文件处理</h3><ul><li><p>小数据量的合并<br>在 IcebergFilesCommitter 之后添加一个 Compactor 算子，用来实现少量小文件的频繁合并。</p></li><li><p>大数据量的合并<br>设计 Flink Batch 作业，对接 Iceberg 的 RewriteDataFilesAction 来实现表内的大数据合并。</p></li></ul><h2 id="社区规划"><a href="#社区规划" class="headerlink" title="社区规划"></a>社区规划</h2><ol><li><p>预计将在下个 Apache Iceberg Release 中支持：<br>a. Flink Sink 流式入湖和批量入湖<br>b. Flink Streaming Reader<br>c. Flink Batch Reader</p></li><li><p>Flink + Iceberg 对小文件的处理<br>a. Committer 任务之后添加 Compactor 算子，专门处理少量数据的 compaction<br>b. 设计 Flink 批任务来处理大数据量的 compaction</p></li><li><p>对接 Iceberg 的 row-level delete 功能<br>a. 通过 Flink 实现 CDC 日志的实时写入和分析<br>b. 通过 Flink 实现 CDC 日志的增量拉取<br>c. Flink + Iceberg 支持批量的数据更新</p></li><li><p>更加完善的 Flink SQL 支持<br>a. 更富的 Flink DDL 支持，例如支持增删改 column<br>b. 往 Flink 社区讨论支持 hidden partition</p></li><li><p>通过 SQL extension 来完成日常数据管理<br>a. 在 Icebeg 内实现 compaction 语法和命令<br>b. SQL 查看 history、snapshot、manifest、files 文件</p></li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.51cto.com/u_15023245/2619826" target="_blank" rel="noopener">基于 Flink+Iceberg 构建企业级实时数据湖 - 文章</a><br><a href="https://www.bilibili.com/video/BV14A411J7e6?p=4" target="_blank" rel="noopener">基于 Flink+Iceberg 构建企业级实时数据湖 - 视频</a><br><a href="https://www.yuque.com/deadwind/fusion/iqc65z?language=zh-cn" target="_blank" rel="noopener">Apache Iceberg调研</a><br><a href="https://www.bilibili.com/video/av929015385/" target="_blank" rel="noopener">Apache Iceberg 0.11.0 最新解读视频，胡争</a><br><a href="https://www.cnblogs.com/swordfall/p/14548574.html#auto_id_0" target="_blank" rel="noopener">Flink集成Iceberg简介</a><br><a href="https://github.com/apache/iceberg/blob/master/site/docs/flink.md" target="_blank" rel="noopener">Flink+Iceberg 社区使用文档</a><br><a href="https://blog.csdn.net/joniers/article/details/116590366" target="_blank" rel="noopener">Flink+iceberg 环境搭建及问题处理</a><br><a href="https://cloud.tencent.com/developer/article/1727735" target="_blank" rel="noopener">Flink集成数据湖之实时数据写入 Iceberg</a><br><a href="https://mp.weixin.qq.com/s/2MxyxOYrHi5HWmkKtXYjBg" target="_blank" rel="noopener">Flink + Iceberg 在去哪儿的实时数仓实践</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为 Apache Iceberg 的入门学习笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="DataLake" scheme="http://yoursite.com/categories/DataLake/"/>
    
      <category term="Iceberg" scheme="http://yoursite.com/categories/DataLake/Iceberg/"/>
    
    
  </entry>
  
  <entry>
    <title>初识数据湖</title>
    <link href="http://yoursite.com/2021/01/20/%E5%88%9D%E8%AF%86%E6%95%B0%E6%8D%AE%E6%B9%96/"/>
    <id>http://yoursite.com/2021/01/20/初识数据湖/</id>
    <published>2021-01-20T08:19:22.000Z</published>
    <updated>2021-06-03T17:41:32.764Z</updated>
    
    <content type="html"><![CDATA[<p>对于数据湖的入门者，本文记录一下对数据湖的初步认识。</p><a id="more"></a><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>数据湖是个什么概念呢？一般来说把一家企业产生的数据维护在一个平台内，这个平台我们称之为“数据湖”。</p><p>个人认为数据湖应该是一种不断演进中、可扩展的大数据存储、处理、分析的基础设施。以数据为导向，实现任意来源、任意规模、任意类型数据的全量获取、全量存储、多模式处理与全生命周期管理；并通过与各类外部异构数据源的交互集成，支持各类企业级应用。</p><p><img src="%E6%95%B0%E6%8D%AE%E6%B9%96%E5%9F%BA%E6%9C%AC%E8%83%BD%E5%8A%9B%E7%A4%BA%E6%84%8F.png" alt></p><p>看下面这幅图，这个湖的数据来源多种多样，有的可能是结构化数据，有的可能是非结构化数据，有的甚至是二进制数据。有一拨人站在湖的入口，用设备在检测水质，这对应着数据湖上的流处理作业；有一拨抽水机从湖里抽水，这对应着数据湖的批处理作业；还有一批人在船头钓鱼或者在岸上捕鱼，这对应着数据科学家从数据湖中通过机器学习的手段提取价值。<br><img src="%E5%88%9D%E8%AF%86%E6%95%B0%E6%8D%AE%E6%B9%96.png" alt></p><p>总结起来，数据湖主要有 4 个方面的特点：</p><ul><li><p>存储原始数据，这些原始数据的来源非常丰富<br>结构化数据<br>半结构化数据<br>非结构化数据<br>二进制数据（图片等）</p></li><li><p>支持多种计算模型<br>批处理<br>流计算<br>交互式分析<br>机器学习</p></li><li><p>有完善的数据管理能力<br>能做到多种数据源接入<br>时间不同数据之间的连接<br>支持 Schema 管理<br>支持权限管理</p></li><li><p>灵活的底层存储<br>一般用 S3/OSS/HDFS 这种廉价的分布式文件系统<br>支持 Parquet/Avro/Orc 文件格式<br>支持数据缓存加速<br>满足对应场景的数据分析需求</p></li></ul><p>那么，开源的数据湖架构一般是什么样的呢？一般分为四层：</p><ul><li>最底层是廉价、弹性可扩展的分布式文件系统，云上用户 S3 和 OSS 这种对象存储用的更多一些，毕竟价格便宜很多；非云上用户一般采用自己维护的 HDFS。</li><li>第二层是数据加速层。提供本地数据缓存（多块 SSD）和元数据加速服务。数据湖架构是一个存储计算彻底分离的架构，如果所有的数据访问都远程读取文件系统上的数据，那么性能和成本开销很大。如果能把经常访问到的一些热点数据缓存在计算节点本地，这就非常自然的实现了冷热分离，一方面能获取到不错的本地读取性能，另一方面还节省了远程访问的带宽。这一层里边，通常会选择开源的 alluxio，或者选择阿里云上的 Jindofs。</li><li>第三层就是 Table Format 层，提供面向用户的主表级语义。要是把一些数据文件封装成一个有业务语义的 table，提供 ACID、snapshot、schema、partition 等表级别的语义。一般对应着开源的 Delta、Iceberg、Hudi 等项目。对一些用户来说，他们认为 Delta、Iceberg、Hudi 这些就是数据湖，其实这几个项目只是数据湖这个架构里边的一环，只是因为它们离用户最近，屏蔽了底层的很多细节，所以才会造成这样的误解。数据湖和数据中台一样，是一种架构理念，而不是专指某一个技术。</li><li>最上层就是不同计算场景的计算引擎了，满足不同的分析需求。开源的一般有 Spark、Flink、Hive、Presto、Hive MR 等，这一批计算引擎可以同时访问同一张数据湖的表。</li></ul><p><img src="%E6%95%B0%E6%8D%AE%E6%B9%96%E7%9A%84%E4%B8%80%E8%88%AC4%E5%B1%82%E6%9E%B6%E6%9E%84.png" alt></p><h3 id="数据湖-vs-数据仓库"><a href="#数据湖-vs-数据仓库" class="headerlink" title="数据湖 vs 数据仓库"></a>数据湖 vs 数据仓库</h3><p>比较数据来源于 AWS。</p><table><thead><tr><th>特性</th><th>数据仓库</th><th>数据湖</th></tr></thead><tbody><tr><td>数据</td><td>来自事务系统、运营数据库和业务线应用程序的关系数据</td><td>来自 IoT设备、网站、移动应用程序、社交媒体和企业应用程序的非关系和关系数据</td></tr><tr><td>Schema</td><td>设计在数据仓库实施之前（写入型Schema）</td><td>写入在分析时（读取型Schema）</td></tr><tr><td>性价比</td><td>更快查询结果会带来较高存储成本</td><td>更快查询结果只需较低存储成本</td></tr><tr><td>数据质量</td><td>可作为重要事实依据的高度监管数据</td><td>任何可以或无法进行监管的数据（例如原始数据）</td></tr><tr><td>用户</td><td>业务分析师</td><td>数据科学家、数据开发人员和业务分析师（使用监管数据）</td></tr><tr><td>分析</td><td>批处理报告、BI和可视化</td><td>机器学习、预测分析、数据发现和分析</td></tr></tbody></table><h3 id="Flink数据湖业务场景"><a href="#Flink数据湖业务场景" class="headerlink" title="Flink数据湖业务场景"></a>Flink数据湖业务场景</h3><h4 id="场景一-构建实时Data-Pipeline"><a href="#场景一-构建实时Data-Pipeline" class="headerlink" title="场景一: 构建实时Data Pipeline"></a>场景一: 构建实时Data Pipeline</h4><p><img src="%E5%9C%BA%E6%99%AF1_%E6%9E%84%E5%BB%BA%E5%AE%9E%E6%97%B6Data_pipeline.png" alt></p><p>首先，Flink+Iceberg 最经典的一个应用场景就是构建实时的 Data Pipeline。业务端产生大量的日志数据，被导入到 Kafka 这样的消息队列，运用 Flink 流计算引擎执行 ETL 后，导入到 Apache Iceberg 原始表中。有一些业务场景需要直接跑分析作业来分析原始表的数据，而另外一些业务需要对数据做进一步的提纯，那么我们可以再起一个 Flink 作业从 Apache Iceberg 表中消费增量数据，经过处理之后写到到提纯之后的 Iceberg 表中。此时，可能还有业务需要对数据做进一步的聚合，那么我们继续在 Iceberg 表上启动增量 Flink 作业，将聚合之后的数据结果写入到聚合表中。</p><p>有人可能会提出质疑，这个场景好像通过 Flink+Hive 也能实现。Flink+Hive 的确可以实现，但写入到 Hive 的数据更多的是为了实现数仓的数据分析，而不是为了做增量拉取。一般来说，Hive 的增量写入是以 partition 为单位，时间是 15min 以上，Flink 长期高频率地写入会造成 partition 膨胀。而 Iceberg 允许实现 1min 甚至 30s 的增量写入，这样就可以大大提高了端到端数据的实时性，上层的分析作业可以看到更新的数据，下游的增量作业也可以读取到更新的数据。</p><ul><li><p>核心优势：<br>可以借助 Flink 实现数据 exactly-once 语义地入湖和出湖<br>新写入数据可以在 checkpoint 周期内可见<br>可以方便地构建 data pipeline，满足不同业务层的数据加工和分析需求</p></li><li><p>对比 Hive 方案：<br>hive 的增量写入以 partition 为单位，长期高频率的 checkpoint 写入，会导致 hive partition 的膨胀<br>本质上 hive 的增量写入和消费粒度都太大，实时性无法比肩 iceberg</p></li></ul><h4 id="场景二-CDC数据实时摄入摄出"><a href="#场景二-CDC数据实时摄入摄出" class="headerlink" title="场景二: CDC数据实时摄入摄出"></a>场景二: CDC数据实时摄入摄出</h4><p><img src="%E5%9C%BA%E6%99%AF%E4%BA%8C_CDC%E6%95%B0%E6%8D%AE%E5%AE%9E%E6%97%B6%E6%91%84%E5%85%A5%E5%B0%84%E5%87%BA.png" alt></p><p>第二个经典的场景，就是可以用 Flink+Iceberg 分析来自 MySQL 等关系型数据库的 binlog 等。</p><p>一方面，Flink 已经原生的支持 CDC 数据解析，一条 binlog 数据通过 flink-cdc-connector 拉取之后，自动转换成 Flink runtime 能识别的 insert、delete、update_before、update_after 四种消息，供用户进一步的实时计算。</p><p>另一方面，Iceberg 已经较为完善的实现了 equality delete 功能，也就是用户定义好到删除的 record，直接写到 Iceberg 表内就可以删除对应的行，本身就是为了实现数据湖的流式删除。在 Iceberg 未来的版本中，用户将不需要设计任何额外的业务字段，不用写几行代码就可以完成 binlog 流式入湖到 Iceberg （社区 PR 已经提供了一个 Flink 写入 CDC 数据的原型）。</p><p>此外，CDC 数据成功入湖 Iceberg 之后，常见的计算引擎 Presto、Spark、Hive 等，都可以实时的读取到 Iceberg 表中最新的数据。</p><h3 id="场景三-近实时场景的流批统一"><a href="#场景三-近实时场景的流批统一" class="headerlink" title="场景三: 近实时场景的流批统一"></a>场景三: 近实时场景的流批统一</h3><p><img src="%E5%9C%BA%E6%99%AF%E4%B8%89_%E8%BF%91%E5%AE%9E%E6%97%B6%E5%9C%BA%E6%99%AF%E7%9A%84%E6%89%B9%E6%B5%81%E7%BB%9F%E4%B8%80.png" alt></p><p>第三个经典场景是近实时场景的批流统一。在常用的 lambda 架构中，有一条实时链路和一条离线链路。实时链路一般由 Flink、Kafka、HBase 这些组件构建而成，离线链路一般会用到 Parquet、Spark等组件。这里边涉及到的计算组件和存储组件非常多，系统维护成本和业务开发成本都非常高。有很多场景，它们的实时性要求并没有那么苛刻，例如可以放松到分钟级别，这种场景我们称之为近实时场景。那么，我们是不是可以通过 Flink+Iceberg 来优化我们常用的 lambda 架构呢？</p><p><img src="%E5%9C%BA%E6%99%AF%E4%B8%89_%E8%BF%91%E5%AE%9E%E6%97%B6%E5%9C%BA%E6%99%AF%E7%9A%84%E6%89%B9%E6%B5%81%E7%BB%9F%E4%B8%802.png" alt></p><p>我们可以用 Flink+Iceberg 把整个架构优化成上图所示。实时的数据通过 Flink 写入到 Iceberg 表中，近实时链路可以通过 Flink 计算增量数据，离线链路也可以通过 Flink 批计算读取整个快照做全局分析，得到对应的分析结果，供不同场景下的用户读取和分析。经过这种改进之后，我们把计算引擎统一成了 Flink，把存储组件统一成了 Iceberg，整个系统的维护开发成本大大降低。</p><h4 id="场景四-从-Iceberg-历史数据启动-Flink-任务"><a href="#场景四-从-Iceberg-历史数据启动-Flink-任务" class="headerlink" title="场景四: 从 Iceberg 历史数据启动 Flink 任务"></a>场景四: 从 Iceberg 历史数据启动 Flink 任务</h4><p><img src="%E5%9C%BA%E6%99%AF%E5%9B%9B_%E4%BB%8EIceberg%E5%8E%86%E5%8F%B2%E6%95%B0%E6%8D%AE%E5%90%AF%E5%8A%A8Flink%E4%BB%BB%E5%8A%A1.png" alt></p><p>第四个场景，是采用 Iceberg 全量数据和 Kafka 的增量数据来 Bootstrap 新的 Flink 作业。我们现有的流作业在线上跑着，突然有一天某个业务方跑过来说，他们遇到一个新的计算场景，需要设计一个新的 Flink 作业，跑一遍去年一年的历史数据，跑完之后再对接到正在产生的 Kafka 增量数据。那么，这时候应该怎么办呢？</p><p>我们依然可以采用常见的 lamnda 架构，实时链路通过 Kafka -&gt; Flink -&gt; Iceberg 实时写入到数据湖，由于 Kafka 成本较高，保留最近 7 天数据即可，Iceberg 存储成本较低，可以存储全量的历史数据（按照 checkpoint 拆分成多个数据区间）。启动解析 Flink 作业的时候，只需要去拉取 Iceberg 的数据，跑完之后平滑的对接到 Kafka 数据即可。</p><h4 id="场景五-通过-Iceberg-数据来订正实时聚合结果"><a href="#场景五-通过-Iceberg-数据来订正实时聚合结果" class="headerlink" title="场景五: 通过 Iceberg 数据来订正实时聚合结果"></a>场景五: 通过 Iceberg 数据来订正实时聚合结果</h4><p><img src="%E5%9C%BA%E6%99%AF%E4%BA%94_%E9%80%9A%E8%BF%87Iceberg%E6%95%B0%E6%8D%AE%E6%9D%A5%E8%AE%A2%E6%AD%A3%E5%AE%9E%E6%97%B6%E8%81%9A%E5%90%88%E7%BB%93%E6%9E%9C.png" alt></p><p>第五个场景，和第四个场景类似。同样是在 lambda 架构下，实时链路由于事件丢失或者到达顺序的问题，可能导致流计算结果不一定完全准确，这时候一般都需要全量的历史数据来订正实时计算的结果。而 Iceberg 可以很好的充当这个角色，因为它可以高性价比的管理好历史数据。</p><h3 id="Why-Iceberg"><a href="#Why-Iceberg" class="headerlink" title="Why Iceberg"></a>Why Iceberg</h3><h4 id="Delta-vs-Hudi-vs-Iceberg"><a href="#Delta-vs-Hudi-vs-Iceberg" class="headerlink" title="Delta vs Hudi vs Iceberg"></a>Delta vs Hudi vs Iceberg</h4><p><img src="Delta_Hudi_Iceberg%E4%B8%89%E5%A4%A7%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%AF%B9%E6%AF%94%E6%80%BB%E7%BB%93%E5%9B%BE.png" alt></p><table><thead><tr><th>Items</th><th>Open Source Delta</th><th>Apache Iceberg</th><th>Apache Hudi</th></tr></thead><tbody><tr><td>Open Source Time</td><td>2019/04/12</td><td>2018/11/06(incubation)</td><td>2019/01/17(incubation)</td></tr><tr><td>Github Star</td><td>2800+</td><td>692</td><td>1400+</td></tr><tr><td>Releases</td><td>5</td><td>5</td><td>48</td></tr><tr><td>ACID</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td>Isolation Level</td><td>Write/Snapshot serialization</td><td>Write serialization</td><td>Snapshot serialization</td></tr><tr><td>Time Travel</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td>Row-level DELETE(batch)</td><td>Yes</td><td>Ongoing</td><td>No</td></tr><tr><td>Row-level DELETE(streaming)</td><td>No</td><td>Ongoing</td><td>Yes</td></tr><tr><td>Abstracted Schema</td><td>No</td><td>Yes</td><td>No</td></tr><tr><td>Engine Pluggable</td><td>No</td><td>Yes</td><td>No</td></tr><tr><td>Open File Format</td><td>Yes</td><td>Yes</td><td>Yes(Data) + No(Log)</td></tr><tr><td>Filter push down</td><td>No</td><td>Yes</td><td>No</td></tr><tr><td>Auto-Compaction</td><td>No</td><td>Ongoing</td><td>Yes</td></tr><tr><td>Python support</td><td>Yes</td><td>Yes</td><td>No</td></tr><tr><td>File Encryption</td><td>No</td><td>Yes</td><td>No</td></tr></tbody></table><h4 id="Flink-为何选择-Apache-Iceberg"><a href="#Flink-为何选择-Apache-Iceberg" class="headerlink" title="Flink: 为何选择 Apache Iceberg"></a>Flink: 为何选择 Apache Iceberg</h4><ol><li>Iceberg 的设计和 Flink 数据湖的需求最匹配</li></ol><ul><li>完美解耦计算引擎和文件格式两层，便于接入多样化的计算引擎和文件格式</li><li>正确的完成了 Table Format这一层的功能需求</li><li>更容易成为 Table Format 层的事实标准</li></ul><ol start="2"><li>两个项目的长远规划相似</li></ol><ul><li>Apache Iceberg：打造流批一体的数据湖存储层</li><li>Apache Flink：打造流批一体的计算引擎</li><li>两者合力打造流批一体的数据湖架构</li></ul><ol start="3"><li>强大的社区资源</li></ol><ul><li>Apache Iceberg 始自 Netflix。Netflix 最早是 All In Cloud 的互联网巨头之一，也是最早在线上生产环境运行 Flink/Spark+Iceberg 这套数据湖方案的公司</li><li>支撑着 Apple、LinkedIn、Adobe、腾讯、网易等多家互联网巨头 PB 级的生产数据</li><li>严苛的文档审核、代码审核及测试设计。拥有来自其他 Apache项目的1个VP、7个PMC、4个Committer</li></ul><p>Delta 和 Hudi 跟 Spark 的代码路径绑定太深，尤其是写入路径。毕竟当时这两个项目设计之初，都多多少少把 Spark 作为它们默认的计算引擎了。而 Apache Iceberg 非常坚定，总值就是要做一个通用化设计的 Table Format。因此它完美的解耦了计算引擎和底下的存储系统，便于多样化计算引擎和文件格式，可以说正确的完成了数据湖架构中的 Table Format 这一层的实现。我们认为它也更容易成为 Table Format 层的开源事实标准。</p><p>另一方面，Apache Iceberg 正在朝着批流一体的数据湖存储层发展， manifest 和 snapshot 的设计，有效的隔离不同 transaction 的变更，非常方便批处理和增量计算。而我们知道 Apache Flink 已经是流批一体的计算引擎，可以说这二者的长远规划完美匹配，未来二者将合力打造流批一体的数据湖架构。</p><p>最后，我们还发现 Apache Iceberg 这个项目背后的社区资源非常丰富。在国外，Netflix、Apple、Linkedin、Adobe 等公司都有 PB 级别的生产数据运行在 Apache Iceberg 上；在国内，腾讯这样的巨头也有非常庞大的数据跑在 Apache Iceberg 之上，他们最大的一个业务每天有几十T的增量数据写入到 Iceberg。社区成员同样非常资深和多样化，拥有来自其他项目的 7 位 Apache PMC，1位 VP。在代码和设计的 review 上，也非常苛刻，一个稍微大点的 PR 涉及 100+ 的 comment 很常见，这些都使得 Apache Iceberg 的设计+代码质量比较高。</p><p>正是基于以上考虑，Apache Flink 最终选择了 Apache Iceberg 作为第一个数据湖接入项目。</p><h2 id="数据湖基本架构"><a href="#数据湖基本架构" class="headerlink" title="数据湖基本架构"></a>数据湖基本架构</h2><p><img src="%E6%95%B0%E6%8D%AE%E6%B9%96%E5%8F%82%E8%80%83%E6%9E%B6%E6%9E%84%E7%A4%BA%E6%84%8F.png" alt></p><p>上图所示是一个数据湖系统的参考架构。对于一个典型的数据湖而言，它与大数据平台相同的地方在于它也具备超大规模数据所需的存储和计算能力，能提供多模式的数据处理能力；增强点在于数据湖提供了更为完善的数据管理能力，具体体现在：</p><ul><li><p>更强大的数据接入能力<br>对各类异构数据源的定义管理能力，以及对于外部数据源相关数据的抽取迁移能力，抽取迁移的数据包括外部数据源的元数据与实际存储的数据。</p></li><li><p>更强大的数据管理能力<br>可分为基本管理能力和扩展管理能力。基本管理能力包括对各类元数据的管理、数据访问控制、数据资产管理，是一个数据湖系统所必须的。扩展管理能力包括任务管理、流程编排以及数据质量、数据治理相关的能力。任务管理和流程编排主要用来管理、编排、调度、监测在数据湖系统中处理数据的各类任务，通常情况下，数据湖构建者会通过读取数据湖的相关元数据，来实现与数据湖系统的融合。而数据质量和数据治理则是更为复杂的问题，一般情况下，数据湖系统不会直接提供相关功能，但是会开放各类接口或元数据，供有能力的企业/组织与已有的数据治理软件集成或者做定制开发。</p></li><li><p>可共享的元数据<br>数据湖中的各类计算引擎会与数据湖中的数据深度融合，而融合的基础就是数据湖的元数据。好的数据湖系统，计算引擎在处理数据时，能从元数据中直接获取数据存储位置、数据格式、数据模式、数据分布等信息，然后直接进行数据处理，而无需进行人工/编程干预。更进一步，好的数据湖系统还可以对数据湖中的数据进行访问控制，控制的力度可以做到“库表列行”等不同级别。</p></li></ul><p> “集中式存储”更多的是业务概念上的集中，本质上希望一个企业组织内部能在一个明确统一的地方进行沉淀。事实上，数据湖的存储应该是一类可按需扩展的分布式文件系统，大多数数据湖实践中也是推荐采用 S3/OSS/HDFS 等分布式文件系统作为数据湖的统一存储。</p><h2 id="各个厂商的数据湖解决方案"><a href="#各个厂商的数据湖解决方案" class="headerlink" title="各个厂商的数据湖解决方案"></a>各个厂商的数据湖解决方案</h2><h3 id="AWS"><a href="#AWS" class="headerlink" title="AWS"></a>AWS</h3><p><img src="AWS%E6%95%B0%E6%8D%AE%E6%B9%96%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.png" alt></p><h3 id="华为"><a href="#华为" class="headerlink" title="华为"></a>华为</h3><p><img src="%E5%8D%8E%E4%B8%BA%E6%95%B0%E6%8D%AE%E6%B9%96%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.png" alt></p><h3 id="阿里云"><a href="#阿里云" class="headerlink" title="阿里云"></a>阿里云</h3><p><img src="%E9%98%BF%E9%87%8C%E4%BA%91%E6%95%B0%E6%8D%AE%E6%B9%96%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.png" alt></p><h3 id="Azure"><a href="#Azure" class="headerlink" title="Azure"></a>Azure</h3><p><img src="Azure%E6%95%B0%E6%8D%AE%E6%B9%96%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.png" alt></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://zhuanlan.zhihu.com/p/142756094" target="_blank" rel="noopener">“新晋网红”数据湖到底该如何理解？</a><br><a href="https://blog.51cto.com/u_15023245/2619826" target="_blank" rel="noopener">基于 Flink+Iceberg 构建企业级实时数据湖 - 文章</a><br><a href="https://www.bilibili.com/video/BV14A411J7e6?p=4" target="_blank" rel="noopener">基于 Flink+Iceberg 构建企业级实时数据湖 - 视频</a><br><a href="https://help.aliyun.com/document_detail/70378.html?spm=5176.21620736.J_5253785160.6.731041d2lYoMlv" target="_blank" rel="noopener">阿里云 云原生数据湖分析 DLA 帮助文档</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于数据湖的入门者，本文记录一下对数据湖的初步认识。&lt;/p&gt;
    
    </summary>
    
      <category term="DataLake" scheme="http://yoursite.com/categories/DataLake/"/>
    
    
  </entry>
  
  <entry>
    <title>晚熟的人</title>
    <link href="http://yoursite.com/2021/01/10/%E6%99%9A%E7%86%9F%E7%9A%84%E4%BA%BA/"/>
    <id>http://yoursite.com/2021/01/10/晚熟的人/</id>
    <published>2021-01-10T05:58:40.000Z</published>
    <updated>2021-05-25T03:58:10.703Z</updated>
    
    <content type="html"><![CDATA[<p>就一直晚熟下去… 没有什么不好</p><a id="more"></a><p>于创作来说，不能过早地固步自封，不能过早的使自己的风格固化，<br>就是要不断地求新求变，努力试图突破自己，要不断的成长。<br>工作中，不必急功急利，保持学习热情，所有好运都会如期而至。<br>你成熟的越晚，说明创作创新的过程延续的越长。</p><p>于人性来说，本性善良的人都晚熟，并且是被”劣人”催熟的，后来虽然开窍了，<br>但也仍然善良与赤诚，不断地寻找同类，最后却成了最孤独的一个。<br>开窍了，就不能啥事都往外喷了，积蓄能量，厚积薄发。<br>你成熟的越晚，善良延续的越长，孤独而自省。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;就一直晚熟下去… 没有什么不好&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>Apache Hudi</title>
    <link href="http://yoursite.com/2021/01/04/Apache-Hudi/"/>
    <id>http://yoursite.com/2021/01/04/Apache-Hudi/</id>
    <published>2021-01-03T17:17:31.000Z</published>
    <updated>2021-06-03T17:20:29.161Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Hey, password is required here.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="7a13309d1b18da83d67f5e813bed9016874b53ac96444e0b19c070fd7d3e3d3a">e3562aa68b223e1c03dd60eecfbb4ec09217adc47939c9407bb5553f1a72086f64fcd5c1b773522b005f8a6763d76e309f4c1ee334b15d045936244f7d81e4378a898228740a8f021aca889558b5fcf250e987f1d87bc7598458b2c26c14e64519492805f4dcb9d5de0b8407389e58af8749934a2d92e9049c61fa40228742e2f30b5136ed25d014a22b58798c9bdbb7fda6505bbf327818b5335b53972af3435eb718167710ebe128e7d22c09f0e40d</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      Here&#39;s something encrypted, password is required to continue reading.
    
    </summary>
    
      <category term="DataLake" scheme="http://yoursite.com/categories/DataLake/"/>
    
      <category term="Hudi" scheme="http://yoursite.com/categories/DataLake/Hudi/"/>
    
    
  </entry>
  
  <entry>
    <title>Flink源码剖析-flink-table-runtime-blink_TopN</title>
    <link href="http://yoursite.com/2020/09/30/Flink%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-flink-table-runtime-blink-TopN/"/>
    <id>http://yoursite.com/2020/09/30/Flink源码剖析-flink-table-runtime-blink-TopN/</id>
    <published>2020-09-30T08:35:54.000Z</published>
    <updated>2020-10-10T05:58:06.371Z</updated>
    
    <content type="html"><![CDATA[<p>本文将基于 flink <code>release-1.11</code> 源码，简单分析下 TopN function 的实现。</p><a id="more"></a><p><img src="TopNFunction%E7%B1%BB%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt></p><h2 id="AbstractTopNFunction"><a href="#AbstractTopNFunction" class="headerlink" title="AbstractTopNFunction"></a>AbstractTopNFunction</h2><p>AbstractTopNFunction 中有如下属性，定义 sortKey selector 和 comparator，rankEnd 相关参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// we set default topN size to 100</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> DEFAULT_TOPN_SIZE = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The util to compare two sortKey equals to each other.</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成 sortKey 比较器实例类的工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> GeneratedRecordComparator generatedSortKeyComparator;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sortKey 比较器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> Comparator&lt;RowData&gt; sortKeyComparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> generateUpdateBefore;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否输出排序序号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> outputRankNumber;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输入的数据类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> RowDataTypeInfo inputRowType;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * key selector，选择 RowData 中的哪一个字段来排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> KeySelector&lt;RowData, RowData&gt; sortKeySelector;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * key 上下文，获取当前处理数据的 key</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> KeyContext keyContext;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否是固定的 TopN 集合大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isConstantRankEnd;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * rankStart 值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> rankStart;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * rankEnd 在 RowData 中的下标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> rankEndIndex;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * rankEnd 值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">long</span> rankEnd;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * java.util.Function，从 RowData 的某一个位置获取 rankEnd</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Function&lt;RowData, Long&gt; rankEndFetcher;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 记录 rankEnd，可能随着输入数据动态变化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> ValueState&lt;Long&gt; rankEndState;</span><br><span class="line"><span class="keyword">private</span> Counter invalidCounter;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当 TopN 需要输出排位序号时，会用到这个对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> JoinedRowData outputRow;</span><br><span class="line"></span><br><span class="line"><span class="comment">// metrics</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">long</span> hitCount = <span class="number">0L</span>;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">long</span> requestCount = <span class="number">0L</span>;</span><br></pre></td></tr></table></figure><p>AbstractTopNFunction 的 <code>open()</code> 方法主要从状态后端获取 rankEndState，并初始化类属性： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(Configuration parameters)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.open(parameters);</span><br><span class="line">initCleanupTimeState(<span class="string">"RankFunctionCleanupTime"</span>);</span><br><span class="line">outputRow = <span class="keyword">new</span> JoinedRowData();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!isConstantRankEnd) &#123;</span><br><span class="line"><span class="comment">// 从状态后端读取当前 rankEnd 值</span></span><br><span class="line">ValueStateDescriptor&lt;Long&gt; rankStateDesc = <span class="keyword">new</span> ValueStateDescriptor&lt;&gt;(<span class="string">"rankEnd"</span>, Types.LONG);</span><br><span class="line">rankEndState = getRuntimeContext().getState(rankStateDesc);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// compile comparator</span></span><br><span class="line"><span class="comment">// classLoader 加载 key comparator 类</span></span><br><span class="line">sortKeyComparator = generatedSortKeyComparator.newInstance(getRuntimeContext().getUserCodeClassLoader());</span><br><span class="line"><span class="comment">// 把确定不需要的对象直接赋值为 null</span></span><br><span class="line">generatedSortKeyComparator = <span class="keyword">null</span>;</span><br><span class="line">invalidCounter = getRuntimeContext().getMetricGroup().counter(<span class="string">"topn.invalidTopSize"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// initialize rankEndFetcher</span></span><br><span class="line"><span class="keyword">if</span> (!isConstantRankEnd) &#123;</span><br><span class="line">LogicalType rankEndIdxType = inputRowType.getLogicalTypes()[rankEndIndex];</span><br><span class="line"><span class="keyword">switch</span> (rankEndIdxType.getTypeRoot()) &#123;</span><br><span class="line"><span class="keyword">case</span> BIGINT:</span><br><span class="line">rankEndFetcher = (RowData row) -&gt; row.getLong(rankEndIndex);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> INTEGER:</span><br><span class="line">rankEndFetcher = (RowData row) -&gt; (<span class="keyword">long</span>) row.getInt(rankEndIndex);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> SMALLINT:</span><br><span class="line">rankEndFetcher = (RowData row) -&gt; (<span class="keyword">long</span>) row.getShort(rankEndIndex);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">LOG.error(<span class="string">"variable rank index column must be long, short or int type, while input type is &#123;&#125;"</span>,</span><br><span class="line">rankEndIdxType.getClass().getName());</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(</span><br><span class="line"><span class="string">"variable rank index column must be long type, while input type is "</span> +</span><br><span class="line">rankEndIdxType.getClass().getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractTopNFunction 的 <code>initRankEnd()</code> 方法根据 input row 来动态获取 rankEnd ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize rank end.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> row input record</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> rank end</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">long</span> <span class="title">initRankEnd</span><span class="params">(RowData row)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (isConstantRankEnd) &#123;</span><br><span class="line"><span class="keyword">return</span> rankEnd;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">Long rankEndValue = rankEndState.value();</span><br><span class="line"><span class="keyword">long</span> curRankEnd = rankEndFetcher.apply(row);</span><br><span class="line"><span class="keyword">if</span> (rankEndValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">rankEnd = curRankEnd;</span><br><span class="line"><span class="comment">// 同步更新到状态后端</span></span><br><span class="line">rankEndState.update(rankEnd);</span><br><span class="line"><span class="keyword">return</span> rankEnd;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">rankEnd = rankEndValue;</span><br><span class="line"><span class="keyword">if</span> (rankEnd != curRankEnd) &#123;</span><br><span class="line"><span class="comment">// increment the invalid counter when the current rank end not equal to previous rank end</span></span><br><span class="line">invalidCounter.inc();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> rankEnd;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractTopNFunction 的 <code>checkSortKeyInBufferRange()</code> 方法来判断 input row 是否应该被放到其 key 对应的 TopBuffer 中：</p><ol><li>将 input row 与 TopBuffer 中的最后一个 entry 比较，comparator 返回 true 则将 input row 丢到 TopBuffer 中；</li><li>comparator 返回 false，当前 TopBuffer 中的 entry 个数还没有达到默认的 TopN size，也将 input row 丢到 TopBuffer 中。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Checks whether the record should be put into the buffer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sortKey sortKey to test</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> buffer  buffer to add</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if the record should be put into the buffer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">checkSortKeyInBufferRange</span><span class="params">(RowData sortKey, TopNBuffer buffer)</span> </span>&#123;</span><br><span class="line">Comparator&lt;RowData&gt; comparator = buffer.getSortKeyComparator();</span><br><span class="line">Map.Entry&lt;RowData, Collection&lt;RowData&gt;&gt; worstEntry = buffer.lastEntry();</span><br><span class="line"><span class="keyword">if</span> (worstEntry == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// return true if the buffer is empty. TopNBuffer 是空的，直接返回 true</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">RowData worstKey = worstEntry.getKey();</span><br><span class="line"><span class="comment">//执行 TopN 比较器</span></span><br><span class="line"><span class="keyword">int</span> compare = comparator.compare(sortKey, worstKey);</span><br><span class="line"><span class="keyword">if</span> (compare &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 如果满足条件，可以放到 TopNBuffer 中</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 到达的数据条数还没有达到默认的 TopN 大小 100，也可以放到 TopNBuffer 中</span></span><br><span class="line"><span class="keyword">return</span> buffer.getCurrentTopNum() &lt; getDefaultTopNSize();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>AbstractTopNFunction 的 <code>createOutputRow()</code> 方法用于构建 output row，区分带不带 rank 序号：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建 output row</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inputRow input row</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> rank     排位序号</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> rowKind  描述一行 changelog 的行为种类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> RowData&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> RowData <span class="title">createOutputRow</span><span class="params">(RowData inputRow, <span class="keyword">long</span> rank, RowKind rowKind)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (outputRankNumber) &#123;</span><br><span class="line"><span class="comment">// 需要输出 rank number</span></span><br><span class="line">GenericRowData rankRow = <span class="keyword">new</span> GenericRowData(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 第 0 个字段设置为排位序号，将 rank 专门放置在一个 RowData 中</span></span><br><span class="line">rankRow.setField(<span class="number">0</span>, rank);</span><br><span class="line"></span><br><span class="line">outputRow.replace(inputRow, rankRow);</span><br><span class="line">outputRow.setRowKind(rowKind);</span><br><span class="line"><span class="keyword">return</span> outputRow;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">inputRow.setRowKind(rowKind);</span><br><span class="line"><span class="keyword">return</span> inputRow;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AppendOnlyTopNFunction"><a href="#AppendOnlyTopNFunction" class="headerlink" title="AppendOnlyTopNFunction"></a>AppendOnlyTopNFunction</h2><p>AppendOnlyTopNFunction 中有如下属性，状态后端 MapState 和本地堆内存 TopNBuffer 结合使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sortKey 字段类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> RowDataTypeInfo sortKeyType;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * input row 的序列化类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> TypeSerializer&lt;RowData&gt; inputRowSer;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> cacheSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a map state stores mapping from sort key to records list which is in topN</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sortKey &lt;-&gt; 在 TopN 中的 RowData list</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> MapState&lt;RowData, List&lt;RowData&gt;&gt; dataState;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the buffer stores mapping from sort key to records list, a heap mirror to dataState</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当前 sortKey 对应的 TopNBuffer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> TopNBuffer buffer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the kvSortedMap stores mapping from partition key to it's buffer</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sortKey &lt;-&gt; TopNBuffer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Map&lt;RowData, TopNBuffer&gt; kvSortedMap;</span><br></pre></td></tr></table></figure><p>AppendOnlyTopNFunction 的 <code>open()</code> 方法中从状态后端中获取当前 key 的 TopN list：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(Configuration parameters)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.open(parameters);</span><br><span class="line"><span class="comment">// LRU的缓存大小=总的缓存大小/topN的缓存大小</span></span><br><span class="line"><span class="keyword">int</span> lruCacheSize = Math.max(<span class="number">1</span>, (<span class="keyword">int</span>) (cacheSize / getDefaultTopNSize()));</span><br><span class="line"><span class="comment">// 根据 key 缓存 LRU list</span></span><br><span class="line">kvSortedMap = <span class="keyword">new</span> LRUMap&lt;&gt;(lruCacheSize);</span><br><span class="line">LOG.info(<span class="string">"Top&#123;&#125; operator is using LRU caches key-size: &#123;&#125;"</span>, getDefaultTopNSize(), lruCacheSize);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 key 记录当前的 TopN list</span></span><br><span class="line"><span class="comment">// RowDataTypeInfo</span></span><br><span class="line">ListTypeInfo&lt;RowData&gt; valueTypeInfo = <span class="keyword">new</span> ListTypeInfo&lt;&gt;(inputRowType);</span><br><span class="line">MapStateDescriptor&lt;RowData, List&lt;RowData&gt;&gt; mapStateDescriptor = <span class="keyword">new</span> MapStateDescriptor&lt;&gt;(</span><br><span class="line"><span class="string">"data-state-with-append"</span>, sortKeyType, valueTypeInfo);</span><br><span class="line">dataState = getRuntimeContext().getMapState(mapStateDescriptor);</span><br><span class="line"></span><br><span class="line"><span class="comment">// metrics</span></span><br><span class="line">registerMetric(kvSortedMap.size() * getDefaultTopNSize());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AppendOnlyTopNFunction 的 <code>processElement()</code> 方法处理数据，判断当前 input row 是否可以丢到 TopNBuffer 中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processElement</span><span class="params">(RowData input, Context context, Collector&lt;RowData&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// 获取当前时间，记录在上下文的计时器中</span></span><br><span class="line"><span class="keyword">long</span> currentTime = context.timerService().currentProcessingTime();</span><br><span class="line"><span class="comment">// register state-cleanup timer</span></span><br><span class="line">registerProcessingCleanupTimer(context, currentTime);</span><br><span class="line"></span><br><span class="line">initHeapStates();</span><br><span class="line">initRankEnd(input);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从输入的数据中抽取 sortKey</span></span><br><span class="line">RowData sortKey = sortKeySelector.getKey(input);</span><br><span class="line"><span class="comment">// check whether the sortKey is in the topN range</span></span><br><span class="line"><span class="comment">// 根据 sortKey 判断当前数据是否应该被放到 TopNBuffer 中</span></span><br><span class="line"><span class="keyword">if</span> (checkSortKeyInBufferRange(sortKey, buffer)) &#123;</span><br><span class="line"><span class="comment">// insert sort key into buffer</span></span><br><span class="line">buffer.put(sortKey, inputRowSer.copy(input));</span><br><span class="line">Collection&lt;RowData&gt; inputs = buffer.get(sortKey);</span><br><span class="line"><span class="comment">// update data state</span></span><br><span class="line"><span class="comment">// copy a new collection to avoid mutating state values, see CopyOnWriteStateMap,</span></span><br><span class="line"><span class="comment">// otherwise, the result might be corrupt.</span></span><br><span class="line"><span class="comment">// don't need to perform a deep copy, because RowData elements will not be updated</span></span><br><span class="line"><span class="comment">// 同步记录到 MapState 中</span></span><br><span class="line">dataState.put(sortKey, <span class="keyword">new</span> ArrayList&lt;&gt;(inputs));</span><br><span class="line"><span class="keyword">if</span> (outputRankNumber || hasOffset()) &#123;</span><br><span class="line"><span class="comment">// the without-number-algorithm can't handle topN with offset,</span></span><br><span class="line"><span class="comment">// so use the with-number-algorithm to handle offset</span></span><br><span class="line">processElementWithRowNumber(sortKey, input, out);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">processElementWithoutRowNumber(input, out);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AppendOnlyTopNFunction 的 <code>initHeapStates()</code> 是在处理 input row 之前，在堆内存中初始化 TopNBuffer，并将状态后端存储的 TopN list 设置到 TopNBuffer 中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initHeapStates</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">requestCount += <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 从 KeyContext 中获取当前的key</span></span><br><span class="line">RowData currentKey = (RowData) keyContext.getCurrentKey();</span><br><span class="line"><span class="comment">// 取出 key 对应的 TopNBuffer</span></span><br><span class="line">buffer = kvSortedMap.get(currentKey);</span><br><span class="line"><span class="keyword">if</span> (buffer == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// buffer 为 null，则为此 key 构建 TopNBuffer，为其设置 key comparator</span></span><br><span class="line">buffer = <span class="keyword">new</span> TopNBuffer(sortKeyComparator, ArrayList::<span class="keyword">new</span>);</span><br><span class="line">kvSortedMap.put(currentKey, buffer);</span><br><span class="line"><span class="comment">// restore buffer</span></span><br><span class="line"><span class="comment">// 读取 state 中记录的 TopN list，塞到这个 TopNBuffer 里</span></span><br><span class="line">Iterator&lt;Map.Entry&lt;RowData, List&lt;RowData&gt;&gt;&gt; iter = dataState.iterator();</span><br><span class="line"><span class="keyword">if</span> (iter != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">Map.Entry&lt;RowData, List&lt;RowData&gt;&gt; entry = iter.next();</span><br><span class="line">RowData sortKey = entry.getKey();</span><br><span class="line">List&lt;RowData&gt; values = entry.getValue();</span><br><span class="line"><span class="comment">// the order is preserved</span></span><br><span class="line">buffer.putAll(sortKey, values);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// buffer 不为 null，记录命中一次 TopNBuffer 缓存</span></span><br><span class="line">hitCount += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AppendOnlyTopNFunction 的 <code>processElementWithoutRowNumber()</code> 方法是处理丢到 TopNBuffer 中的 input row，决定这条数据是否被 Delete ： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processElementWithoutRowNumber</span><span class="params">(RowData input, Collector&lt;RowData&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// remove retired element</span></span><br><span class="line"><span class="comment">// 当前 TopNBuffer 中缓存的数据条数大于 TopN 的 N</span></span><br><span class="line"><span class="keyword">if</span> (buffer.getCurrentTopNum() &gt; rankEnd) &#123;</span><br><span class="line">Map.Entry&lt;RowData, Collection&lt;RowData&gt;&gt; lastEntry = buffer.lastEntry();</span><br><span class="line">RowData lastKey = lastEntry.getKey();</span><br><span class="line">Collection&lt;RowData&gt; lastList = lastEntry.getValue();</span><br><span class="line">RowData lastElement = buffer.lastElement();</span><br><span class="line"><span class="keyword">int</span> size = lastList.size();</span><br><span class="line"><span class="comment">// remove last one</span></span><br><span class="line"><span class="keyword">if</span> (size &lt;= <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">// 移除最后一个元素</span></span><br><span class="line">buffer.removeAll(lastKey);</span><br><span class="line">dataState.remove(lastKey);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 移除大于 TopN 的 N 之后的元素</span></span><br><span class="line">buffer.removeLast();</span><br><span class="line"><span class="comment">// last element has been removed from lastList, we have to copy a new collection</span></span><br><span class="line"><span class="comment">// for lastList to avoid mutating state values, see CopyOnWriteStateMap,</span></span><br><span class="line"><span class="comment">// otherwise, the result might be corrupt.</span></span><br><span class="line"><span class="comment">// don't need to perform a deep copy, because RowData elements will not be updated</span></span><br><span class="line"><span class="comment">// 更新状态后端</span></span><br><span class="line">dataState.put(lastKey, <span class="keyword">new</span> ArrayList&lt;&gt;(lastList));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (size == <span class="number">0</span> || input.equals(lastElement)) &#123;</span><br><span class="line"><span class="comment">// input 的数据和 TopNBuffer 中的最后一个元素相同，则直接返回</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// lastElement shouldn't be null</span></span><br><span class="line">collectDelete(out, lastElement);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// it first appears in the TopN, send INSERT message</span></span><br><span class="line">collectInsert(out, input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AppendOnlyTopNFunctionTest"><a href="#AppendOnlyTopNFunctionTest" class="headerlink" title="AppendOnlyTopNFunctionTest"></a>AppendOnlyTopNFunctionTest</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tests for &#123;<span class="doctag">@link</span> AppendOnlyTopNFunction&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppendOnlyTopNFunctionTest</span> <span class="keyword">extends</span> <span class="title">TopNFunctionTestBase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AbstractTopNFunction <span class="title">createFunction</span><span class="params">(RankType rankType, RankRange rankRange,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">boolean</span> generateUpdateBefore, <span class="keyword">boolean</span> outputRankNumber)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> AppendOnlyTopNFunction(minTime.toMilliseconds(),</span><br><span class="line">maxTime.toMilliseconds(),</span><br><span class="line">inputRowType,</span><br><span class="line">sortKeyComparator,</span><br><span class="line">sortKeySelector,</span><br><span class="line">rankType,</span><br><span class="line">rankRange,</span><br><span class="line">generateUpdateBefore,</span><br><span class="line">outputRankNumber,</span><br><span class="line">cacheSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testVariableRankRange</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">AbstractTopNFunction func = createFunction(RankType.ROW_NUMBER,</span><br><span class="line"><span class="comment">// 指定数据的第2个字段值为 rankEnd，动态指定 TopN 集合的大小</span></span><br><span class="line"><span class="keyword">new</span> VariableRankRange(<span class="number">1</span>),</span><br><span class="line"><span class="keyword">true</span>,</span><br><span class="line"><span class="comment">// 不用输出 topN 的排序序号</span></span><br><span class="line"><span class="keyword">false</span>);</span><br><span class="line"><span class="comment">// 将 TopNFunction 包装进 KeyedProcessOperator</span></span><br><span class="line">OneInputStreamOperatorTestHarness&lt;RowData, RowData&gt; testHarness = createTestHarness(func);</span><br><span class="line"><span class="comment">// 测试类准备工作</span></span><br><span class="line">testHarness.open();</span><br><span class="line"></span><br><span class="line"><span class="comment">// KeyedProcessOperator 作为 input operator 模拟处理数据</span></span><br><span class="line">testHarness.processElement(insertRecord(<span class="string">"book"</span>, <span class="number">2L</span>, <span class="number">12</span>)); <span class="comment">// 开始处理(book,2,12)，key 为 book，rankEnd 为 2，加入 TopN 集合</span></span><br><span class="line">testHarness.processElement(insertRecord(<span class="string">"book"</span>, <span class="number">2L</span>, <span class="number">19</span>)); <span class="comment">// 开始处理(book,2,19)，key 为 book，rankEnd 为 2，加入 TopN 集合</span></span><br><span class="line">testHarness.processElement(insertRecord(<span class="string">"book"</span>, <span class="number">2L</span>, <span class="number">11</span>)); <span class="comment">// 开始处理(book,2,11)，key 为 book，rankEnd 为 2，超出 TopN 集合容量，因此需要先删除 (book,2,19)，留下 2 个较小的</span></span><br><span class="line">testHarness.processElement(insertRecord(<span class="string">"fruit"</span>, <span class="number">1L</span>, <span class="number">33</span>)); <span class="comment">// 开始处理(fruit,1,33)，key 为 fruit，rankEnd 为 1，加入 TopN 集合</span></span><br><span class="line">testHarness.processElement(insertRecord(<span class="string">"fruit"</span>, <span class="number">1L</span>, <span class="number">44</span>)); <span class="comment">// 开始处理(fruit,1,44)，key 为 fruit，rankEnd 为 1，44 &gt; 33，直接过滤掉</span></span><br><span class="line">testHarness.processElement(insertRecord(<span class="string">"fruit"</span>, <span class="number">1L</span>, <span class="number">22</span>)); <span class="comment">// 开始处理(fruit,1,22)，key 为 fruit，rankEnd 为 1，超出 TopN 集合容量，因此需要先删除 (fruit,1,33)，留下 1 个较小的</span></span><br><span class="line">testHarness.close();</span><br><span class="line"></span><br><span class="line">ConcurrentLinkedQueue&lt;Object&gt; output = testHarness.getOutput();</span><br><span class="line"><span class="keyword">for</span> (Object o : output) &#123;</span><br><span class="line">StreamRecord streamRecord = (StreamRecord) o;</span><br><span class="line">System.out.println(<span class="string">"Output element -&gt; "</span> + streamRecord.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;Object&gt; expectedOutput = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">// ("book", 2L, 12)</span></span><br><span class="line">expectedOutput.add(insertRecord(<span class="string">"book"</span>, <span class="number">2L</span>, <span class="number">12</span>));</span><br><span class="line"><span class="comment">// ("book", 2L, 19)</span></span><br><span class="line">expectedOutput.add(insertRecord(<span class="string">"book"</span>, <span class="number">2L</span>, <span class="number">19</span>));</span><br><span class="line"><span class="comment">// ("book", 2L, 11)</span></span><br><span class="line">expectedOutput.add(deleteRecord(<span class="string">"book"</span>, <span class="number">2L</span>, <span class="number">19</span>));</span><br><span class="line">expectedOutput.add(insertRecord(<span class="string">"book"</span>, <span class="number">2L</span>, <span class="number">11</span>));</span><br><span class="line"><span class="comment">// ("fruit", 1L, 33)</span></span><br><span class="line">expectedOutput.add(insertRecord(<span class="string">"fruit"</span>, <span class="number">1L</span>, <span class="number">33</span>));</span><br><span class="line"><span class="comment">// ("fruit", 1L, 44)</span></span><br><span class="line"><span class="comment">// ("fruit", 1L, 22)</span></span><br><span class="line">expectedOutput.add(deleteRecord(<span class="string">"fruit"</span>, <span class="number">1L</span>, <span class="number">33</span>));</span><br><span class="line">expectedOutput.add(insertRecord(<span class="string">"fruit"</span>, <span class="number">1L</span>, <span class="number">22</span>));</span><br><span class="line">assertorWithoutRowNumber</span><br><span class="line">.assertOutputEquals(<span class="string">"output wrong."</span>, expectedOutput, testHarness.getOutput());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TopNFunctionTestBase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// key 比较器的类加载工具类，生成一个 key 比较器实例</span></span><br><span class="line">    <span class="keyword">static</span> GeneratedRecordComparator sortKeyComparator = <span class="keyword">new</span> GeneratedRecordComparator(<span class="string">""</span>, <span class="string">""</span>, <span class="keyword">new</span> Object[<span class="number">0</span>]) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1434685115916728955L</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RecordComparator <span class="title">newInstance</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// compare(RowData o1, RowData o2) 方法中比较 o1 和 o2 的第 0 个元素，从小到大比较</span></span><br><span class="line"><span class="keyword">return</span> IntRecordComparator.INSTANCE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TopNFunctionTestBase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> sortKeyIdx = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// key 选择器，比较 RowData 中的第 2 位置的元素</span></span><br><span class="line">BinaryRowDataKeySelector sortKeySelector = <span class="keyword">new</span> BinaryRowDataKeySelector(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;sortKeyIdx&#125;,</span><br><span class="line">inputRowType.getLogicalTypes());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Output element -&gt; +I(book,2,12)   </span><br><span class="line">Output element -&gt; +I(book,2,19)   </span><br><span class="line">Output element -&gt; -D(book,2,19)    </span><br><span class="line">Output element -&gt; +I(book,2,11)   </span><br><span class="line">Output element -&gt; +I(fruit,1,33)  </span><br><span class="line">Output element -&gt; -D(fruit,1,33)  </span><br><span class="line">Output element -&gt; +I(fruit,1,22)</span><br></pre></td></tr></table></figure><h2 id="RetractableTopNFunction"><a href="#RetractableTopNFunction" class="headerlink" title="RetractableTopNFunction"></a>RetractableTopNFunction</h2><p>内部使用 TreeMap 进行 TopN 排序，可以对数据执行撤回操作，RowKind.UPDATE_BEFORE（-U）。</p><p>RetractableTopNFunction 中有如下属性，记录相同的 RowData 列表，使用 sortedMap 来进行 TopN 排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a map state stores mapping from sort key to records list</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RowData &lt;-&gt;  相同的 RowData list，状态后端远程维护</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> MapState&lt;RowData, List&lt;RowData&gt;&gt; dataState;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a sorted map stores mapping from sort key to records count</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RowData &lt;-&gt; 对应的记录个数，ValueState 中记录有序的 RowData</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> ValueState&lt;SortedMap&lt;RowData, Long&gt;&gt; treeMap;</span><br></pre></td></tr></table></figure><p>RetractableTopNFunction 中的 <code>processElement()</code> 方法，按照数据的 RowKind 分别执行 emit 和 retract 操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processElement</span><span class="params">(RowData input, Context ctx, Collector&lt;RowData&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">long</span> currentTime = ctx.timerService().currentProcessingTime();</span><br><span class="line"><span class="comment">// register state-cleanup timer</span></span><br><span class="line">registerProcessingCleanupTimer(ctx, currentTime);</span><br><span class="line">initRankEnd(input);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从状态后端中获取有序 RowData 的集合</span></span><br><span class="line">SortedMap&lt;RowData, Long&gt; sortedMap = treeMap.value();</span><br><span class="line"><span class="keyword">if</span> (sortedMap == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 如果为 null，则新建一个，指定 sortKey comparator</span></span><br><span class="line">sortedMap = <span class="keyword">new</span> TreeMap&lt;&gt;(sortKeyComparator);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RowData sortKey = sortKeySelector.getKey(input);</span><br><span class="line"><span class="comment">// RowKind.INSERT 或 RowKind.UPDATE_AFTER</span></span><br><span class="line"><span class="keyword">boolean</span> isAccumulate = RowDataUtil.isAccumulateMsg(input);</span><br><span class="line"><span class="comment">// erase row kind for further state accessing</span></span><br><span class="line">input.setRowKind(RowKind.INSERT);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isAccumulate) &#123;</span><br><span class="line"><span class="comment">// update sortedMap，记录当前 sortKey 的记录数到状态后端</span></span><br><span class="line"><span class="keyword">if</span> (sortedMap.containsKey(sortKey)) &#123;</span><br><span class="line">sortedMap.put(sortKey, sortedMap.get(sortKey) + <span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">sortedMap.put(sortKey, <span class="number">1L</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// emit</span></span><br><span class="line"><span class="keyword">if</span> (outputRankNumber || hasOffset()) &#123;</span><br><span class="line"><span class="comment">// the without-number-algorithm can't handle topN with offset,</span></span><br><span class="line"><span class="comment">// so use the with-number-algorithm to handle offset</span></span><br><span class="line">emitRecordsWithRowNumber(sortedMap, sortKey, input, out);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">emitRecordsWithoutRowNumber(sortedMap, sortKey, input, out);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步更新到状态后端</span></span><br><span class="line"><span class="comment">// update data state</span></span><br><span class="line">List&lt;RowData&gt; inputs = dataState.get(sortKey);</span><br><span class="line"><span class="keyword">if</span> (inputs == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// the sort key is never seen</span></span><br><span class="line">inputs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line">inputs.add(input);</span><br><span class="line">dataState.put(sortKey, inputs);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// emit updates first，先输出 update 操作，-U 代表执行撤回操作</span></span><br><span class="line"><span class="keyword">if</span> (outputRankNumber || hasOffset()) &#123;</span><br><span class="line"><span class="comment">// the without-number-algorithm can't handle topN with offset,</span></span><br><span class="line"><span class="comment">// so use the with-number-algorithm to handle offset</span></span><br><span class="line">retractRecordWithRowNumber(sortedMap, sortKey, input, out);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">retractRecordWithoutRowNumber(sortedMap, sortKey, input, out);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// and then update sortedMap</span></span><br><span class="line"><span class="keyword">if</span> (sortedMap.containsKey(sortKey)) &#123;</span><br><span class="line"><span class="keyword">long</span> count = sortedMap.get(sortKey) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">sortedMap.remove(sortKey);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">sortedMap.put(sortKey, count);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (sortedMap.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">if</span> (lenient) &#123;</span><br><span class="line">LOG.warn(STATE_CLEARED_WARN_MSG);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(STATE_CLEARED_WARN_MSG);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line"><span class="string">"Can not retract a non-existent record. This should never happen."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更新状态后端中记录的 sortedMap</span></span><br><span class="line">treeMap.update(sortedMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RetractableTopNFunction 中的 <code>emitRecordsWithRowNumber()</code> 方法正常输出排序行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">emitRecordsWithRowNumber</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">SortedMap&lt;RowData, Long&gt; sortedMap, RowData sortKey, RowData inputRow, Collector&lt;RowData&gt; out)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Iterator&lt;Map.Entry&lt;RowData, Long&gt;&gt; iterator = sortedMap.entrySet().iterator();</span><br><span class="line"><span class="keyword">long</span> currentRank = <span class="number">0L</span>;</span><br><span class="line">RowData currentRow = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">boolean</span> findsSortKey = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext() &amp;&amp; isInRankEnd(currentRank)) &#123;</span><br><span class="line">Map.Entry&lt;RowData, Long&gt; entry = iterator.next();</span><br><span class="line">RowData key = entry.getKey();</span><br><span class="line"><span class="keyword">if</span> (!findsSortKey &amp;&amp; key.equals(sortKey)) &#123;</span><br><span class="line">currentRank += entry.getValue();</span><br><span class="line">currentRow = inputRow;</span><br><span class="line"><span class="comment">// 从 sortedMap 中找到当前的 sortKey</span></span><br><span class="line">findsSortKey = <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (findsSortKey) &#123;</span><br><span class="line">List&lt;RowData&gt; inputs = dataState.get(key);</span><br><span class="line"><span class="keyword">if</span> (inputs == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// Skip the data if it's state is cleared because of state ttl.</span></span><br><span class="line"><span class="keyword">if</span> (lenient) &#123;</span><br><span class="line">LOG.warn(STATE_CLEARED_WARN_MSG);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(STATE_CLEARED_WARN_MSG);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; inputs.size() &amp;&amp; isInRankEnd(currentRank)) &#123;</span><br><span class="line">RowData prevRow = inputs.get(i); <span class="comment">// 取出前一个row</span></span><br><span class="line">collectUpdateBefore(out, prevRow, currentRank);</span><br><span class="line">collectUpdateAfter(out, currentRow, currentRank); <span class="comment">//输出当前行</span></span><br><span class="line">currentRow = prevRow; <span class="comment">// 前一行赋给当前行</span></span><br><span class="line">currentRank += <span class="number">1</span>;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">currentRank += entry.getValue();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (isInRankEnd(currentRank)) &#123;</span><br><span class="line"><span class="comment">// there is no enough elements in Top-N, emit INSERT message for the new record.</span></span><br><span class="line">collectInsert(out, currentRow, currentRank);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RetractableTopNFunction 中的 <code>retractRecordWithRowNumber()</code> 方法将撤回行从 sortedMap 中移除，并更新前一行的排位输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">retractRecordWithRowNumber</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">SortedMap&lt;RowData, Long&gt; sortedMap, RowData sortKey, RowData inputRow, Collector&lt;RowData&gt; out)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Iterator&lt;Map.Entry&lt;RowData, Long&gt;&gt; iterator = sortedMap.entrySet().iterator();</span><br><span class="line"><span class="keyword">long</span> currentRank = <span class="number">0L</span>;</span><br><span class="line">RowData prevRow = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">boolean</span> findsSortKey = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext() &amp;&amp; isInRankEnd(currentRank)) &#123;</span><br><span class="line">Map.Entry&lt;RowData, Long&gt; entry = iterator.next();</span><br><span class="line">RowData key = entry.getKey();</span><br><span class="line"><span class="keyword">if</span> (!findsSortKey &amp;&amp; key.equals(sortKey)) &#123;</span><br><span class="line">List&lt;RowData&gt; inputs = dataState.get(key);</span><br><span class="line"><span class="keyword">if</span> (inputs == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// Skip the data if it's state is cleared because of state ttl.</span></span><br><span class="line"><span class="keyword">if</span> (lenient) &#123;</span><br><span class="line">LOG.warn(STATE_CLEARED_WARN_MSG);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(STATE_CLEARED_WARN_MSG);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">Iterator&lt;RowData&gt; inputIter = inputs.iterator();</span><br><span class="line"><span class="keyword">while</span> (inputIter.hasNext() &amp;&amp; isInRankEnd(currentRank)) &#123;</span><br><span class="line">RowData currentRow = inputIter.next();</span><br><span class="line"><span class="keyword">if</span> (!findsSortKey &amp;&amp; equaliser.equals(currentRow, inputRow)) &#123;</span><br><span class="line">prevRow = currentRow;</span><br><span class="line">findsSortKey = <span class="keyword">true</span>;</span><br><span class="line">inputIter.remove();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (findsSortKey) &#123;</span><br><span class="line">collectUpdateBefore(out, prevRow, currentRank);</span><br><span class="line">collectUpdateAfter(out, currentRow, currentRank);</span><br><span class="line">prevRow = currentRow;</span><br><span class="line">&#125;</span><br><span class="line">currentRank += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (inputs.isEmpty()) &#123;</span><br><span class="line">dataState.remove(key); <span class="comment">// 将撤回的行从 sortedMap 中移除</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dataState.put(key, inputs);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (findsSortKey) &#123;</span><br><span class="line">List&lt;RowData&gt; inputs = dataState.get(key);</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; inputs.size() &amp;&amp; isInRankEnd(currentRank)) &#123;</span><br><span class="line">RowData currentRow = inputs.get(i); <span class="comment">// 上一行作为当前行</span></span><br><span class="line"><span class="comment">// 处理上一条数据</span></span><br><span class="line">collectUpdateBefore(out, prevRow, currentRank);</span><br><span class="line"><span class="comment">// 输出当前行</span></span><br><span class="line">collectUpdateAfter(out, currentRow, currentRank);</span><br><span class="line">prevRow = currentRow;</span><br><span class="line">currentRank += <span class="number">1</span>;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">currentRank += entry.getValue();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (isInRankEnd(currentRank)) &#123;</span><br><span class="line"><span class="comment">// there is no enough elements in Top-N, emit DELETE message for the retract record.</span></span><br><span class="line">collectDelete(out, prevRow, currentRank);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RetractableTopNFunctionTest"><a href="#RetractableTopNFunctionTest" class="headerlink" title="RetractableTopNFunctionTest"></a>RetractableTopNFunctionTest</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tests for &#123;<span class="doctag">@link</span> RetractableTopNFunction&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RetractableTopNFunctionTest</span> <span class="keyword">extends</span> <span class="title">TopNFunctionTestBase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AbstractTopNFunction <span class="title">createFunction</span><span class="params">(RankType rankType, RankRange rankRange,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">boolean</span> generateUpdateBefore, <span class="keyword">boolean</span> outputRankNumber)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> RetractableTopNFunction(</span><br><span class="line">minTime.toMilliseconds(),</span><br><span class="line">maxTime.toMilliseconds(),</span><br><span class="line">inputRowType,</span><br><span class="line">sortKeyComparator,</span><br><span class="line">sortKeySelector,</span><br><span class="line">rankType,</span><br><span class="line">rankRange,</span><br><span class="line">generatedEqualiser,</span><br><span class="line">generateUpdateBefore,</span><br><span class="line">outputRankNumber);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testProcessRetractMessageWithNotGenerateUpdateBefore</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">AbstractTopNFunction func = createFunction(RankType.ROW_NUMBER,</span><br><span class="line"><span class="comment">// 固定的 TopN 集合大小，1～2</span></span><br><span class="line"><span class="keyword">new</span> ConstantRankRange(<span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line"><span class="keyword">false</span>,</span><br><span class="line"><span class="comment">// 输出 TopN 的排序序号</span></span><br><span class="line"><span class="keyword">true</span>);</span><br><span class="line">OneInputStreamOperatorTestHarness&lt;RowData, RowData&gt; testHarness = createTestHarness(func);</span><br><span class="line">testHarness.open();</span><br><span class="line">testHarness.processElement(insertRecord(<span class="string">"book"</span>, <span class="number">1L</span>, <span class="number">12</span>));</span><br><span class="line">testHarness.processElement(insertRecord(<span class="string">"book"</span>, <span class="number">2L</span>, <span class="number">19</span>));</span><br><span class="line">testHarness.processElement(insertRecord(<span class="string">"book"</span>, <span class="number">4L</span>, <span class="number">11</span>));</span><br><span class="line">testHarness.processElement(updateBeforeRecord(<span class="string">"book"</span>, <span class="number">1L</span>, <span class="number">12</span>));</span><br><span class="line">testHarness.processElement(insertRecord(<span class="string">"book"</span>, <span class="number">5L</span>, <span class="number">11</span>));</span><br><span class="line">testHarness.processElement(insertRecord(<span class="string">"fruit"</span>, <span class="number">4L</span>, <span class="number">33</span>));</span><br><span class="line">testHarness.processElement(insertRecord(<span class="string">"fruit"</span>, <span class="number">3L</span>, <span class="number">44</span>));</span><br><span class="line">testHarness.processElement(insertRecord(<span class="string">"fruit"</span>, <span class="number">5L</span>, <span class="number">22</span>));</span><br><span class="line">testHarness.close();</span><br><span class="line"></span><br><span class="line">ConcurrentLinkedQueue&lt;Object&gt; output = testHarness.getOutput();</span><br><span class="line"><span class="keyword">for</span> (Object o : output) &#123;</span><br><span class="line">StreamRecord streamRecord = (StreamRecord) o;</span><br><span class="line">System.out.println(<span class="string">"Output element -&gt; "</span> + streamRecord.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;Object&gt; expectedOutput = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">// ("book", 1L, 12)</span></span><br><span class="line"><span class="comment">// sortedMap -&gt; [("book", 1L, 12)]</span></span><br><span class="line">expectedOutput.add(insertRecord(<span class="string">"book"</span>, <span class="number">1L</span>, <span class="number">12</span>, <span class="number">1L</span>));</span><br><span class="line"><span class="comment">// ("book", 2L, 19)</span></span><br><span class="line"><span class="comment">// sortedMap -&gt; [("book", 1L, 12)],[("book", 2L, 19)]</span></span><br><span class="line">expectedOutput.add(insertRecord(<span class="string">"book"</span>, <span class="number">2L</span>, <span class="number">19</span>, <span class="number">2L</span>));</span><br><span class="line"><span class="comment">// ("book", 4L, 11)</span></span><br><span class="line"><span class="comment">// sortedMap -&gt; [("book", 4L, 11)],[("book", 1L, 12)],[("book", 2L, 19)]</span></span><br><span class="line">expectedOutput.add(updateAfterRecord(<span class="string">"book"</span>, <span class="number">4L</span>, <span class="number">11</span>, <span class="number">1L</span>));</span><br><span class="line">expectedOutput.add(updateAfterRecord(<span class="string">"book"</span>, <span class="number">1L</span>, <span class="number">12</span>, <span class="number">2L</span>));</span><br><span class="line"><span class="comment">// UB ("book", 1L, 12)，撤回即将 ("book", 1L ,12) 从 sortedMap 中移除，("book", 2L, 19)的排序被更新为 2</span></span><br><span class="line"><span class="comment">// sortedMap -&gt; [("book", 4L, 11)],[("book", 2L, 19)]</span></span><br><span class="line">expectedOutput.add(updateAfterRecord(<span class="string">"book"</span>, <span class="number">2L</span>, <span class="number">19</span>, <span class="number">2L</span>));</span><br><span class="line"><span class="comment">// ("book", 5L, 11)</span></span><br><span class="line"><span class="comment">// sortedMap -&gt; [("book", 4L, 11),("book", 5L, 11)],[("book", 2L, 19)]，("book", 5L, 11) 的排序被更新为 2</span></span><br><span class="line">expectedOutput.add(updateAfterRecord(<span class="string">"book"</span>, <span class="number">5L</span>, <span class="number">11</span>, <span class="number">2L</span>));</span><br><span class="line"><span class="comment">// ("fruit", 4L, 33)</span></span><br><span class="line"><span class="comment">// ("fruit", 3L, 44)</span></span><br><span class="line">expectedOutput.add(insertRecord(<span class="string">"fruit"</span>, <span class="number">4L</span>, <span class="number">33</span>, <span class="number">1L</span>));</span><br><span class="line">expectedOutput.add(insertRecord(<span class="string">"fruit"</span>, <span class="number">3L</span>, <span class="number">44</span>, <span class="number">2L</span>));</span><br><span class="line"><span class="comment">// ("fruit", 5L, 22)</span></span><br><span class="line">expectedOutput.add(updateAfterRecord(<span class="string">"fruit"</span>, <span class="number">5L</span>, <span class="number">22</span>, <span class="number">1L</span>));</span><br><span class="line">expectedOutput.add(updateAfterRecord(<span class="string">"fruit"</span>, <span class="number">4L</span>, <span class="number">33</span>, <span class="number">2L</span>));</span><br><span class="line">assertorWithRowNumber.assertOutputEquals(<span class="string">"output wrong."</span>, expectedOutput, testHarness.getOutput());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Output element -&gt; +I&#123;row1=+I(book,1,12), row2=+I(1)&#125;</span><br><span class="line">Output element -&gt; +I&#123;row1=+I(book,2,19), row2=+I(2)&#125;</span><br><span class="line">Output element -&gt; +U&#123;row1=+I(book,4,11), row2=+I(1)&#125;</span><br><span class="line">Output element -&gt; +U&#123;row1=+I(book,1,12), row2=+I(2)&#125;</span><br><span class="line">Output element -&gt; +U&#123;row1=+I(book,2,19), row2=+I(2)&#125;</span><br><span class="line">Output element -&gt; +U&#123;row1=+I(book,5,11), row2=+I(2)&#125;</span><br><span class="line">Output element -&gt; +I&#123;row1=+I(fruit,4,33), row2=+I(1)&#125;</span><br><span class="line">Output element -&gt; +I&#123;row1=+I(fruit,3,44), row2=+I(2)&#125;</span><br><span class="line">Output element -&gt; +U&#123;row1=+I(fruit,5,22), row2=+I(1)&#125;</span><br><span class="line">Output element -&gt; +U&#123;row1=+I(fruit,4,33), row2=+I(2)&#125;</span><br></pre></td></tr></table></figure><h2 id="UpdatableTopNFunction"><a href="#UpdatableTopNFunction" class="headerlink" title="UpdatableTopNFunction"></a>UpdatableTopNFunction</h2><p>支持更新流，是 RetractableTopNFunction 的简单实现版本，输入流中不能包含 DELETE 和 UPDATE_BEFORE 操作。</p><h3 id="UpdatableTopNFunctionTest"><a href="#UpdatableTopNFunctionTest" class="headerlink" title="UpdatableTopNFunctionTest"></a>UpdatableTopNFunctionTest</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tests for &#123;<span class="doctag">@link</span> UpdatableTopNFunction&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UpdatableTopNFunctionTest</span> <span class="keyword">extends</span> <span class="title">TopNFunctionTestBase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AbstractTopNFunction <span class="title">createFunction</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">RankType rankType,</span></span></span><br><span class="line"><span class="function"><span class="params">RankRange rankRange,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">boolean</span> generateUpdateBefore,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">boolean</span> outputRankNumber)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> UpdatableTopNFunction(</span><br><span class="line">minTime.toMilliseconds(),</span><br><span class="line">maxTime.toMilliseconds(),</span><br><span class="line">inputRowType,</span><br><span class="line">rowKeySelector,</span><br><span class="line">sortKeyComparator,</span><br><span class="line">sortKeySelector,</span><br><span class="line">rankType,</span><br><span class="line">rankRange,</span><br><span class="line">generateUpdateBefore,</span><br><span class="line">outputRankNumber,</span><br><span class="line">cacheSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testVariableRankRange</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">AbstractTopNFunction func = createFunction(RankType.ROW_NUMBER,</span><br><span class="line"><span class="comment">// TopN 的集合大小随着数据动态变化</span></span><br><span class="line"><span class="keyword">new</span> VariableRankRange(<span class="number">1</span>),</span><br><span class="line"><span class="keyword">true</span>,</span><br><span class="line"><span class="keyword">false</span>);</span><br><span class="line">OneInputStreamOperatorTestHarness&lt;RowData, RowData&gt; testHarness = createTestHarness(func);</span><br><span class="line">testHarness.open();</span><br><span class="line">testHarness.processElement(insertRecord(<span class="string">"book"</span>, <span class="number">2L</span>, <span class="number">19</span>));</span><br><span class="line">testHarness.processElement(updateAfterRecord(<span class="string">"book"</span>, <span class="number">2L</span>, <span class="number">18</span>));</span><br><span class="line">testHarness.processElement(insertRecord(<span class="string">"fruit"</span>, <span class="number">1L</span>, <span class="number">44</span>));</span><br><span class="line">testHarness.processElement(updateAfterRecord(<span class="string">"fruit"</span>, <span class="number">1L</span>, <span class="number">33</span>));</span><br><span class="line">testHarness.processElement(updateAfterRecord(<span class="string">"fruit"</span>, <span class="number">1L</span>, <span class="number">22</span>));</span><br><span class="line">testHarness.close();</span><br><span class="line"></span><br><span class="line">ConcurrentLinkedQueue&lt;Object&gt; output = testHarness.getOutput();</span><br><span class="line"><span class="keyword">for</span> (Object o : output) &#123;</span><br><span class="line">StreamRecord streamRecord = (StreamRecord) o;</span><br><span class="line">System.out.println(<span class="string">"Output element -&gt; "</span> + streamRecord.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;Object&gt; expectedOutput = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">expectedOutput.add(insertRecord(<span class="string">"book"</span>, <span class="number">2L</span>, <span class="number">19</span>));</span><br><span class="line">expectedOutput.add(updateBeforeRecord(<span class="string">"book"</span>, <span class="number">2L</span>, <span class="number">19</span>));</span><br><span class="line">expectedOutput.add(updateAfterRecord(<span class="string">"book"</span>, <span class="number">2L</span>, <span class="number">18</span>));</span><br><span class="line">expectedOutput.add(insertRecord(<span class="string">"fruit"</span>, <span class="number">1L</span>, <span class="number">44</span>));</span><br><span class="line">expectedOutput.add(updateBeforeRecord(<span class="string">"fruit"</span>, <span class="number">1L</span>, <span class="number">44</span>));</span><br><span class="line">expectedOutput.add(updateAfterRecord(<span class="string">"fruit"</span>, <span class="number">1L</span>, <span class="number">33</span>));</span><br><span class="line">expectedOutput.add(updateBeforeRecord(<span class="string">"fruit"</span>, <span class="number">1L</span>, <span class="number">33</span>));</span><br><span class="line">expectedOutput.add(updateAfterRecord(<span class="string">"fruit"</span>, <span class="number">1L</span>, <span class="number">22</span>));</span><br><span class="line">assertorWithoutRowNumber</span><br><span class="line">.assertOutputEquals(<span class="string">"output wrong."</span>, expectedOutput, testHarness.getOutput());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Output element -&gt; +I(book,2,19)</span><br><span class="line">Output element -&gt; -U(book,2,19)</span><br><span class="line">Output element -&gt; +U(book,2,18)</span><br><span class="line">Output element -&gt; +I(fruit,1,44)</span><br><span class="line">Output element -&gt; -U(fruit,1,44)</span><br><span class="line">Output element -&gt; +U(fruit,1,33)</span><br><span class="line">Output element -&gt; -U(fruit,1,33)</span><br><span class="line">Output element -&gt; +U(fruit,1,22)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将基于 flink &lt;code&gt;release-1.11&lt;/code&gt; 源码，简单分析下 TopN function 的实现。&lt;/p&gt;
    
    </summary>
    
      <category term="Flink" scheme="http://yoursite.com/categories/Flink/"/>
    
    
  </entry>
  
  <entry>
    <title>Flink部署-flink-on-kubernetes</title>
    <link href="http://yoursite.com/2020/09/29/Flink%E9%83%A8%E7%BD%B2-flink-on-kubernetes/"/>
    <id>http://yoursite.com/2020/09/29/Flink部署-flink-on-kubernetes/</id>
    <published>2020-09-29T07:23:17.000Z</published>
    <updated>2020-09-29T09:13:38.017Z</updated>
    
    <content type="html"><![CDATA[<p>kubernetes 是目前非常流行的容器编排系统，在其之上可以运行 web 服务、大数据处理等各类应用。这些应用被打包在非常轻量的容器中，我们通过声明的方式来告知 kubernetes 要如何部署和扩容这些程序，并对外提供服务。flink on kubernetes 可以得到一个健壮和高可扩的数据处理应用，并且能够更安全的和其他服务共享一个 kubernetes 集群。</p><p>本文将记录使用 kubernetes 部署 flink 应用的步骤。</p><a id="more"></a><h2 id="Mac-安装-Docker"><a href="#Mac-安装-Docker" class="headerlink" title="Mac 安装 Docker"></a>Mac 安装 Docker</h2><p>Docker Desktop 下载地址：<a href="https://www.docker.com/get-started" target="_blank" rel="noopener">Docker 官网</a><br>注册 DockerID 并登录。</p><p>安装 docker 命令行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> brew install docker</span></span><br></pre></td></tr></table></figure><h2 id="Minikube-搭建-Kubernetes-实验环境"><a href="#Minikube-搭建-Kubernetes-实验环境" class="headerlink" title="Minikube 搭建 Kubernetes 实验环境"></a>Minikube 搭建 Kubernetes 实验环境</h2><p>可以参考：<a href="https://kubernetes.io/docs/setup/learning-environment/minikube/#quickstart" target="_blank" rel="noopener">Kubernetes 官网</a></p><h3 id="安装-Minikube"><a href="#安装-Minikube" class="headerlink" title="安装 Minikube"></a>安装 Minikube</h3><ol><li><p>校验 MacOS 是否支持虚拟化，运行如下命令出现 ‘VMX’：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sysctl -a | grep -E --color <span class="string">'machdep.cpu.features|VMX'</span></span></span><br></pre></td></tr></table></figure></li><li><p>安装 kubectl 命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -LO <span class="string">"https://storage.googleapis.com/kubernetes-release/release/<span class="variable">$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)</span>/bin/darwin/amd64/kubectl"</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> chmod +x ./kubectl</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo mv ./kubectl /usr/<span class="built_in">local</span>/bin/kubectl</span></span><br></pre></td></tr></table></figure><p> 或者直接使用 Homebrew 安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> brew install kubectl </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> brew install kubernetes-cli</span></span><br></pre></td></tr></table></figure><p> 查看是否安装成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl version --client</span></span><br><span class="line">Client Version: version.Info&#123;Major:"1", Minor:"19", GitVersion:"v1.19.2", GitCommit:"f5743093fd1c663cb0cbc89748f730662345d44d", GitTreeState:"clean", BuildDate:"2020-09-16T13:41:02Z", GoVersion:"go1.15", Compiler:"gc", Platform:"darwin/amd64"&#125;</span><br></pre></td></tr></table></figure></li><li><p>安装 VirtualBox<br>VirtualBox 下载地址：<a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="noopener">VirtualBox 官网</a></p></li></ol><ol start="4"><li><p>安装 minikube</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-darwin-amd64 &amp;&amp; chmod +x minikube</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo mv minikube /usr/<span class="built_in">local</span>/bin</span></span><br></pre></td></tr></table></figure><p> 或者直接使用 Homebrew 安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> brew install minikube</span></span><br></pre></td></tr></table></figure></li><li><p>执行 minikube start<br>该命令会下载 kubelet 和 kubeadm 程序，并构建一个完整的 k8s 集群。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> minikube start</span></span><br></pre></td></tr></table></figure></li><li><p>查看 k8s pods<br>Minikube 已经将命令 kubectl 指向虚拟机中的 k8s 集群了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pods -A</span></span><br><span class="line">kube-system   coredns-f9fd979d6-xjht6                           1/1     Running   0          5h14m</span><br><span class="line">kube-system   etcd-minikube                                     1/1     Running   0          5h14m</span><br><span class="line">kube-system   kube-apiserver-minikube                           1/1     Running   0          5h14m</span><br><span class="line">kube-system   kube-controller-manager-minikube                  1/1     Running   0          5h14m</span><br><span class="line">kube-system   kube-proxy-ff8m8                                  1/1     Running   0          5h14m</span><br><span class="line">kube-system   kube-scheduler-minikube                           1/1     Running   0          5h14m</span><br><span class="line">kube-system   storage-provisioner                               1/1     Running   0          5h14m</span><br></pre></td></tr></table></figure></li></ol><h2 id="Flink-实时处理-demo"><a href="#Flink-实时处理-demo" class="headerlink" title="Flink 实时处理 demo"></a>Flink 实时处理 demo</h2><p>我们可以编写一个简单的实时处理脚本，该脚本会从某个端口中读取文本，分割为单词，并且每 5 秒钟打印一次每个单词出现的次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;Tuple2&lt;String, Integer&gt;&gt; dataStream = env</span><br><span class="line">    .socketTextStream(<span class="string">"192.168.99.1"</span>, <span class="number">9999</span>)</span><br><span class="line">    .flatMap(<span class="keyword">new</span> Splitter())</span><br><span class="line">    .keyBy(<span class="number">0</span>)</span><br><span class="line">    .timeWindow(Time.seconds(<span class="number">5</span>))</span><br><span class="line">    .sum(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">dataStream.print();</span><br><span class="line"></span><br><span class="line">env.execute(<span class="string">"Window WordCount"</span>);</span><br></pre></td></tr></table></figure><p>K8s 容器中的程序可以通过 IP 192.168.99.1 来访问 Minikube 宿主机上的服务。</p><p>demo 下载：<a href="flink-on-kubernetes-0.0.1-SNAPSHOT-jar-with-dependencies.jar">flink-on-kubernetes-0.0.1-SNAPSHOT-jar-with-dependencies.jar</a></p><h2 id="构建-Docker-容器镜像"><a href="#构建-Docker-容器镜像" class="headerlink" title="构建 Docker 容器镜像"></a>构建 Docker 容器镜像</h2><p>flink 提供了一个官方的容器镜像，可以从 <a href="https://hub.docker.com/_/flink?tab=tags&page=1&name=1.8.1-scala_2.12" target="_blank" rel="noopener">DockerHub</a> 上下载镜像。<br>官方镜像的 <a href="https://github.com/docker-flink/docker-flink/blob/master/1.8/scala_2.12-debian/Dockerfile" target="_blank" rel="noopener">Dockerfile</a>，以 <code>1.8.1-scala_2.12</code> 为例，大致内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FROM openjdk:8-jre</span><br><span class="line">ENV FLINK_HOME=/opt/flink</span><br><span class="line">ENV PATH=$FLINK_HOME/bin:$PATH</span><br><span class="line">RUN groupadd --system --gid=9999 flink &amp;&amp; \</span><br><span class="line">    useradd --system --home-dir $FLINK_HOME --uid=9999 --gid=flink flink</span><br><span class="line">WORKDIR $FLINK_HOME</span><br><span class="line"></span><br><span class="line">RUN useradd flink &amp;&amp; \</span><br><span class="line">  wget -O flink.tgz &quot;$FLINK_TGZ_URL&quot; &amp;&amp; \</span><br><span class="line">  tar -xf flink.tgz</span><br><span class="line">ENTRYPOINT [&quot;/docker-entrypoint.sh&quot;]</span><br></pre></td></tr></table></figure><p>主要做了以下几件事情：</p><ul><li>将 OpenJDK 1.8 作为基础镜像</li><li>下载并安装 flink 至 /opt/flink 目录中</li><li>添加 flink 用户和组等</li></ul><p>下面我们以 flink:1.8.1-scala_2.12 作为基础镜像，编写新的 Dockerfile，将打包好的任务 jar 包放置进去。此外，新版 flink 已将 hadoop 依赖从官方发行版本中剥离，因此在打包镜像的时候也要包含进去。<br>Hadoop jar 下载：<a href="flink-shaded-hadoop-2-uber-2.8.3-7.0.jar">flink-shaded-hadoop-2-uber-2.8.3-7.0.jar</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">FROM flink:1.8.1-scala_2.12</span><br><span class="line"></span><br><span class="line">ARG hadoop_jar</span><br><span class="line">ARG job_jar</span><br><span class="line"></span><br><span class="line">ENV FLINK_CONF=$FLINK_HOME/conf/flink-conf.yaml</span><br><span class="line"></span><br><span class="line">RUN set -x &amp;&amp; \</span><br><span class="line">  sed -i -e &quot;s/jobmanager\.heap\.size:.*/jobmanager.heap.size: 128m/g&quot; $FLINK_CONF &amp;&amp; \</span><br><span class="line">  sed -i -e &quot;s/taskmanager\.heap\.size:.*/taskmanager.heap.size: 256m/g&quot; $FLINK_CONF</span><br><span class="line"></span><br><span class="line">COPY --chown=flink:flink $hadoop_jar $job_jar $FLINK_HOME/lib/</span><br><span class="line"></span><br><span class="line">USER flink</span><br></pre></td></tr></table></figure><p>将 docker 命令行指向 Minikube 中的 Docker 服务，这样打印出来的镜像才能被 k8s 使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">eval</span> $(minikube docker-env)</span></span><br></pre></td></tr></table></figure><p>移动到 Dockerfile 所在目录，开始构建镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker build \</span></span><br><span class="line">  --build-arg hadoop_jar=flink-shaded-hadoop-2-uber-2.8.3-7.0.jar \</span><br><span class="line">  --build-arg job_jar=flink-on-kubernetes-0.0.1-SNAPSHOT-jar-with-dependencies.jar \</span><br><span class="line">  --tag flink-on-kubernetes:0.0.1 .</span><br></pre></td></tr></table></figure><p>镜像打包完毕，可用于部署：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker image ls</span></span><br><span class="line">REPOSITORY                           TAG                                              IMAGE ID            CREATED             SIZE</span><br><span class="line">flink-on-kubernetes                  0.0.1                                            ed4dfaf07cfe        5 hours ago         618MB</span><br></pre></td></tr></table></figure><h2 id="部署-JobManager"><a href="#部署-JobManager" class="headerlink" title="部署 JobManager"></a>部署 JobManager</h2><p><code>jobmanager.yml</code> ：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Job</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">$&#123;JOB&#125;-jobmanager</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">flink</span></span><br><span class="line"><span class="attr">        instance:</span> <span class="string">$&#123;JOB&#125;-jobmanager</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      restartPolicy:</span> <span class="string">OnFailure</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">jobmanager</span></span><br><span class="line"><span class="attr">        image:</span> <span class="attr">flink-on-kubernetes:0.0.1</span></span><br><span class="line"><span class="attr">        command:</span> <span class="string">["/opt/flink/bin/standalone-job.sh"]</span></span><br><span class="line"><span class="attr">        args:</span> <span class="string">["start-foreground",</span></span><br><span class="line">               <span class="string">"-Djobmanager.rpc.address=$&#123;JOB&#125;-jobmanager"</span><span class="string">,</span></span><br><span class="line">               <span class="string">"-Dparallelism.default=1"</span><span class="string">,</span></span><br><span class="line">               <span class="string">"-Dblob.server.port=6124"</span><span class="string">,</span></span><br><span class="line">               <span class="string">"-Dqueryable-state.server.ports=6125"</span><span class="string">,</span></span><br><span class="line">               <span class="string">"-Dstate.savepoints.dir=hdfs://192.168.99.1:9000/flink/savepoints/"</span><span class="string">,</span></span><br><span class="line">               <span class="string">]</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">6123</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">rpc</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">6124</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">blob</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">6125</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">query</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">ui</span></span><br></pre></td></tr></table></figure><ul><li>${JOB} 变量可以使用 <code>envsubst</code> 命令来替换</li><li>容器的入口修改为 <code>standalone-job.sh</code></li><li>JobManager 的 rpc 地址修改为了 k8s Service 的名称，集群中的其他组件将通过这个名称来访问 JobManager。</li><li>为 Flink Blob Server &amp; Queryable State Server 指定默认端口号</li></ul><p>使用 <code>kubectl</code> 命令创建 JobManager pod，并查看状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> JOB=flink-on-kubernetes</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> envsubst &lt;jobmanager.yml | kubectl create -f -</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pod</span></span><br><span class="line">NAME                                              READY   STATUS    RESTARTS   AGE</span><br><span class="line">flink-on-kubernetes-jobmanager-dzhcs              1/1     Running   0          77m</span><br></pre></td></tr></table></figure><p>创建一个 k8s Service 把 JobManager 的端口开放出来，以便 TaskManager 前来注册。<br><code>service.yml</code>：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">$&#123;JOB&#125;-jobmanager</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">flink</span></span><br><span class="line"><span class="attr">    instance:</span> <span class="string">$&#123;JOB&#125;-jobmanager</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">NodePort</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">rpc</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">6123</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">blob</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">6124</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">query</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">6125</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">ui</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">8081</span></span><br></pre></td></tr></table></figure><p>使用 <code>kubectl</code> 命令创建 JobManager service，并查看状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> envsubst &lt;service.yml | kubectl create -f -</span></span><br><span class="line"><span class="meta">$</span><span class="bash">  kubectl get service</span></span><br><span class="line">NAME                             TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)                                                       AGE</span><br><span class="line">flink-on-kubernetes-jobmanager   NodePort    10.104.157.70   &lt;none&gt;        6123:30261/TCP,6124:31158/TCP,6125:30509/TCP,8081:30262/TCP   89m</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> minikube service <span class="variable">$JOB</span>-jobmanager --url</span></span><br><span class="line">http://192.168.99.100:30261</span><br><span class="line">http://192.168.99.100:31158</span><br><span class="line">http://192.168.99.100:30509</span><br><span class="line">http://192.168.99.100:30262</span><br></pre></td></tr></table></figure><p><img src="JobManager%E9%80%8F%E5%87%BA%E7%9A%84Dashboard.png" alt></p><h2 id="部署-TaskManager"><a href="#部署-TaskManager" class="headerlink" title="部署 TaskManager"></a>部署 TaskManager</h2><p><code>taskmanager.yml</code> ：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">$&#123;JOB&#125;-taskmanager</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">flink</span></span><br><span class="line"><span class="attr">      instance:</span> <span class="string">$&#123;JOB&#125;-taskmanager</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">flink</span></span><br><span class="line"><span class="attr">        instance:</span> <span class="string">$&#123;JOB&#125;-taskmanager</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">taskmanager</span></span><br><span class="line"><span class="attr">        image:</span> <span class="attr">flink-on-kubernetes:0.0.1</span></span><br><span class="line"><span class="attr">        command:</span> <span class="string">["/opt/flink/bin/taskmanager.sh"]</span></span><br><span class="line"><span class="attr">        args:</span> <span class="string">["start-foreground",</span> <span class="string">"-Djobmanager.rpc.address=$&#123;JOB&#125;-jobmanager"</span><span class="string">]</span></span><br></pre></td></tr></table></figure><p>使用 <code>kubectl</code> 命令创建 TaskManager pod，并查看状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pod</span></span><br><span class="line">NAME                                              READY   STATUS    RESTARTS   AGE</span><br><span class="line">flink-on-kubernetes-jobmanager-dzhcs              1/1     Running   0          77m</span><br><span class="line">flink-on-kubernetes-taskmanager-64b7cc4bf-9t6cr   1/1     Running   2          77m</span><br></pre></td></tr></table></figure><p>至此，Flink 脚本集群已经在运行中了。在监听终端下输入如下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nc -lk 9999</span></span><br><span class="line">hello world</span><br><span class="line">hello flink</span><br></pre></td></tr></table></figure><p>打开另一个终端，查看 TaskManager 的标准输出日志：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl logs -f -l instance=<span class="variable">$JOB</span>-taskmanager</span></span><br><span class="line">(hello,2)</span><br><span class="line">(flink,1)</span><br><span class="line">(world,1)</span><br></pre></td></tr></table></figure><p><img src="taskmanager%E7%BB%9F%E8%AE%A1%E5%8D%95%E8%AF%8D%E7%9A%84%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA%E6%97%A5%E5%BF%97.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;kubernetes 是目前非常流行的容器编排系统，在其之上可以运行 web 服务、大数据处理等各类应用。这些应用被打包在非常轻量的容器中，我们通过声明的方式来告知 kubernetes 要如何部署和扩容这些程序，并对外提供服务。flink on kubernetes 可以得到一个健壮和高可扩的数据处理应用，并且能够更安全的和其他服务共享一个 kubernetes 集群。&lt;/p&gt;
&lt;p&gt;本文将记录使用 kubernetes 部署 flink 应用的步骤。&lt;/p&gt;
    
    </summary>
    
      <category term="Flink" scheme="http://yoursite.com/categories/Flink/"/>
    
    
  </entry>
  
  <entry>
    <title>数仓建模</title>
    <link href="http://yoursite.com/2020/08/30/%E6%95%B0%E4%BB%93%E5%BB%BA%E6%A8%A1/"/>
    <id>http://yoursite.com/2020/08/30/数仓建模/</id>
    <published>2020-08-30T07:17:02.000Z</published>
    <updated>2021-06-03T11:32:03.275Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Hey, password is required here.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="19069d48fa4630dbf0c27ec582746095b5566ad0fa55a70059bf774e567702db">49f7eb9bea6cd6a47e660ee8aad95e5f73cac4e1b520f2f05987d67f416cec10d8c2add8935a4ae2fb7082d916f36e1d3b1ed1fb7bcc4a12e137188f59446abb2793b486bccbe4623c71e641069af1d03b6d7448688f68fd44135d03359ccd28f09c7d65ba42a4d058f4476b96d7f174862b5dc8cec10b8e87ab53a12373a774d75aa90e65ca65ea44be5aba777dcc773c576337a2e70b471a5f8b9c51dcd0d08399d3077fa4d7a6c5ecd1d38a2ca5c8a12bfc2a5d1063c3a7b08ed47526b9efc6a3416b2e9cc165277add16e50e26b375fd18b880deba7cf6cb87dc2e2da1a5026eec9857555689114cdc2f07682ddd7fe1b0e05d0fde7fbcdf74d980dd66ff1a09e0e0b0ea2b7efa55d7a3a0324450149c1d23b68dd405e59498865fc4419f16b0cdc2a9ab426677f774e850ceb8127a193dcac1eafcaf4991c8a4d3d729cace9b533923714f2f99ebc591ae2f7454b70067e0827301f293ecbf8daa9fc8cdc07ee0bd664df675b39eea60c2721bce411442e4f45525b364d261f1bb75e017d235a89c7a11d09bd618aeef49cca101573c0fd7b8f06880b330b0c3f98e62fc047990982c7cda3e652e92610cacaf18602219bbc15b0648fea56d47ac9c1e9c8bff0a8fee80b7de9b68f1757ba152e9fe0c58ff471974d313009242c7ad9011</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      Here&#39;s something encrypted, password is required to continue reading.
    
    </summary>
    
      <category term="BigData" scheme="http://yoursite.com/categories/BigData/"/>
    
      <category term="Data WareHouse" scheme="http://yoursite.com/categories/BigData/Data-WareHouse/"/>
    
    
  </entry>
  
  <entry>
    <title>职业规划</title>
    <link href="http://yoursite.com/2020/07/01/%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/"/>
    <id>http://yoursite.com/2020/07/01/职业规划/</id>
    <published>2020-07-01T07:03:13.000Z</published>
    <updated>2021-06-03T11:33:00.912Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Hey, password is required here.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="14d602c993698899ec8f7dce7c0fffcd6feb9d11df9c94077396b1501d8350c8">49f7eb9bea6cd6a47e660ee8aad95e5f92bbfa9fa31ac4f0dd4c2609ce47fa2b9ac4820bcb0d20b13024247a24dbff74b4e1bc10854b2dcdfee53f3b8d596d3be45db846157e2926e065c5170bafd8420bc9ee8ff2f044cc90d0a6a1c0defe47b2b66a6bfc00481f4a3d425366e4bd87fa08ac706fe7fe9320915f17a6e3ffccbca5a6991393cab717accd0f50d508e807f16110e1174c5c1eebee69211eccfc894957f4b8e1468aa049332478c8428315199c1eafa504e8616898ec7da1d127bda0562374b4bcc3a177c8f003557970f910452c0354f329604fa7720d01dce2af1ee024c6d94ad65e01d721f8530196507bd83dd462d60fd4d5b33a81295c6612f4a9db22b3619d23fd54d071e825578fcb7cf1d854a5ef60806bc98d877b366f197e90f4c2697b4424aa52204ebca7547cdd821c16422ab79f8ad90c1952431bdf0019bbd3d8c455689a4948b03ab6fd49ea22a3bcbd7a35c564761f08a10728b47e2771cbae6def78b22e39cb592a79ef81f252466140195514703e3c10db6e71922c4f82b7ffefb64babb29fc2ce4abbdf7f7ebba6da244b90b270065729733e48feb4e59c868471aa25fb5908ba837e866ac0f858c85fa2f122e448df2b9bb9aa2aa57b9c07e6fee94a6757d0fcc1977f43850538723e2291e707be145241a33050d7a5c74ed82514997413f164b099de48dd20a9fe12da6f57c7cbd1b16045ecb6f804c9f685534abce1f692e9f7b0e36f738f8799c5fb121055264ca2e67d82767cfc679423d64b6ac2af863a7353befb4cf10b23f808ddc359f80f0053124b8bd68371d1e030f5d840ca147834324c7b07c9ec9a5d5d4e4ca4128563da70f4e22bf6d85c169a9f79724a2eae77dd86745921becfe8fbc610069a5edf549128cd031a832c7c74dff1f06231574a29971f85a5444515803044858653e5cdbdcbc6eabeb7172822f33de99a2fe94e0576a42480e1bf97876d24a7dd7ab20446c80a92068054dc0caaa9bc0b152901a8415431b09841c9d2feebd76835536e3c2384cb5d856339d25aecc33626d6378ba5223b67eff48f3c450dd0534e6f2f602ab908d923ee9210adc4143abc4ceb7b679bd86cd8f9b181a96d590c07d7d629d79d36ceef3611f331815b2cf837a1da4fd42470850cbceb8b2c46acdc1a986ed920feff61c43f52263e674c1fd57444a58bc840985caead1068fcd1f077ad50c38fb4bb9dfb8590da0faa2f494e714d2b98865f792c1288b83e1f1058e89a7193712a849b151453d80196f68345a0e6bab402e6a8cecaa8925d7b9a04cda116cd4a11e54f9160ed2f1cd70c70b83b0723e16fbc0dd602fef1ff7e0df205d821da35c16d11de6b006d3c6ce45f45a1fd5fe0395edb6bf84184d5b9e34052aaead6e9d2821ce671a8ac55770b69239e85c9692183075184ee08c498c475cea0aa36c759fab82dd23de1084cb91ccbd6ca73900b0bd946fb22ac73d6eaaebca06914a9f47131feb9f94a2ea2bea330cd53758e23a8c3e6ee8ace1f5db45f8ba6f8f627691e95b1eb765cd52cc102aad3a590c3f6e7cf5b3cb09698a9f39fea21bb87826afc39a07742a311ae1cf839</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      Here&#39;s something encrypted, password is required to continue reading.
    
    </summary>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>Hexo常用命令</title>
    <link href="http://yoursite.com/2020/05/24/Hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2020/05/24/Hexo常用命令/</id>
    <published>2020-05-24T02:38:00.000Z</published>
    <updated>2021-05-24T05:53:55.340Z</updated>
    
    <content type="html"><![CDATA[<p>使用 Hexo + Github 搭建个人博客的常用命令，在此记录下。</p><a id="more"></a><h2 id="init"><a href="#init" class="headerlink" title="init"></a>init</h2><p>新建一个网站</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init "文件夹名称"</span><br></pre></td></tr></table></figure><h2 id="version"><a href="#version" class="headerlink" title="version"></a>version</h2><p>显示 Hexo 版本。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo version</span><br></pre></td></tr></table></figure><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new "新文章名"</span><br></pre></td></tr></table></figure><h2 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h2><p>生成静态网页</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><h2 id="server"><a href="#server" class="headerlink" title="server"></a>server</h2><p>启动服务器。默认情况下，访问网址为：<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><h2 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h2><p>部署网站。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><p>列出网站资料</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo list &lt;type&gt;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://hexo.io/zh-cn/docs/commands.html" target="_blank" rel="noopener">Hexo 指令</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 Hexo + Github 搭建个人博客的常用命令，在此记录下。&lt;/p&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://yoursite.com/categories/Tools/"/>
    
    
  </entry>
  
  <entry>
    <title>Git常用命令</title>
    <link href="http://yoursite.com/2020/05/24/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2020/05/24/Git常用命令/</id>
    <published>2020-05-24T02:37:42.000Z</published>
    <updated>2021-05-24T05:10:01.093Z</updated>
    
    <content type="html"><![CDATA[<p>Git 命令比较多，会经常 fork git 仓库，fork 仓库同步原远程仓库的操作，也会经常忘记，特此记录下。</p><a id="more"></a><h2 id="新建代码库"><a href="#新建代码库" class="headerlink" title="新建代码库"></a>新建代码库</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在当前目录新建一个Git代码库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个目录，将其初始化为Git代码库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git init [project-name]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载一个项目和它的整个代码历史</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> [url]</span></span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>Git 的设置文件为 .gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 显示当前的Git配置</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --list</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编辑Git配置文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config -e [--global]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置提交代码时的用户信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config [--global] user.name <span class="string">"[name]"</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config [--global] user.email <span class="string">"[email address]"</span></span></span><br></pre></td></tr></table></figure><h2 id="增加-删除文件"><a href="#增加-删除文件" class="headerlink" title="增加/删除文件"></a>增加/删除文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加指定文件到暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add [file1] [file2] ...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加指定目录到暂存区，包括子目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add [dir]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加当前目录的所有文件到暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add .</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加每个变化前，都会要求确认</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 对于同一个文件的多处变化，可以实现分次提交</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add -p</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除工作区文件，并且将这次删除放入暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rm [file1] [file2] ...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止追踪指定文件，但该文件会保留在工作区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rm --cached [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 改名文件，并且将这个改名放入暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git mv [file-original] [file-renamed]</span></span><br></pre></td></tr></table></figure><h2 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 提交暂存区到仓库区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m [message]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交暂存区的指定文件到仓库区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit [file1] [file2] ... -m [message]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交工作区自上次commit之后的变化，直接到仓库区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -a</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交时显示所有diff信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -v</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用一次新的commit，替代上一次提交</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend -m [message]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重做上一次commit，并包括指定文件的新变化</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend [file1] [file2] ...</span></span><br></pre></td></tr></table></figure><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出所有本地分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出所有远程分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -r</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出所有本地分支和远程分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -a</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个分支，但依然停留在当前分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch [branch-name]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个分支，并切换到该分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b [branch]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个分支，指向指定commit</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch [branch] [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个分支，与指定的远程分支建立追踪关系</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch --track [branch] [remote-branch]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换到指定分支，并更新工作区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout [branch-name]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换到上一个分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 建立追踪关系，在现有分支与指定的远程分支之间</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch --<span class="built_in">set</span>-upstream [branch] [remote-branch]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 合并指定分支到当前分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge [branch]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 选择一个commit，合并进当前分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git cherry-pick [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -d [branch-name]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除远程分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin --delete [branch-name]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -dr [remote/branch]</span></span><br></pre></td></tr></table></figure><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 列出所有tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个tag在当前commit</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag [tag]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个tag在指定commit</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag [tag] [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除本地tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag -d [tag]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除远程tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin :refs/tags/[tagName]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看tag信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git show [tag]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交指定tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] [tag]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交所有tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] --tags</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个分支，指向某个tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b [branch] [tag]</span></span><br></pre></td></tr></table></figure><h2 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 显示有变更的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示当前分支的版本历史</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示commit历史，以及每次commit发生变更的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --<span class="built_in">stat</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 搜索提交历史，根据关键词</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -S [keyword]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某个commit之后的所有变动，每个commit占据一行</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> [tag] HEAD --pretty=format:%s</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某个commit之后的所有变动，其<span class="string">"提交说明"</span>必须符合搜索条件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> [tag] HEAD --grep feature</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某个文件的版本历史，包括文件改名</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --follow [file]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git whatchanged [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示指定文件相关的每一次diff</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -p [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示过去5次提交</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -5 --pretty --oneline</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示所有提交过的用户，按提交次数排序</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git shortlog -sn</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示指定文件是什么人在什么时间修改过</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git blame [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示暂存区和工作区的差异</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示暂存区和上一个commit的差异</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff --cached [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示工作区与当前分支最新commit之间的差异</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff HEAD</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示两次提交之间的差异</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff [first-branch]...[second-branch]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示今天你写了多少行代码</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff --shortstat <span class="string">"@&#123;0 day ago&#125;"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某次提交的元数据和内容变化</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git show [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某次提交发生变化的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git show --name-only [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某次提交时，某个文件的内容</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git show [commit]:[filename]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示当前分支的最近几次提交</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reflog</span></span><br></pre></td></tr></table></figure><h2 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载远程仓库的所有变动</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git fetch [remote]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示所有远程仓库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote -v</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某个远程仓库的信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote show [remote]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 增加一个新的远程仓库，并命名</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote add [shortname] [url]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 取回远程仓库的变化，并与本地分支合并</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git pull [remote] [branch]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 上传本地指定分支到远程仓库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] [branch]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 强行推送当前分支到远程仓库，即使有冲突</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] --force</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 推送所有分支到远程仓库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] --all</span></span><br></pre></td></tr></table></figure><h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 恢复暂存区的指定文件到工作区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 恢复某个commit的指定文件到暂存区和工作区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout [commit] [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 恢复暂存区的所有文件到工作区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout .</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重置暂存区与工作区，与上一次commit保持一致</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset --keep [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个commit，用来撤销指定commit</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 后者的所有变化都将被前者抵消，并且应用到当前分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git revert [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 暂时将未提交的变化移除，稍后再移入</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git stash</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git stash pop</span></span><br></pre></td></tr></table></figure><h2 id="fork仓库合并原仓库"><a href="#fork仓库合并原仓库" class="headerlink" title="fork仓库合并原仓库"></a>fork仓库合并原仓库</h2><h3 id="merge-前的设定"><a href="#merge-前的设定" class="headerlink" title="merge 前的设定"></a>merge 前的设定</h3><ul><li><p>进入本地仓库目录</p></li><li><p>查看远程仓库的路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure></li><li><p>将远程仓库设置成 fork 仓库的上游代码库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add upstream 远程仓库.git</span><br></pre></td></tr></table></figure></li><li><p>检查本地提交<br>执行命令 git status 检查本地是否有未提交的修改。如果有，则把你本地的有效修改，先从本地仓库推送到你的github仓库。最后再执行一次 git status 检查本地已无未提交的修改</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git add -A 或者 git add filename</span><br><span class="line">git commit -m "your note"</span><br><span class="line">git push origin master</span><br><span class="line">git status</span><br></pre></td></tr></table></figure></li></ul><h3 id="merge-的相关命令"><a href="#merge-的相关命令" class="headerlink" title="merge 的相关命令"></a>merge 的相关命令</h3><ul><li><p>抓取原仓库的更新</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch upstream 远程仓库.git</span><br></pre></td></tr></table></figure></li><li><p>切换到 fork 仓库的 master 分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure></li><li><p>合并远程的 master 分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge upstream/master</span><br></pre></td></tr></table></figure></li><li><p>推送 fork 仓库的修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 生成一个可供发布的压缩包</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git archive</span></span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="noopener">常用 Git 命令清单</a><br><a href="https://github.com/selfteaching/the-craft-of-selfteaching/issues/67" target="_blank" rel="noopener">Github进行fork后如何与原仓库同步：重新fork很省事，但不如反复练习版本合并</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Git 命令比较多，会经常 fork git 仓库，fork 仓库同步原远程仓库的操作，也会经常忘记，特此记录下。&lt;/p&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://yoursite.com/categories/Tools/"/>
    
    
  </entry>
  
  <entry>
    <title>Flink源码剖析-flink-streaming-java_JobGraph</title>
    <link href="http://yoursite.com/2020/04/22/Flink%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-flink-streaming-java_JobGraph/"/>
    <id>http://yoursite.com/2020/04/22/Flink源码剖析-flink-streaming-java_JobGraph/</id>
    <published>2020-04-22T14:29:49.000Z</published>
    <updated>2020-04-22T16:55:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要围绕 Flink 源码中 <code>flink-streaming-java</code> 模块。介绍下 StreamGraph 转成 JobGraph 的过程等。</p><a id="more"></a><p>StreamGraph 和 JobGraph 都是在 Client 端生成的，也就是说我们可以在 IDE 中通过断点调试观察 StreamGraph 和 JobGraph 的生成过程。</p><h2 id="前置调用"><a href="#前置调用" class="headerlink" title="前置调用"></a>前置调用</h2><p>从 StreamExecutionEnvironment 中的 execute() 方法一直往下跟：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Streaming 程序的提交入口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JobExecutionResult <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">return</span> execute(DEFAULT_JOB_NAME);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成 StreamGraph</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JobExecutionResult <span class="title">execute</span><span class="params">(String jobName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Preconditions.checkNotNull(jobName, <span class="string">"Streaming Job name should not be null."</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> execute(getStreamGraph(jobName));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成 JobGraph ，提交任务，并响应 JobListeners</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Internal</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JobExecutionResult <span class="title">execute</span><span class="params">(StreamGraph streamGraph)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// 异步执行</span></span><br><span class="line"><span class="keyword">final</span> JobClient jobClient = executeAsync(streamGraph);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">final</span> JobExecutionResult jobExecutionResult;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (configuration.getBoolean(DeploymentOptions.ATTACHED)) &#123;</span><br><span class="line">jobExecutionResult = jobClient.getJobExecutionResult(userClassloader).get();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">jobExecutionResult = <span class="keyword">new</span> DetachedJobExecutionResult(jobClient.getJobID());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jobListeners.forEach(jobListener -&gt; jobListener.onJobExecuted(jobExecutionResult, <span class="keyword">null</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> jobExecutionResult;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">jobListeners.forEach(jobListener -&gt; &#123;</span><br><span class="line">jobListener.onJobExecuted(<span class="keyword">null</span>, ExceptionUtils.stripExecutionException(t));</span><br><span class="line">&#125;);</span><br><span class="line">ExceptionUtils.rethrowException(t);</span><br><span class="line"></span><br><span class="line"><span class="comment">// never reached, only make javac happy</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们详细看看 StreamExecutionEnvironment 中的 executeAsync 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据 execution.target 配置反射得到 PipelineExecutorFactory，拿出工厂类对应的 PipelineExecutor，执行其 execute 方法</span></span><br><span class="line"><span class="comment"> * execute的主要工作是将 StreamGraph 转成了 JobGraph，并创建相应的 ClusterClient 完成提交任务的操作。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Internal</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JobClient <span class="title">executeAsync</span><span class="params">(StreamGraph streamGraph)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">checkNotNull(streamGraph, <span class="string">"StreamGraph cannot be null."</span>);</span><br><span class="line">checkNotNull(configuration.get(DeploymentOptions.TARGET), <span class="string">"No execution.target specified in your configuration file."</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// SPI机制</span></span><br><span class="line"><span class="comment">// 根据flink Configuration中的"execution.target"加载 PipelineExecutorFactory</span></span><br><span class="line"><span class="comment">// PipelineExecutorFactory 的实现类在flink-clients包或者flink-yarn包里，因此需要在pom.xml中添加此依赖</span></span><br><span class="line"><span class="keyword">final</span> PipelineExecutorFactory executorFactory =</span><br><span class="line">executorServiceLoader.getExecutorFactory(configuration);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反射出的 PipelineExecutorFactory 类不能为空</span></span><br><span class="line">checkNotNull(</span><br><span class="line">executorFactory,</span><br><span class="line"><span class="string">"Cannot find compatible factory for specified execution.target (=%s)"</span>,</span><br><span class="line">configuration.get(DeploymentOptions.TARGET));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据加载到的 PipelineExecutorFactory 工厂类，获取其对应的 PipelineExecutor，</span></span><br><span class="line"><span class="comment">// 并执行 PipelineExecutor 的 execute() 方法，将 StreamGraph 转成 JobGraph</span></span><br><span class="line">CompletableFuture&lt;JobClient&gt; jobClientFuture = executorFactory</span><br><span class="line">.getExecutor(configuration)</span><br><span class="line">.execute(streamGraph, configuration);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步调用的返回结果</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">JobClient jobClient = jobClientFuture.get();</span><br><span class="line">jobListeners.forEach(jobListener -&gt; jobListener.onJobSubmitted(jobClient, <span class="keyword">null</span>));</span><br><span class="line"><span class="keyword">return</span> jobClient;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">jobListeners.forEach(jobListener -&gt; jobListener.onJobSubmitted(<span class="keyword">null</span>, t));</span><br><span class="line">ExceptionUtils.rethrow(t);</span><br><span class="line"></span><br><span class="line"><span class="comment">// make javac happy, this code path will not be reached</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>executeAsync 有涉及到 PipelineExecutorFactory 和 PipelineExecutor 。<br>PipelineExecutorFactory 是通过 SPI ServiceLoader 加载的，我们看下 <code>flink-clients</code> 模块的 <code>META-INF.services</code> 文件：<br><img src="flink-clients%E6%A8%A1%E5%9D%97%E7%9A%84META-INF%E6%96%87%E4%BB%B6.png" alt></p><p>PipelineExecutorFactory 的实现子类，分别对应着 Flink 的不同部署模式，local、standalone、yarn、kubernets 等：<br><img src="PipelineExecutorFactory%E5%AD%90%E7%B1%BB.png" alt></p><p>这里我们只看下 LocalExecutorFactory 的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Internal</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalExecutorFactory</span> <span class="keyword">implements</span> <span class="title">PipelineExecutorFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * execution.target 配置项对应的值为 "local"</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCompatibleWith</span><span class="params">(<span class="keyword">final</span> Configuration configuration)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> LocalExecutor.NAME.equalsIgnoreCase(configuration.get(DeploymentOptions.TARGET));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 直接 new 一个 LocalExecutor 返回</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PipelineExecutor <span class="title">getExecutor</span><span class="params">(<span class="keyword">final</span> Configuration configuration)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> LocalExecutor();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PipelineExecutor 的实现子类与 PipelineExecutorFactory 与工厂类一一对应，负责将 StreamGraph 转成 JobGraph，并生成 ClusterClient 执行任务的提交：<br><img src="PipelineExecutor%E5%AD%90%E7%B1%BB.png" alt></p><p>LocalExecutorFactory 对应的 LocalExecutor 实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Internal</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalExecutor</span> <span class="keyword">implements</span> <span class="title">PipelineExecutor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"local"</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;JobClient&gt; <span class="title">execute</span><span class="params">(Pipeline pipeline, Configuration configuration)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">checkNotNull(pipeline);</span><br><span class="line">checkNotNull(configuration);</span><br><span class="line"></span><br><span class="line"><span class="comment">// we only support attached execution with the local executor.</span></span><br><span class="line">checkState(configuration.getBoolean(DeploymentOptions.ATTACHED));</span><br><span class="line"></span><br><span class="line"><span class="comment">// StreamGraph 转成 JobGraph</span></span><br><span class="line"><span class="keyword">final</span> JobGraph jobGraph = getJobGraph(pipeline, configuration);</span><br><span class="line"></span><br><span class="line"><span class="comment">// local 模式，本地启动一个 Mini Cluster</span></span><br><span class="line"><span class="keyword">final</span> MiniCluster miniCluster = startMiniCluster(jobGraph, configuration);</span><br><span class="line"><span class="comment">// 创建 MiniClusterClient ，准备提交任务</span></span><br><span class="line"><span class="keyword">final</span> MiniClusterClient clusterClient = <span class="keyword">new</span> MiniClusterClient(configuration, miniCluster);</span><br><span class="line">        <span class="comment">// 提交任务</span></span><br><span class="line">CompletableFuture&lt;JobID&gt; jobIdFuture = clusterClient.submitJob(jobGraph);</span><br><span class="line"></span><br><span class="line">jobIdFuture</span><br><span class="line">.thenCompose(clusterClient::requestJobResult)</span><br><span class="line">.thenAccept((jobResult) -&gt; clusterClient.shutDownCluster());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> jobIdFuture.thenApply(jobID -&gt;</span><br><span class="line"><span class="keyword">new</span> ClusterClientJobClientAdapter&lt;&gt;(() -&gt; clusterClient, jobID));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> JobGraph <span class="title">getJobGraph</span><span class="params">(Pipeline pipeline, Configuration configuration)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里调用 FlinkPipelineTranslationUtil 的 getJobGraph() 方法</span></span><br><span class="line"><span class="keyword">return</span> FlinkPipelineTranslationUtil.getJobGraph(pipeline, configuration, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回归主题，我们看下 FlinkPipelineTranslationUtil 的 getJobGraph() 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JobGraph <span class="title">getJobGraph</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">Pipeline pipeline,</span></span></span><br><span class="line"><span class="function"><span class="params">Configuration optimizerConfiguration,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> defaultParallelism)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过反射得到 FlinkPipelineTranslator </span></span><br><span class="line">FlinkPipelineTranslator pipelineTranslator = getPipelineTranslator(pipeline);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pipelineTranslator.translateToJobGraph(pipeline,</span><br><span class="line">optimizerConfiguration,</span><br><span class="line">defaultParallelism);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> FlinkPipelineTranslator <span class="title">getPipelineTranslator</span><span class="params">(Pipeline pipeline)</span> </span>&#123;</span><br><span class="line">PlanTranslator planToJobGraphTransmogrifier = <span class="keyword">new</span> PlanTranslator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (planToJobGraphTransmogrifier.canTranslate(pipeline)) &#123;</span><br><span class="line"><span class="keyword">return</span> planToJobGraphTransmogrifier;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FlinkPipelineTranslator streamGraphTranslator = reflectStreamGraphTranslator();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其实就是判断当前的 Pipeline 实例是不是 StreamGraph</span></span><br><span class="line"><span class="keyword">if</span> (!streamGraphTranslator.canTranslate(pipeline)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Translator "</span> + streamGraphTranslator + <span class="string">" cannot translate "</span></span><br><span class="line">+ <span class="string">"the given pipeline "</span> + pipeline + <span class="string">"."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> streamGraphTranslator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> FlinkPipelineTranslator <span class="title">reflectStreamGraphTranslator</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; streamGraphTranslatorClass;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">streamGraphTranslatorClass = Class.forName(</span><br><span class="line"><span class="comment">// 因为这个类在 flink-streaming-java 模块中，FlinkPipelineTranslationUtil 在 flink-clients 模块中，</span></span><br><span class="line">    <span class="comment">// flink-clients 模块没有引入 flink-streaming-java 模块，所以只能通过反射拿到</span></span><br><span class="line"><span class="string">"org.apache.flink.streaming.api.graph.StreamGraphTranslator"</span>,</span><br><span class="line"><span class="keyword">true</span>,</span><br><span class="line">FlinkPipelineTranslationUtil.class.getClassLoader());</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Could not load StreamGraphTranslator."</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FlinkPipelineTranslator streamGraphTranslator;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">streamGraphTranslator =</span><br><span class="line">(FlinkPipelineTranslator) streamGraphTranslatorClass.newInstance();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Could not instantiate StreamGraphTranslator."</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> streamGraphTranslator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着走到 StreamGraphTranslator 的 translateToJobGraph 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamGraphTranslator</span> <span class="keyword">implements</span> <span class="title">FlinkPipelineTranslator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 其实就是调用 StreamGraph 自己的 getJobGraph 方法生成 JobGraph</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JobGraph <span class="title">translateToJobGraph</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">Pipeline pipeline,</span></span></span><br><span class="line"><span class="function"><span class="params">Configuration optimizerConfiguration,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> defaultParallelism)</span> </span>&#123;</span><br><span class="line">checkArgument(pipeline <span class="keyword">instanceof</span> StreamGraph,</span><br><span class="line"><span class="string">"Given pipeline is not a DataStream StreamGraph."</span>);</span><br><span class="line"></span><br><span class="line">StreamGraph streamGraph = (StreamGraph) pipeline;</span><br><span class="line"><span class="keyword">return</span> streamGraph.getJobGraph(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">translateToJSONExecutionPlan</span><span class="params">(Pipeline pipeline)</span> </span>&#123;</span><br><span class="line">checkArgument(pipeline <span class="keyword">instanceof</span> StreamGraph,</span><br><span class="line"><span class="string">"Given pipeline is not a DataStream StreamGraph."</span>);</span><br><span class="line"></span><br><span class="line">StreamGraph streamGraph = (StreamGraph) pipeline;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> streamGraph.getStreamingPlanAsJSON();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canTranslate</span><span class="params">(Pipeline pipeline)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> pipeline <span class="keyword">instanceof</span> StreamGraph;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="StreamGraph-到-JobGraph-的转换"><a href="#StreamGraph-到-JobGraph-的转换" class="headerlink" title="StreamGraph 到 JobGraph 的转换"></a>StreamGraph 到 JobGraph 的转换</h2><p>接着走到 StreamGraph 中的 getJobGraph() 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> JobGraph <span class="title">getJobGraph</span><span class="params">(@Nullable JobID jobID)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> StreamingJobGraphGenerator.createJobGraph(<span class="keyword">this</span>, jobID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着走到 StreamingJobGraphGenerator 的 createJobGraph() 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传入 StreamGraph，生成 JobGraph</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JobGraph <span class="title">createJobGraph</span><span class="params">(StreamGraph streamGraph)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> createJobGraph(streamGraph, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JobGraph <span class="title">createJobGraph</span><span class="params">(StreamGraph streamGraph, @Nullable JobID jobID)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> StreamingJobGraphGenerator(streamGraph, jobID).createJobGraph();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 核心方法</span></span><br><span class="line"><span class="comment"> * StreamGraph 转 JobGraph 的整体流程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> JobGraph <span class="title">createJobGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">preValidate();</span><br><span class="line"></span><br><span class="line"><span class="comment">// make sure that all vertices start immediately</span></span><br><span class="line"><span class="comment">// 设置调度模式，streaming 模式下，调度模式是所有节点一起启动</span></span><br><span class="line">jobGraph.setScheduleMode(streamGraph.getScheduleMode());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 广度优先遍历 StreamGraph 并且为每个 SteamNode 生成一个唯一确定的 hash id</span></span><br><span class="line"><span class="comment">// Generate deterministic hashes for the nodes in order to identify them across</span></span><br><span class="line"><span class="comment">// submission iff they didn't change.</span></span><br><span class="line"><span class="comment">// 保证如果提交的拓扑没有改变，则每次生成的 hash id 都是一样的，这里只要保证 source 的顺序是确定的，就可以保证最后生产的 hash id 不变</span></span><br><span class="line"><span class="comment">// 它是利用 input 节点的 hash 值及该节点在 map 中位置（实际上是 map.size 算的）来计算确定的</span></span><br><span class="line">Map&lt;Integer, <span class="keyword">byte</span>[]&gt; hashes = defaultStreamGraphHasher.traverseStreamGraphAndGenerateHashes(streamGraph);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generate legacy version hashes for backwards compatibility</span></span><br><span class="line"><span class="comment">// 这个设置主要是为了防止 hash 机制变化时出现不兼容的情况</span></span><br><span class="line">List&lt;Map&lt;Integer, <span class="keyword">byte</span>[]&gt;&gt; legacyHashes = <span class="keyword">new</span> ArrayList&lt;&gt;(legacyStreamGraphHashers.size());</span><br><span class="line"><span class="keyword">for</span> (StreamGraphHasher hasher : legacyStreamGraphHashers) &#123;</span><br><span class="line">legacyHashes.add(hasher.traverseStreamGraphAndGenerateHashes(streamGraph));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Map&lt;Integer, List&lt;Tuple2&lt;<span class="keyword">byte</span>[], <span class="keyword">byte</span>[]&gt;&gt;&gt; chainedOperatorHashes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 最重要的函数，生成 JobVertex/JobEdge/IntermediateDataSet 等，并尽可能地将多个 StreamNode 节点 chain 在一起</span></span><br><span class="line">setChaining(hashes, legacyHashes, chainedOperatorHashes);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 将每个 JobVertex 的入边集合也序列化到该 JobVertex 的 StreamConfig 中 (出边集合已经在 setChaining 的时候写入了)</span></span><br><span class="line">setPhysicalEdges();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 根据 group name，为每个 JobVertex 指定所属的 SlotSharingGroup 以及设置 CoLocationGroup</span></span><br><span class="line">setSlotSharingAndCoLocation();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 其他设置</span></span><br><span class="line"><span class="comment">// 设置 ManagedMemory 因子</span></span><br><span class="line">setManagedMemoryFraction(</span><br><span class="line">Collections.unmodifiableMap(jobVertices),</span><br><span class="line">Collections.unmodifiableMap(vertexConfigs),</span><br><span class="line">Collections.unmodifiableMap(chainedConfigs),</span><br><span class="line">id -&gt; streamGraph.getStreamNode(id).getMinResources(),</span><br><span class="line">id -&gt; streamGraph.getStreamNode(id).getManagedMemoryWeight());</span><br><span class="line"></span><br><span class="line"><span class="comment">// checkpoint相关的配置</span></span><br><span class="line">configureCheckpointing();</span><br><span class="line"></span><br><span class="line"><span class="comment">// savepoint相关的配置</span></span><br><span class="line">jobGraph.setSavepointRestoreSettings(streamGraph.getSavepointRestoreSettings());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户的第三方依赖包就是在这里（cacheFile）传给 JobGraph</span></span><br><span class="line">JobGraphGenerator.addUserArtifactEntries(streamGraph.getUserArtifacts(), jobGraph);</span><br><span class="line"></span><br><span class="line"><span class="comment">// set the ExecutionConfig last when it has been finalized</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 将 StreamGraph 的 ExecutionConfig 序列化到 JobGraph 的配置中</span></span><br><span class="line">jobGraph.setExecutionConfig(streamGraph.getExecutionConfig());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalConfigurationException(<span class="string">"Could not serialize the ExecutionConfig."</span> +</span><br><span class="line"><span class="string">"This indicates that non-serializable types (like custom serializers) were registered"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> jobGraph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要围绕 Flink 源码中 &lt;code&gt;flink-streaming-java&lt;/code&gt; 模块。介绍下 StreamGraph 转成 JobGraph 的过程等。&lt;/p&gt;
    
    </summary>
    
      <category term="Flink" scheme="http://yoursite.com/categories/Flink/"/>
    
    
  </entry>
  
  <entry>
    <title>Flink源码剖析-flink-streaming-java_StreamGraph</title>
    <link href="http://yoursite.com/2020/04/22/Flink%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-flink-streaming-java_StreamGraph/"/>
    <id>http://yoursite.com/2020/04/22/Flink源码剖析-flink-streaming-java_StreamGraph/</id>
    <published>2020-04-21T16:06:00.000Z</published>
    <updated>2020-04-22T16:55:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要围绕 Flink 源码中 <code>flink-streaming-java</code> 模块。介绍如何使用 DataStream API 进行 Flink 流任务开发，<code>flink-streaming-java</code> 模块中的一些重要类，贯穿着介绍下从 DataStream<br>API 到 StreamGraph 的构建过程。</p><a id="more"></a><h2 id="DataStream-API使用一览"><a href="#DataStream-API使用一览" class="headerlink" title="DataStream API使用一览"></a>DataStream API使用一览</h2><p>使用 DataStream API 通常有以下步骤：</p><ol><li>如何创建 Environment(Local、Remote) 并设置属性</li></ol><ul><li>setParallelism(int)：StreamExecutionEnvironment</li><li>setMaxParallelism(int)：StreamExecutionEnvironment</li><li>setBufferTimeout(long)：StreamExecutionEnvironment</li><li>enableCheckpointing(long,CheckpointingMode)：StreamExecutionEnvironment</li><li>setStateBackend(StateBackend)：StreamExecutionEnvironment</li><li>setStreamTimeCharacteristic(TimeCharacteristic)：void</li></ul><ol start="2"><li>如何读取数据？添加 Source 数据源获得 DataStream</li></ol><ul><li>fromElements(OUT …): DataStreamSource<out>   …</out></li><li>readTextFile(String): DataStreamSource<string>  …</string></li><li>readFile(FileInputFormat<out>,String): DataStreamSource<out> …</out></out></li><li>socketTextStream(String ,int ,String ,long): DataStreamSource<string>  …</string></li><li>createInput(InputFormat&lt;OUT,?&gt;,TypeInformation<out>): DataStreamSource<out> …</out></out></li><li>addSource(SourceFunction<out>,TypeInformation<out>): DataStreamSource<out> …</out></out></out></li></ul><ol start="3"><li>如何操作转换数据？</li></ol><p><img src="DataStream_API%E6%93%8D%E4%BD%9C%E6%A6%82%E8%A7%88.png" alt></p><ul><li>Basic Transformations<br>map、filter、flatMap</li><li>KeyedStream Transformations<br>keyBy、aggregations、reduce</li><li>MultiStream Transformations<br>union、connect、coMap、coFlatMap、split、select</li></ul><p><img src="DataStream%E5%9F%BA%E6%9C%AC%E8%BD%AC%E6%8D%A2.png" alt></p><ul><li>Distribution Transformations<br>物理分组：</li></ul><table><thead><tr><th>关系</th><th>表示</th><th>图示</th></tr></thead><tbody><tr><td>global</td><td>全部发往第1个task</td><td><img src="%E7%89%A9%E7%90%86%E5%88%86%E7%BB%84_global.png" alt></td></tr><tr><td>broadcast</td><td>广播，复制上游的数据发送到所有下游节点</td><td><img src="%E7%89%A9%E7%90%86%E5%88%86%E7%BB%84_broadcast.png" alt></td></tr><tr><td>forward</td><td>上下游并发度一样时一对一发送</td><td><img src="%E7%89%A9%E7%90%86%E5%88%86%E7%BB%84_forward.png" alt></td></tr><tr><td>shuffle</td><td>随机均匀分配</td><td><img src="%E7%89%A9%E7%90%86%E5%88%86%E7%BB%84_shuffle.png" alt></td></tr><tr><td>reblance</td><td>Round-Robin（轮流分配）</td><td><img src="%E7%89%A9%E7%90%86%E5%88%86%E7%BB%84_reblance.png" alt></td></tr><tr><td>rescale</td><td>Local Round-Robin (本地轮流分配)，<br>只会看到本机的实例</td><td><img src="%E7%89%A9%E7%90%86%E5%88%86%E7%BB%84_rescale.png" alt></td></tr><tr><td>partitionCustom</td><td>自定义单播</td><td></td></tr></tbody></table><ol start="4"><li>如何输出数据？添加 Sink</li></ol><ul><li>writeAsText(String path): DataStreamSink<t> …</t></li><li>writeAsCsv(String path): DataStreamSink<t> …</t></li><li>addSink(SinkFunction<t> sinkFunction): DataStreamSink<t></t></t></li></ul><ol start="5"><li>如何提交执行？<br>DataStream 通过不同的算子不停地在 DataStream 上实现转换过滤等逻辑，最终将结果输出到 DataSink 中。<br>在 StreamExecutionEnvironment 内部使用一个 <code>List&lt;StreamTransformation&lt;?&gt;&gt; transformations</code> 来保留生成 DataStream 的所有转换。</li></ol><ul><li>execute()：JobExecutionResult</li></ul><p>我们看下基于 Flink DataStream API 的自带 WordCount 示例：实时统计单词数量，每来一个计算一次并输出一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCount</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// *************************************************************************</span></span><br><span class="line"><span class="comment">// PROGRAM</span></span><br><span class="line"><span class="comment">// *************************************************************************</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> ParameterTool params = ParameterTool.fromArgs(args);</span><br><span class="line"><span class="comment">// 1. 设置运行环境</span></span><br><span class="line"><span class="keyword">final</span> StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">env.getConfig().setGlobalJobParameters(params);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 配置数据源读取数据</span></span><br><span class="line">DataStream&lt;String&gt; text;</span><br><span class="line"><span class="keyword">if</span> (params.has(<span class="string">"input"</span>)) &#123;</span><br><span class="line"><span class="comment">// read the text file from given input path</span></span><br><span class="line">text = env.readTextFile(params.get(<span class="string">"input"</span>));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// get default test text data</span></span><br><span class="line">text = env.fromElements(<span class="keyword">new</span> String[] &#123;</span><br><span class="line"><span class="string">"miao,She is a programmer"</span>,</span><br><span class="line"><span class="string">"wu,He is a programmer"</span>,</span><br><span class="line"><span class="string">"zhao,She is a programmer"</span></span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 进行一系列转换</span></span><br><span class="line">DataStream&lt;Tuple2&lt;String, Integer&gt;&gt; counts =</span><br><span class="line"><span class="comment">// split up the lines in pairs (2-tuples) containing: (word,1)</span></span><br><span class="line">text.flatMap(<span class="keyword">new</span> Tokenizer())</span><br><span class="line"><span class="comment">// group by the tuple field "0" and sum up tuple field "1"</span></span><br><span class="line">.keyBy(<span class="number">0</span>).sum(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 配置数据汇写出数据</span></span><br><span class="line"><span class="keyword">if</span> (params.has(<span class="string">"output"</span>)) &#123;</span><br><span class="line">counts.writeAsText(params.get(<span class="string">"output"</span>));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"Printing result to stdout. Use --output to specify output path."</span>);</span><br><span class="line">counts.print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 提交执行</span></span><br><span class="line">env.execute(<span class="string">"Streaming WordCount"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// *************************************************************************</span></span><br><span class="line"><span class="comment">// USER FUNCTIONS</span></span><br><span class="line"><span class="comment">// *************************************************************************</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Tokenizer</span> <span class="keyword">implements</span> <span class="title">FlatMapFunction</span>&lt;<span class="title">String</span>, <span class="title">Tuple2</span>&lt;<span class="title">String</span>, <span class="title">Integer</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatMap</span><span class="params">(String value, Collector&lt;Tuple2&lt;String, Integer&gt;&gt; out)</span> </span>&#123;</span><br><span class="line"><span class="comment">// normalize and split the line</span></span><br><span class="line">String[] tokens = value.toLowerCase().split(<span class="string">"\\W+"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// emit the pairs</span></span><br><span class="line"><span class="keyword">for</span> (String token : tokens) &#123;</span><br><span class="line"><span class="keyword">if</span> (token.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">out.collect(<span class="keyword">new</span> Tuple2&lt;&gt;(token, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="源码剖析"><a href="#源码剖析" class="headerlink" title="源码剖析"></a>源码剖析</h2><h3 id="StreamExecutionEnvironment"><a href="#StreamExecutionEnvironment" class="headerlink" title="StreamExecutionEnvironment"></a>StreamExecutionEnvironment</h3><p>StreamExecutionEnvironment 是 Flink 流处理任务执行的上下文，是我们编写 Flink 程序的入口。根据执行环境的不同，选择不同的 StreamExecutionEnvironment 类，<br>有 LocalStreamEnvironment、RemoteStreamEnvironment 等。如下图：<br><img src="StreamExecutionEnvironment%E5%AD%90%E7%B1%BB.png" alt></p><p>StreamExecutionEnvironment 依赖 ExecutionConfig 类来设置并行度等，依赖 CheckpointConfig 设置 Checkpointing 等相关属性。<br><img src="StreamExecutionEnvironment%E7%B1%BB%E5%9B%BE.png" alt></p><p>这里再补充说明下 StreamExecutionEnvironment类中的重要属性和方法：<br><img src="StreamExecutionEnvironment%E7%B1%BB%E4%B8%AD%E7%9A%84%E9%87%8D%E8%A6%81%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95.png" alt></p><h3 id="Transformation"><a href="#Transformation" class="headerlink" title="Transformation"></a>Transformation</h3><p>Transformation 代表了从一个或多个 DataStream 生成新 DataStream 的操作。在 DataStream 上通过 map 等算子不断进行转换，就得到了由 Transformation<br>构成的图。当需要执行的时候，底层的这个图就会被转换成 StreamGraph 。</p><p>Transformation 有很多子类，如 SourceTransformation、OneInputTransformation、TwoInputTransformation、SideOutputTransformation 等，分别对应了 DataStream 上的不同转换操作。</p><p><img src="Transformation%E5%AD%90%E7%B1%BB.png" alt></p><p>每一个 Transformation 都有一个关联 id，这个 id 是全局递增的，还有 uid、slotSharingGroup、parallelism 等信息。</p><p><img src="Transformation%E7%B1%BB%E4%B8%AD%E7%9A%84%E9%87%8D%E8%A6%81%E5%B1%9E%E6%80%A7.png" alt></p><p>查看 Transformation 的其中两个子类 OneInputTransformation、TwoInputTransformation 的实现，都对应有输入 Transformation，也正是基于此才能还原出 DAG 的拓扑结构。</p><p>Transformation 在运行时并不对应着一个物理转换操作，有一些操作只是逻辑层面上的，比如 split/select/partitioning 等。<br>Transformations 组成的 graph ，也就是我们写代码时的图结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> Source              Source</span><br><span class="line">    +                   +</span><br><span class="line">    |                   |</span><br><span class="line">    v                   v</span><br><span class="line">Rebalance          HashPartition</span><br><span class="line">    +                   +</span><br><span class="line">    |                   |</span><br><span class="line">    |                   |</span><br><span class="line">    +------&gt;Union&lt;------+</span><br><span class="line">              +</span><br><span class="line">              |</span><br><span class="line">              v</span><br><span class="line">            Split</span><br><span class="line">              +</span><br><span class="line">              |</span><br><span class="line">              v</span><br><span class="line">            Select</span><br><span class="line">              +</span><br><span class="line">              v</span><br><span class="line">             Map</span><br><span class="line">              +</span><br><span class="line">              |</span><br><span class="line">              v</span><br><span class="line">            Sink</span><br></pre></td></tr></table></figure><p>但是，在运行时将生成如下操作图，split/select/partitioning 等转换操作会被编码到边中，这个边连接 sources 和 map 操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Source              Source</span><br><span class="line">   +                   +</span><br><span class="line">   |                   |</span><br><span class="line">   |                   |</span><br><span class="line">   +-------&gt;Map&lt;-------+</span><br><span class="line">             +</span><br><span class="line">             |</span><br><span class="line">             v</span><br><span class="line">            Sink</span><br></pre></td></tr></table></figure><h3 id="DataStream"><a href="#DataStream" class="headerlink" title="DataStream"></a>DataStream</h3><p>一个 DataStream 就代表了同一种类型元素构成的数据流。通过对 DataStream 应用 map/filter 等操作，就可以将一个 DataStream 转换成另一个 DataStream 。<br>这个转换的过程就是根据不同的操作生成不同的 Transformation ，并将其加入到 StreamExecutionEnvironment 的 transformations 列表中。</p><p>DataStream 的子类包括 DataStreamSource、KeyedStream、IterativeStream、SingleOutputStreamOperator。</p><p><img src="DataStream%E5%AD%90%E7%B1%BB.png" alt></p><p>除了 DataStream 及其子类以外，其它的表征数据流的类还有 ConnectedStreams、WindowedStream、AllWindowedStream，这些会在后续的文章中陆续介绍。</p><p>DataStream 类中的重要属性和方法：</p><p><img src="DataStream%E7%B1%BB%E4%B8%AD%E7%9A%84%E9%87%8D%E8%A6%81%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95.png" alt></p><p>下面我们看下 map 操作是如何被添加进来的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;R&gt; <span class="function">SingleOutputStreamOperator&lt;R&gt; <span class="title">map</span><span class="params">(MapFunction&lt;T, R&gt; mapper, TypeInformation&lt;R&gt; outputType)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 将 MapFunction 封装成 StreamMap 这个 StreamOperator</span></span><br><span class="line"><span class="keyword">return</span> transform(<span class="string">"Map"</span>, outputType, <span class="keyword">new</span> StreamMap&lt;&gt;(clean(mapper)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PublicEvolving</span></span><br><span class="line"><span class="keyword">public</span> &lt;R&gt; <span class="function">SingleOutputStreamOperator&lt;R&gt; <span class="title">transform</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">String operatorName,</span></span></span><br><span class="line"><span class="function"><span class="params">TypeInformation&lt;R&gt; outTypeInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">OneInputStreamOperator&lt;T, R&gt; operator)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> doTransform(operatorName, outTypeInfo, SimpleOperatorFactory.of(operator));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们看下其中一个比较重要的方法 doTransform ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;R&gt; <span class="function">SingleOutputStreamOperator&lt;R&gt; <span class="title">doTransform</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">String operatorName,</span></span></span><br><span class="line"><span class="function"><span class="params">TypeInformation&lt;R&gt; outTypeInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">StreamOperatorFactory&lt;R&gt; operatorFactory)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// read the output type of the input Transform to coax out errors about MissingTypeInfo</span></span><br><span class="line">transformation.getOutputType();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造 Transformation</span></span><br><span class="line">OneInputTransformation&lt;T, R&gt; resultTransform = <span class="keyword">new</span> OneInputTransformation&lt;&gt;(</span><br><span class="line"><span class="keyword">this</span>.transformation,</span><br><span class="line">operatorName,</span><br><span class="line">operatorFactory,</span><br><span class="line">outTypeInfo,</span><br><span class="line">environment.getParallelism());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 Transformation 封装进 SingleOutputStreamOperator 返回</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"rawtypes"</span>&#125;)</span><br><span class="line">SingleOutputStreamOperator&lt;R&gt; returnStream = <span class="keyword">new</span> SingleOutputStreamOperator(environment, resultTransform);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加到 StreamExecutionEnvironment 的 transformations 列表中</span></span><br><span class="line">getExecutionEnvironment().addOperator(resultTransform);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> returnStream;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="StreamOperator"><a href="#StreamOperator" class="headerlink" title="StreamOperator"></a>StreamOperator</h3><p>在操作 DataStream 的时候，比如 <code>DataStream.map(MapFunction&lt;T, R&gt; mapper)</code> 时，都会传入一个自定义的 Function 。那么这些信息是如何保存在 Transformation 中的呢？<br>这里就引入了一个新的接口 StreamOpertor ，DataStream 上的每一个 Transformation 都对应了一个 StreamOperator，StreamOperator 是运行时的具体实现，会决定 UDF 的调用方式。</p><p>StreamOperator 的类继承关系如下：</p><p><img src="StreamOperator%E5%AD%90%E7%B1%BB.png" alt></p><p>接口 StreamOpertor 定义了对一个具体的算子的生命周期的管理。StreamOperator 的两个子接口 OneInputStreamOperator 和 TwoInputStreamOperator 提供了数据流中具体元素的操作方法，而 AbstractUdfStreamOperator 抽象子类则提供了自定义处理函数对应的算子的基本实现：</p><p><img src="StreamOperator%E7%B1%BB%E4%B8%AD%E7%9A%84%E9%87%8D%E8%A6%81%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95.png" alt></p><p>下面我们还是拿 map 举例，map 操作对应的 StreamOperator 为 StreamMap ，继承了 AbstractUdfStreamOperator 类，实现了 OneInputStreamOperator 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Internal</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamMap</span>&lt;<span class="title">IN</span>, <span class="title">OUT</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">AbstractUdfStreamOperator</span>&lt;<span class="title">OUT</span>, <span class="title">MapFunction</span>&lt;<span class="title">IN</span>, <span class="title">OUT</span>&gt;&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">OneInputStreamOperator</span>&lt;<span class="title">IN</span>, <span class="title">OUT</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StreamMap</span><span class="params">(MapFunction&lt;IN, OUT&gt; mapper)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(mapper);</span><br><span class="line">chainingStrategy = ChainingStrategy.ALWAYS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processElement</span><span class="params">(StreamRecord&lt;IN&gt; element)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">output.collect(element.replace(userFunction.map(element.getValue())));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上，我们可以知道通过 DataStream -&gt; Function -&gt; StreamOperator -&gt; StreamTransformation 这种依赖关系，就可以完成 DataStream 的转换，并且可以保存数据流和应用在流上<br>的算子之间的关系。</p><h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h3><p><img src="Function%E5%AD%90%E7%B1%BB.png" alt></p><h3 id="StreamGraph"><a href="#StreamGraph" class="headerlink" title="StreamGraph"></a>StreamGraph</h3><p>StreamGraph 是在 Client 端构造的。<br>了解 StreamGraph 之前我们首先要知道 StreamGraphGenerator 这个类，它会基于 StreamExecutionEnvironment 的 transformations 列表来生成 StreamGraph。</p><p>首先看下 StreamGraphGenerator 的 generate() 方法，这个方法会由触发程序执行的方法 StreamExecutionEnvironment.execute() 调用到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StreamGraph <span class="title">generate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">streamGraph = <span class="keyword">new</span> StreamGraph(executionConfig, checkpointConfig, savepointRestoreSettings);</span><br><span class="line">streamGraph.setStateBackend(stateBackend);</span><br><span class="line">streamGraph.setChaining(chaining);</span><br><span class="line">streamGraph.setScheduleMode(scheduleMode);</span><br><span class="line">streamGraph.setUserArtifacts(userArtifacts);</span><br><span class="line">streamGraph.setTimeCharacteristic(timeCharacteristic);</span><br><span class="line">streamGraph.setJobName(jobName);</span><br><span class="line">streamGraph.setBlockingConnectionsBetweenChains(blockingConnectionsBetweenChains);</span><br><span class="line"></span><br><span class="line">alreadyTransformed = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 遍历 transformations 列表，递归调用 transform 方法。</span></span><br><span class="line"><span class="comment"> * 对于每一个 Transformation ，确保当前上游已经完成转换，转换成 StreamGraph 中的 StreamNode，并为上下游节点添加 StreamEdge</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">for</span> (Transformation&lt;?&gt; transformation: transformations) &#123;</span><br><span class="line">transform(transformation);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> StreamGraph builtStreamGraph = streamGraph;</span><br><span class="line"></span><br><span class="line">alreadyTransformed.clear();</span><br><span class="line">alreadyTransformed = <span class="keyword">null</span>;</span><br><span class="line">streamGraph = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> builtStreamGraph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在遍历 List<transformation> 生成 StreamGraph 时，会递归调用其 transform 方法。对于每一个 Transformation ，确保当前其上游已经完成转换。最终，部分 Transformation 节点被<br>转换为 StreamGraph 中的 StreamNode 节点，并会为上下游节点添加边 StreamEdge。下面看下 transform() 方法：</transformation></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Collection&lt;Integer&gt; <span class="title">transform</span><span class="params">(Transformation&lt;?&gt; transform)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (alreadyTransformed.containsKey(transform)) &#123;</span><br><span class="line"><span class="keyword">return</span> alreadyTransformed.get(transform);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于不同类型的 Transformation，分别调用对应的转换方法</span></span><br><span class="line"><span class="comment">// 只有 OneInputTransformation、TwoInputTransformation、SourceTransformation、SinkTransformation 会生成 StreamNode，</span></span><br><span class="line"><span class="comment">// 会生成 StreamNode.</span></span><br><span class="line"><span class="comment">// 像 Partitioning, split/select, union 这些是不包含物理转换操作的，会生成一个带有特定属性的虚拟节点，</span></span><br><span class="line"><span class="comment">// 当添加一条有虚拟节点指向下游节点的边时，会找到虚拟节点上游的物理节点，在两个物理节点之间添加边，并把虚拟转换操作的属性附着上去。</span></span><br><span class="line">Collection&lt;Integer&gt; transformedIds;</span><br><span class="line"><span class="keyword">if</span> (transform <span class="keyword">instanceof</span> OneInputTransformation&lt;?, ?&gt;) &#123;</span><br><span class="line">transformedIds = transformOneInputTransform((OneInputTransformation&lt;?, ?&gt;) transform);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (transform <span class="keyword">instanceof</span> TwoInputTransformation&lt;?, ?, ?&gt;) &#123;</span><br><span class="line">transformedIds = transformTwoInputTransform((TwoInputTransformation&lt;?, ?, ?&gt;) transform);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (transform <span class="keyword">instanceof</span> SourceTransformation&lt;?&gt;) &#123;</span><br><span class="line">transformedIds = transformSource((SourceTransformation&lt;?&gt;) transform);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (transform <span class="keyword">instanceof</span> SinkTransformation&lt;?&gt;) &#123;</span><br><span class="line">transformedIds = transformSink((SinkTransformation&lt;?&gt;) transform);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (transform <span class="keyword">instanceof</span> UnionTransformation&lt;?&gt;) &#123;</span><br><span class="line">transformedIds = transformUnion((UnionTransformation&lt;?&gt;) transform);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (transform <span class="keyword">instanceof</span> SplitTransformation&lt;?&gt;) &#123;</span><br><span class="line">transformedIds = transformSplit((SplitTransformation&lt;?&gt;) transform);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (transform <span class="keyword">instanceof</span> SelectTransformation&lt;?&gt;) &#123;</span><br><span class="line">transformedIds = transformSelect((SelectTransformation&lt;?&gt;) transform);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (transform <span class="keyword">instanceof</span> FeedbackTransformation&lt;?&gt;) &#123;</span><br><span class="line">transformedIds = transformFeedback((FeedbackTransformation&lt;?&gt;) transform);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (transform <span class="keyword">instanceof</span> CoFeedbackTransformation&lt;?&gt;) &#123;</span><br><span class="line">transformedIds = transformCoFeedback((CoFeedbackTransformation&lt;?&gt;) transform);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (transform <span class="keyword">instanceof</span> PartitionTransformation&lt;?&gt;) &#123;</span><br><span class="line">transformedIds = transformPartition((PartitionTransformation&lt;?&gt;) transform);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (transform <span class="keyword">instanceof</span> SideOutputTransformation&lt;?&gt;) &#123;</span><br><span class="line">transformedIds = transformSideOutput((SideOutputTransformation&lt;?&gt;) transform);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unknown transformation: "</span> + transform);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> transformedIds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于另外一部分 Transformation ，如 partitioning, split/select, union，并不包含真正的物理转换操作，是不会生成 StreamNode 的，而是生成一个带有特定属性的虚拟节点。<br>当添加一条有虚拟节点指向下游节点的边时，会找到虚拟节点上游的物理节点，在两个物理节点之间添加边，并把虚拟转换操作的属性附着上去。下面我们首先看下 transformOneInputTransform() 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;IN, OUT&gt; <span class="function">Collection&lt;Integer&gt; <span class="title">transformOneInputTransform</span><span class="params">(OneInputTransformation&lt;IN, OUT&gt; transform)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首先确保上游节点完成转换</span></span><br><span class="line">Collection&lt;Integer&gt; inputIds = transform(transform.getInput());</span><br><span class="line"></span><br><span class="line"><span class="comment">// the recursive call might have already transformed this</span></span><br><span class="line"><span class="comment">// 由于是递归调用的，可能已经完成了转换</span></span><br><span class="line"><span class="keyword">if</span> (alreadyTransformed.containsKey(transform)) &#123;</span><br><span class="line"><span class="keyword">return</span> alreadyTransformed.get(transform);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确定共享资源组，如果用户没有指定，默认是 default</span></span><br><span class="line">String slotSharingGroup = determineSlotSharingGroup(transform.getSlotSharingGroup(), inputIds);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向 StreamGraph 中添加 Operator，这一步会生成对应的 StreamNode</span></span><br><span class="line">streamGraph.addOperator(transform.getId(),</span><br><span class="line">slotSharingGroup,</span><br><span class="line">transform.getCoLocationGroupKey(),</span><br><span class="line">transform.getOperatorFactory(),</span><br><span class="line">transform.getInputType(),</span><br><span class="line">transform.getOutputType(),</span><br><span class="line">transform.getName());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 stateKey</span></span><br><span class="line"><span class="keyword">if</span> (transform.getStateKeySelector() != <span class="keyword">null</span>) &#123;</span><br><span class="line">TypeSerializer&lt;?&gt; keySerializer = transform.getStateKeyType().createSerializer(executionConfig);</span><br><span class="line">streamGraph.setOneInputStateKey(transform.getId(), transform.getStateKeySelector(), keySerializer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 parallelism</span></span><br><span class="line"><span class="keyword">int</span> parallelism = transform.getParallelism() != ExecutionConfig.PARALLELISM_DEFAULT ?</span><br><span class="line">transform.getParallelism() : executionConfig.getParallelism();</span><br><span class="line">streamGraph.setParallelism(transform.getId(), parallelism);</span><br><span class="line">streamGraph.setMaxParallelism(transform.getId(), transform.getMaxParallelism());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在每一个物理节点的转换上</span></span><br><span class="line"><span class="comment">// 依次连接到上游 input 节点，创建 StreamEdge，在输入节点和当前节点之间建立边的连接</span></span><br><span class="line"><span class="keyword">for</span> (Integer inputId: inputIds) &#123;</span><br><span class="line">streamGraph.addEdge(inputId, transform.getId(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Collections.singleton(transform.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着看下 StreamGraph 中对应的添加节点的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;IN, OUT&gt; <span class="function"><span class="keyword">void</span> <span class="title">addOperator</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">Integer vertexID,</span></span></span><br><span class="line"><span class="function"><span class="params">@Nullable String slotSharingGroup,</span></span></span><br><span class="line"><span class="function"><span class="params">@Nullable String coLocationGroup,</span></span></span><br><span class="line"><span class="function"><span class="params">StreamOperatorFactory&lt;OUT&gt; operatorFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">TypeInformation&lt;IN&gt; inTypeInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">TypeInformation&lt;OUT&gt; outTypeInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">String operatorName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (operatorFactory.isStreamSource()) &#123;</span><br><span class="line"><span class="comment">// 从传入的 StreamOperatorFactory 得知当前 operator 代表的是 source 流。SourceStreamTask</span></span><br><span class="line">addNode(vertexID, slotSharingGroup, coLocationGroup, SourceStreamTask.class, operatorFactory, operatorName);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 上游节点输入流，OneInputStreamTask</span></span><br><span class="line">addNode(vertexID, slotSharingGroup, coLocationGroup, OneInputStreamTask.class, operatorFactory, operatorName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> StreamNode <span class="title">addNode</span><span class="params">(Integer vertexID,</span></span></span><br><span class="line"><span class="function"><span class="params">@Nullable String slotSharingGroup,</span></span></span><br><span class="line"><span class="function"><span class="params">    @Nullable String coLocationGroup,</span></span></span><br><span class="line"><span class="function"><span class="params">// 表示该节点在 TM 中运行时的实际任务类型</span></span></span><br><span class="line"><span class="function"><span class="params">Class&lt;? extends AbstractInvokable&gt; vertexClass,</span></span></span><br><span class="line"><span class="function"><span class="params">StreamOperatorFactory&lt;?&gt; operatorFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">String operatorName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (streamNodes.containsKey(vertexID)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Duplicate vertexID "</span> + vertexID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造 StreamNode</span></span><br><span class="line">StreamNode vertex = <span class="keyword">new</span> StreamNode(</span><br><span class="line">vertexID,</span><br><span class="line">slotSharingGroup,</span><br><span class="line">coLocationGroup,</span><br><span class="line">operatorFactory,</span><br><span class="line">operatorName,</span><br><span class="line"><span class="keyword">new</span> ArrayList&lt;OutputSelector&lt;?&gt;&gt;(),</span><br><span class="line">vertexClass);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存在 streamNodes 这个 map 中</span></span><br><span class="line">streamNodes.put(vertexID, vertex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> vertex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们再看下 transformPartition() 非物理节点的转换方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">Collection&lt;Integer&gt; <span class="title">transformPartition</span><span class="params">(PartitionTransformation&lt;T&gt; partition)</span> </span>&#123;</span><br><span class="line">Transformation&lt;T&gt; input = partition.getInput();</span><br><span class="line">List&lt;Integer&gt; resultIds = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归遍历转换上游节点</span></span><br><span class="line">Collection&lt;Integer&gt; transformedIds = transform(input);</span><br><span class="line"><span class="keyword">for</span> (Integer transformedId: transformedIds) &#123;</span><br><span class="line"><span class="keyword">int</span> virtualId = Transformation.getNewNodeId();</span><br><span class="line"><span class="comment">// 添加虚拟的 Partition 节点</span></span><br><span class="line">streamGraph.addVirtualPartitionNode(</span><br><span class="line">transformedId, virtualId, partition.getPartitioner(), partition.getShuffleMode());</span><br><span class="line">resultIds.add(virtualId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> resultIds;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addVirtualPartitionNode</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">Integer originalId,</span></span></span><br><span class="line"><span class="function"><span class="params">Integer virtualId,</span></span></span><br><span class="line"><span class="function"><span class="params">StreamPartitioner&lt;?&gt; partitioner,</span></span></span><br><span class="line"><span class="function"><span class="params">ShuffleMode shuffleMode)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (virtualPartitionNodes.containsKey(virtualId)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already has virtual partition node with id "</span> + virtualId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一个虚拟节点到 virtualPartitionNodes 中，后续添加边的时候会连接到实际的物理节点</span></span><br><span class="line">virtualPartitionNodes.put(virtualId, <span class="keyword">new</span> Tuple3&lt;&gt;(originalId, partitioner, shuffleMode));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实际的物理节点执行添加边的操作时，会判断上游是不是虚拟节点，如果是则会一直递归调用，将虚拟节点的信息添加到边中，直到连接到一个物理转换节点为止：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addEdgeInternal</span><span class="params">(Integer upStreamVertexID,</span></span></span><br><span class="line"><span class="function"><span class="params"> Integer downStreamVertexID,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="keyword">int</span> typeNumber,</span></span></span><br><span class="line"><span class="function"><span class="params"> StreamPartitioner&lt;?&gt; partitioner,</span></span></span><br><span class="line"><span class="function"><span class="params"> List&lt;String&gt; outputNames,</span></span></span><br><span class="line"><span class="function"><span class="params"> OutputTag outputTag,</span></span></span><br><span class="line"><span class="function"><span class="params"> ShuffleMode shuffleMode)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先判断是不是虚拟节点上的边，如果是，则找到虚拟节点上游对应的物理节点</span></span><br><span class="line"><span class="comment">// 在两个物理节点之间添加边，并把对应的 outputTag 或 StreamPartitioner 添加到 StreamEdge 中</span></span><br><span class="line"><span class="keyword">if</span> (virtualSideOutputNodes.containsKey(upStreamVertexID)) &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (virtualSelectNodes.containsKey(upStreamVertexID)) &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (virtualPartitionNodes.containsKey(upStreamVertexID)) &#123;</span><br><span class="line"><span class="keyword">int</span> virtualId = upStreamVertexID;</span><br><span class="line">upStreamVertexID = virtualPartitionNodes.get(virtualId).f0;</span><br><span class="line"><span class="keyword">if</span> (partitioner == <span class="keyword">null</span>) &#123;</span><br><span class="line">partitioner = virtualPartitionNodes.get(virtualId).f1;</span><br><span class="line">&#125;</span><br><span class="line">shuffleMode = virtualPartitionNodes.get(virtualId).f2;</span><br><span class="line">addEdgeInternal(upStreamVertexID, downStreamVertexID, typeNumber, partitioner, outputNames, outputTag, shuffleMode);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个物理节点</span></span><br><span class="line">StreamNode upstreamNode = getStreamNode(upStreamVertexID);</span><br><span class="line">StreamNode downstreamNode = getStreamNode(downStreamVertexID);</span><br><span class="line"></span><br><span class="line"><span class="comment">// If no partitioner was specified and the parallelism of upstream and downstream</span></span><br><span class="line"><span class="comment">// operator matches use forward partitioning, use rebalance otherwise.</span></span><br><span class="line"><span class="keyword">if</span> (partitioner == <span class="keyword">null</span> &amp;&amp; upstreamNode.getParallelism() == downstreamNode.getParallelism()) &#123;</span><br><span class="line">partitioner = <span class="keyword">new</span> ForwardPartitioner&lt;Object&gt;();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (partitioner == <span class="keyword">null</span>) &#123;</span><br><span class="line">partitioner = <span class="keyword">new</span> RebalancePartitioner&lt;Object&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (partitioner <span class="keyword">instanceof</span> ForwardPartitioner) &#123;</span><br><span class="line"><span class="keyword">if</span> (upstreamNode.getParallelism() != downstreamNode.getParallelism()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Forward partitioning does not allow "</span> +</span><br><span class="line"><span class="string">"change of parallelism. Upstream operation: "</span> + upstreamNode + <span class="string">" parallelism: "</span> + upstreamNode.getParallelism() +</span><br><span class="line"><span class="string">", downstream operation: "</span> + downstreamNode + <span class="string">" parallelism: "</span> + downstreamNode.getParallelism() +</span><br><span class="line"><span class="string">" You must use another partitioning strategy, such as broadcast, rebalance, shuffle or global."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (shuffleMode == <span class="keyword">null</span>) &#123;</span><br><span class="line">shuffleMode = ShuffleMode.UNDEFINED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 StreamEdge，带着 outputTag 、StreamPartitioner 等属性</span></span><br><span class="line">StreamEdge edge = <span class="keyword">new</span> StreamEdge(upstreamNode, downstreamNode, typeNumber, outputNames, partitioner, outputTag, shuffleMode);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分别将 StreamEdge 添加到上游节点和下游节点</span></span><br><span class="line"><span class="comment">// 获取上游节点，添加 OutEdge</span></span><br><span class="line">getStreamNode(edge.getSourceId()).addOutEdge(edge);</span><br><span class="line">getStreamNode(edge.getTargetId()).addInEdge(edge);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StreamGraph 是 Flink 任务最接近用户逻辑的 DAG 表示，后面到具体执行时还会进行一系列转换。</p><h3 id="类之间的层级关系"><a href="#类之间的层级关系" class="headerlink" title="类之间的层级关系"></a>类之间的层级关系</h3><p><img src="DataStream_API%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%B1%82%E7%BA%A7%E5%85%B3%E7%B3%BB.png" alt></p><p>map 转换将用户自定义函数 MapFunction 包装到 StreamMap 这个 StreamOperator 中，再将 StreamMap 包装到 OneInputTransformation，最后该 transformation 会存到<br>StreamExecutionEnvironment 中。当调用 env.execute() 时，会遍历其中的 transformations 集合构造出 StreamGraph 。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要围绕 Flink 源码中 &lt;code&gt;flink-streaming-java&lt;/code&gt; 模块。介绍如何使用 DataStream API 进行 Flink 流任务开发，&lt;code&gt;flink-streaming-java&lt;/code&gt; 模块中的一些重要类，贯穿着介绍下从 DataStream&lt;br&gt;API 到 StreamGraph 的构建过程。&lt;/p&gt;
    
    </summary>
    
      <category term="Flink" scheme="http://yoursite.com/categories/Flink/"/>
    
    
  </entry>
  
  <entry>
    <title>UML</title>
    <link href="http://yoursite.com/2020/04/14/UML/"/>
    <id>http://yoursite.com/2020/04/14/UML/</id>
    <published>2020-04-14T08:58:11.000Z</published>
    <updated>2020-04-15T13:04:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍Java开发中的软技能之一，UML图。UML 即统一建模语言，它是一种开放的方法，用于说明、可视化、构建和编写一个正在开发的、面向对象的、软件密集系统的制品的开放方法。<br>UML 展现了一系列最佳工程实践，这些最佳实践在对大规模，复杂系统进行建模方面，特别是在软件架构层次已经被验证有效。<br>我们知道开发一个软件系统，不光只有程序员参与，另外还有分析师、设计师、测试人员等等，为了让不同人能够理解交流这个软件系统，就诞生了这么一套语言。<br>这套语言是由图表组成的，最常用的有：用例图、类图、时序图、状态图、活动图、组件图和部署图等。大致可以将这些图归类为结构图和行为图：</p><ul><li>结构图是静态图，如类图、对象图等</li><li>行为图是动态图，像序列图、协作图等</li></ul><a id="more"></a><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p>类图主要是用来显示系统中的类、接口以及它们之间的静态结构和关系的一种静态模型。<br>许多项目立项文档、需求分析文档中，都会有关 UML 类图的涉及。类图基本上是一个系统的静态视图的图形表示，代表应用的不同方面，集合类图就表示整个系统。<br>画类图需要关注以下几点：</p><ul><li>类图中的名称应该是有意义的描述，并且是面向系统的</li><li>画类图前应该先确定每个元素之间的关系</li><li>类图中每个类职责（属性和方法）应该清晰标明</li><li>对于每个类的属性应改精简，不必要的属性将使图表变得复杂</li></ul><h3 id="可见性符号"><a href="#可见性符号" class="headerlink" title="可见性符号"></a>可见性符号</h3><p><code>+</code> public<br><code>#</code> protected<br><code>-</code> private</p><h3 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h3><table><thead><tr><th>关系</th><th>表示</th><th>图示</th><th>解释</th><th>结构和语义</th></tr></thead><tbody><tr><td>泛化（Generalization）</td><td><img src="%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E8%A1%A8%E7%A4%BA.png" alt></td><td><img src="%E6%B3%9B%E5%8C%96%E5%85%B3%E7%B3%BB.png" alt></td><td>A继承B，B为非抽象类</td><td>继承结构</td></tr><tr><td>实现（Realization）</td><td><img src="%E5%AE%9E%E7%8E%B0%E5%85%B3%E7%B3%BB%E8%A1%A8%E7%A4%BA.png" alt></td><td><img src="%E5%AE%9E%E7%8E%B0%E5%85%B3%E7%B3%BB.png" alt></td><td>A实现B，B为抽象类或接口</td><td>继承结构</td></tr><tr><td>聚合（Aggregation）</td><td><img src="%E8%81%9A%E5%90%88%E5%85%B3%E7%B3%BB%E8%A1%A8%E7%A4%BA.png" alt></td><td><img src="%E8%81%9A%E5%90%88%E5%85%B3%E7%B3%BB.png" alt></td><td>A聚合到B上，B由A组成</td><td>表示整体由部分构成的语义。<br> (不是强依赖：整体不存在了，部分仍然存在)</td></tr><tr><td>组合（Composition）</td><td><img src="%E7%BB%84%E5%90%88%E5%85%B3%E7%B3%BB%E8%A1%A8%E7%A4%BA.png" alt></td><td><img src="%E7%BB%84%E5%90%88%E5%85%B3%E7%B3%BB.png" alt></td><td>A组成B，B由A组成</td><td>表示整体由部分构成的语义。<br> (强依赖：整体不存在了，部分也不存在了)</td></tr><tr><td>关联（Association）</td><td><img src="%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB%E8%A1%A8%E7%A4%BA.png" alt></td><td><img src="%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB.png" alt></td><td>A知道B，但是B不知道A</td><td>不同类的对象之间的结构关系。<br> 不强调方向，表示对象间相互知道。</td></tr><tr><td>依赖（Dependence）</td><td><img src="%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%E8%A1%A8%E7%A4%BA.png" alt></td><td><img src="%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB.png" alt></td><td>A依赖于B</td><td>描述一个对象在运行期间会用到另一个对象的关系。<br> 应该保持单向依赖，杜绝双向依赖。</td></tr></tbody></table><p>首先，我们给出一张具有整体关系的 UML 类图，后面再逐步分解说明。</p><p><img src="UML%E7%B1%BB%E5%9B%BE%E6%95%B4%E4%BD%93%E5%85%B3%E7%B3%BB%E7%A4%BA%E4%BE%8B.png" alt></p><h4 id="泛化（Generalization）"><a href="#泛化（Generalization）" class="headerlink" title="泛化（Generalization）"></a>泛化（Generalization）</h4><p>泛化即 Java 中的继承关系，是类与类或者接口与接口之间最常见的关系。</p><p><img src="%E6%B3%9B%E5%8C%96%E5%85%B3%E7%B3%BB%E7%A4%BA%E4%BE%8B.png" alt></p><p>两个子类 Fish 和 Cat 分别继承自 Animal。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">boolean</span> isPet;</span><br><span class="line"><span class="keyword">private</span> String state;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fish</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> String fishType;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">boolean</span> hasFeet;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playToy</span><span class="params">(Doll doll)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现（Realization）"><a href="#实现（Realization）" class="headerlink" title="实现（Realization）"></a>实现（Realization）</h4><p>实现即 Java 中类对抽象类或接口的实现关系，是类与接口之间最常见的关系。</p><p><img src="%E5%AE%9E%E7%8E%B0%E5%85%B3%E7%B3%BB%E7%A4%BA%E4%BE%8B.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ToyAction</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">toyMoved</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Doll</span> <span class="keyword">implements</span> <span class="title">ToyAction</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> Body body;</span><br><span class="line"><span class="keyword">public</span> Cloth cloth;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toyMoved</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关联（Association）"><a href="#关联（Association）" class="headerlink" title="关联（Association）"></a>关联（Association）</h4><p>关联关系是一种比较强的关系，他们的关系是比较持久的、稳定的，而且双方的关系一般是平等的，分单向关联、双向关联等。<br>表现在代码层面，就是类 B 作为类 A 的属性，也可能是类 A 引用了一个类型为 B 的全局变量。如 Person 类，他拥有一个宠物猫，他们之间是关联关系。</p><p><img src="%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB%E7%A4%BA%E4%BE%8B.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> Cat pet;</span><br><span class="line"><span class="keyword">public</span> Head head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(1) 单向关联<br>用带箭头的实线表示，箭头指向被引用或被包含的类。上面演示的就是一个单向关联关系。</p><p>(2) 双向关联<br>用不带箭头的实线来连接两个类，所谓的双向关联就是双方各自持有对方类型的成员变量。例如 Customer 类中维护一个 Product[] 数组，表示一个顾客购买了哪些商品；在 Product 类中维护一个 Customer 类型的成员变量表示这个产品被哪个顾客所购买。</p><p><img src="%E5%8F%8C%E5%90%91%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB%E7%A4%BA%E4%BE%8B.png" alt></p><p>(3) 自关联<br>系统中可能会存在一些类的属性对象类型为该类本身，例如二叉树中的 TreeNode 定义。</p><p><img src="%E8%87%AA%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB%E7%A4%BA%E4%BE%8B.png" alt></p><h4 id="依赖（Dependence）"><a href="#依赖（Dependence）" class="headerlink" title="依赖（Dependence）"></a>依赖（Dependence）</h4><p>就是一个类 A 使用到了另一个类 B ，这种使用关系是具有偶然性的、临时性的、非常弱的，但是类 B 的变化会影响到 A。<br>表现在代码层面，就是类 B 作为参数被类 A 在某个 method 方法中使用。如 Cat 类的 playToy 方法的参数就引用了 Doll 类，因此他们是依赖关系。</p><p><img src="%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%E7%A4%BA%E4%BE%8B.png" alt></p><h4 id="聚合（Aggregation）"><a href="#聚合（Aggregation）" class="headerlink" title="聚合（Aggregation）"></a>聚合（Aggregation）</h4><p>聚合关系强调的整体和部分、拥有的关系，即 has-a 的关系，其中部分可以脱离整体而存在，他们可以具有各自的生命周期。<br>如 Doll 类由 Body 和 Cloth 组成，即使失去了 Cloth，Doll 也可以正常存在。<br>表现在代码层面，和关联关系是一致的，只能从语义级别来区分。</p><p><img src="%E8%81%9A%E5%90%88%E5%85%B3%E7%B3%BB%E7%A4%BA%E4%BE%8B.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Body</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cloth</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="组合（Composition）"><a href="#组合（Composition）" class="headerlink" title="组合（Composition）"></a>组合（Composition）</h4><p>组合关系也是强调整体和部分的关系，不同的是部分不能脱离整体而存在，它体现的是一种 contains-a 的关系，这种关系比聚合更强，也成为强聚合。<br>整体的生命周期结束也就意味着部分的生命周期结束，如人和大脑。<br>表现在代码层面，和关联关系是一致的，只能从语义级别来区分。</p><p><img src="%E7%BB%84%E5%90%88%E5%85%B3%E7%B3%BB%E7%A4%BA%E4%BE%8B.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Head</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类关系强度：组合 &gt; 聚合 &gt; 关联 &gt; 依赖</p><p>下面我们在 idea 中构建这几个类，将这几个放到同一 package 下，看下 idea 自动生成的UML类图：<br><img src="idea%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E7%9A%84UML%E7%B1%BB%E5%9B%BE.png" alt></p><p>和我们给出整体关系 UML 类图基本一致，区别是聚合关系和组合关系都是用实心菱形表示的。</p><h2 id="对象图"><a href="#对象图" class="headerlink" title="对象图"></a>对象图</h2><p>是类图的一个具体实例。</p><h2 id="用例图"><a href="#用例图" class="headerlink" title="用例图"></a>用例图</h2><p>从用户的角度出发描述系统的功能、需求，展示系统外部的各类角色与系统内部的各种用例之间的关系。</p><h2 id="顺序图"><a href="#顺序图" class="headerlink" title="顺序图"></a>顺序图</h2><p>表示对象之间动态合作的关系。</p><h2 id="协作图"><a href="#协作图" class="headerlink" title="协作图"></a>协作图</h2><p>描述对象之间的协作关系。</p><h2 id="活动图"><a href="#活动图" class="headerlink" title="活动图"></a>活动图</h2><p>描述系统中各种活动的执行顺序。</p><h2 id="状态图"><a href="#状态图" class="headerlink" title="状态图"></a>状态图</h2><p>描述一类对象的所有可能的状态以及事件发生时状态的转移条件。</p><h2 id="部署图"><a href="#部署图" class="headerlink" title="部署图"></a>部署图</h2><p>定义系统中软硬件的物理体系结构。</p><h2 id="UML组件图"><a href="#UML组件图" class="headerlink" title="UML组件图"></a>UML组件图</h2><p>描述代码部件的物理结构以及各部件之间的依赖关系。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍Java开发中的软技能之一，UML图。UML 即统一建模语言，它是一种开放的方法，用于说明、可视化、构建和编写一个正在开发的、面向对象的、软件密集系统的制品的开放方法。&lt;br&gt;UML 展现了一系列最佳工程实践，这些最佳实践在对大规模，复杂系统进行建模方面，特别是在软件架构层次已经被验证有效。&lt;br&gt;我们知道开发一个软件系统，不光只有程序员参与，另外还有分析师、设计师、测试人员等等，为了让不同人能够理解交流这个软件系统，就诞生了这么一套语言。&lt;br&gt;这套语言是由图表组成的，最常用的有：用例图、类图、时序图、状态图、活动图、组件图和部署图等。大致可以将这些图归类为结构图和行为图：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;结构图是静态图，如类图、对象图等&lt;/li&gt;
&lt;li&gt;行为图是动态图，像序列图、协作图等&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Flink源码剖析-flink-annotations</title>
    <link href="http://yoursite.com/2020/04/13/Flink%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-flink-annotations/"/>
    <id>http://yoursite.com/2020/04/13/Flink源码剖析-flink-annotations/</id>
    <published>2020-04-13T04:05:32.000Z</published>
    <updated>2020-04-14T06:35:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文将先介绍下java注解的实现，再说明下Flink自定义的几个注解及其使用。</p><a id="more"></a><h2 id="java注解"><a href="#java注解" class="headerlink" title="java注解"></a>java注解</h2><p>注解在一定程度上是在把元数据与源代码文件结合在一起，而不是保存在外部文档中这一大的趋势下所催生的。注解可以提供用来完整的描述程序所需的信息，而这些信息是无法用Java来表达的。<br>因此，注解存储有关程序的额外信息，是可以由编译器来测试和验证的。注解还可以用来生成描述符文件，甚至是新的类定义，并且有助于减轻编写“样板”代码的负担。通过使用注解，我们可以将这些元数据保存在Java源代码中，并利用 annotation API 为自己的注解构造处理工具，同时注解的优点还包括：更加干净易读的代码以及编译器类型检查等。</p><p>注解的使用场景：</p><ul><li>提供信息给编译器：编译器可以利用注解来探测错误和警告信息</li><li>编译阶段时的处理：软件工具可以利用注解信息来生成代码，HTML文档或其他相应处理</li><li>运行时的处理：某些注解可以在程序运行时接受代码的提取</li></ul><h3 id="注解的分类"><a href="#注解的分类" class="headerlink" title="注解的分类"></a>注解的分类</h3><ol><li><p>按运行机制划分<br>源码注解：只在源码中存在，编译成 .class 文件就不存在了<br>编译时注解：在源码和 .class 文件中都存在，像前面的 @Override、@Deprecated、@SuppressWarnings 都属于编译时注解<br>运行时注解：在运行阶段还有作用，甚至会影响运行逻辑，像 @Autowired 就属于运行时注解，它会在程序运行时把你的成员变量自动的注入进来</p></li><li><p>按来源划分<br>来自 JDK 的注解<br>来自第三方的注解<br>自定义注解</p></li><li><p>元注解</p></li></ol><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>负责注解的创建，是注解的注解。</p><p>元注解的类图关系如下：<br><img src="Annotation%E5%85%83%E6%B3%A8%E8%A7%A3%E7%B1%BB%E5%9B%BE.png" alt></p><ol><li>@Target</li></ol><p>表示注解可以用在什么地方。ElementType可以是：</p><ul><li>TYPE：类，接口，枚举类上</li><li>FIELD：字段上，包括枚举实例</li><li>METHOD：方法上</li><li>PARAMETER：参数前</li><li>CONSTRUCTOR：构造函数上</li><li>LOCAL_VARIABLE：局部变量上</li><li>ANNOTATION_TYPE：注解类上</li><li>PACKAGE：包上</li><li>TYPE_PARAMETER：</li><li>TYPE_USE：<br>可以是某一个值或者以逗号分隔的形式指定多个值，如果想要将注解应用于所有的ElementType，也可以省去 @Target 元注解</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.ANNOTATION_TYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Target &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns an array of the kinds of elements an annotation type</span></span><br><span class="line"><span class="comment">     * can be applied to.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> an array of the kinds of elements an annotation type</span></span><br><span class="line"><span class="comment">     * can be applied to</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ElementType[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>@Retention</li></ol><p>表示需要在什么级别上保留该注解信息。RetentionPolicy可以是：</p><ul><li>SOURCE：注解将被编译器丢弃</li><li>CLASS：注解在class中可用，但会被VM丢弃</li><li>RUNTIME：VM在运行期也将保留注解，因此可以通过反射机制读取注解信息</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.ANNOTATION_TYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Retention &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the retention policy.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the retention policy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">RetentionPolicy <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>@Documented</li></ol><p>将此注解中的元素包含到javadoc中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.ANNOTATION_TYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Documented &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>@Inherited</li></ol><p>允许子类继承父类的注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.ANNOTATION_TYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Inherited &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>@Repeatable</li></ol><p>注解的值可以是多个，元素是一个容器注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.ANNOTATION_TYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Repeatable &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Indicates the &lt;em&gt;containing annotation type&lt;/em&gt; for the</span></span><br><span class="line"><span class="comment">     * repeatable annotation type.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the containing annotation type</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;? extends Annotation&gt; value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注解元素"><a href="#注解元素" class="headerlink" title="注解元素"></a>注解元素</h3><ol><li>基本语法</li></ol><p>使用 @interface 关键字定义注解，在注解上添加元注解。一般还要为注解添加元素，没有元素的注解称为标识注解。<br>注解只有成员变量，没有方法。注解的成员变量在注解的定义中以”无形参的方法”形式来声明，其方法名定义了该成员变量的名字，返回值定义了该成员变量的类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestAnnotation &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">()</span> <span class="keyword">default</span> -1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">msg</span><span class="params">()</span> <span class="keyword">default</span> "Hello"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>注解元素可用的类型</li></ol><ul><li>所有基本类型（int,float,boolean等）</li><li>String</li><li>Class</li><li>enum</li><li>Annotation</li><li>以上类型的数组</li></ul><p>如果使用了其他类型，那编译器就会报错。也不允许使用任何包装类型。注解也可以作为元素的类型，也就是说注解可以嵌套。</p><ol start="3"><li>注解元素的默认值限制</li></ol><p>编译器对注解元素的默认值有些过分挑剔。首先，注解元素不能有不确定的值。也就是说，注解元素要么具有默认值，要么在使用注解时设置元素值。</p><h3 id="内置注解"><a href="#内置注解" class="headerlink" title="内置注解"></a>内置注解</h3><p>所有的注解都继承自 java.lang.annotation.Annotation 接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Annotation</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends Annotation&gt; annotationType();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK 中有几种内置的注解：<br><img src="JDK%E5%86%85%E7%BD%AE%E6%B3%A8%E8%A7%A3.png" alt></p><ol><li>@Override</li></ol><p>表示当前的方法定义将覆盖超类中的方法。如果不小心拼写错误或者方法签名对不上被覆盖的方法，编译器就会发出错误提示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> javac Override.java</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> javap -c Override.class</span></span><br></pre></td></tr></table></figure><p>得到如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Compiled from &quot;Override.java&quot;</span><br><span class="line">public interface java.lang.Override extends java.lang.annotation.Annotation &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此可以看出，注解的本质就是一个继承了 Annotation 接口的接口，是一种典型的标记式注解。<br>一旦编译器检测到某个方法被修饰了 @Override 注解，编译器就会检查当前方法的方法签名是否真正重写了父类的某个方法，也就是比较父类中是否具有一个同样的方法签名，如果没有，自然不能编译通过。<br>编译器只能识别已经熟知的注解类，比如 JDK 内置的几个注解，而我们自定义的注解，编译器是不会知道这个注解的作用的，当然也不知道应该如何处理。</p><ol start="2"><li>@Deprecated</li></ol><p>依然是一种标记式注解，永久存在，可以修饰所有类型，被标记的类、方法、字段等已经不再被推荐使用了，可能下一个版本就会删除。当然，编译器并不会强制要求你做什么，只是会在对象上画出一道线，建议你使用某个替代者。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Deprecated &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>@SuppressWarnings</li></ol><p>抑制告警。它有一个 value 属性需要主动传值，传入需要被抑制的警告类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SuppressWarnings &#123;</span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下 Date 的构造函数是过时的，在 main() 方法上加上 @SuppressWarning(value = “deprecated”) 注解后，编译器就不会再对这种告警进行检查了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarning</span>(value = <span class="string">"deprecated"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Date date = <span class="keyword">new</span> Date(<span class="number">2018</span>, <span class="number">7</span>, <span class="number">11</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注解的提取"><a href="#注解的提取" class="headerlink" title="注解的提取"></a>注解的提取</h3><p>解析一个类或方法的注解往往有两种形式：</p><ul><li>一种是编译期直接扫描：编译器在对java代码编译字节码的过程中会检测到某个类或方法被一些注解修饰，它就会对这些注解进行某些处理。</li><li>一种是运行期反射。</li></ul><p>上文中有创建注解 TestAnnotation ，下面我们来写一个注解的提取类 Test：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TestAnnotation</span>(<span class="string">"defaultValue"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 注解通过反射获取，通过 Class 对象的 isAnnotationPresent() 方法判断它是否应用了某个注解</span></span><br><span class="line"><span class="keyword">boolean</span> hasAnnotation = Test.class.isAnnotationPresent(TestAnnotation.class);</span><br><span class="line"><span class="keyword">if</span> (hasAnnotation) &#123;</span><br><span class="line"><span class="comment">// 通过 getAnnotation() 方法来获取 Annotation 对象实例</span></span><br><span class="line">TestAnnotation testAnnotation = Test.class.getAnnotation(TestAnnotation.class);</span><br><span class="line">System.out.println(<span class="string">"id:"</span> + testAnnotation.id());</span><br><span class="line">System.out.println(<span class="string">"msg:"</span> + testAnnotation.msg());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们前面说过，注解本质上是继承了 Annotation 接口的接口，而当你通过反射，也就是 getAnnotation 方法去获取一个注解类实例的时候，其实 JDK 是通过动态代理生成了一个实现自定义注解（接口）的代理类。</p><p>运行 Test 类之前，先设置如下 VM 参数，让其生成代理类 class 文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* jdk动态代理 设置此系统属性,让JVM生成的Proxy类写入文件.保存路径为：com/sun/proxy(如果不存在请手工创建) */</span><br><span class="line">-Dsun.misc.ProxyGenerator.saveGeneratedFiles=true</span><br><span class="line">/* cglib动态代理 设置此系统属性,让JVM生成的Proxy类写入文件.保存路径为：com/sun/proxy(如果不存在请手工创建) */</span><br><span class="line">-Dcglib.debugLocation=com/sun/proxy</span><br></pre></td></tr></table></figure><p>将生成的代理类 class 文件反编译成可视化文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ./com/sun/proxy</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> javap -c \<span class="variable">$Proxy1</span>.class &gt; Proxy1</span></span><br></pre></td></tr></table></figure><p>查看代理类内容，代理类实现接口 TestAnnotation 并重写其所有方法，包括id()、msg()、value()以及接口 TestAnnotation 从 Annotation 接口继承而来的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public final class com.sun.proxy.$Proxy1 extends java.lang.reflect.Proxy implements org.apache.flink.annotation.TestAnnotation &#123;</span><br><span class="line">  public com.sun.proxy.$Proxy1(java.lang.reflect.InvocationHandler) throws ;</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: aload_1</span><br><span class="line">       2: invokespecial #8                  // Method java/lang/reflect/Proxy.&quot;&lt;init&gt;&quot;:(Ljava/lang/reflect/InvocationHandler;)V</span><br><span class="line">       5: return</span><br><span class="line"></span><br><span class="line">  public final boolean equals(java.lang.Object) throws ;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">  public final java.lang.String toString() throws ;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">  public final java.lang.String msg() throws ;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">  public final java.lang.Class annotationType() throws ;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">  public final int id() throws ;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">  public final int hashCode() throws ;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">  public final java.lang.String value() throws ;</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: getfield      #16                 // Field java/lang/reflect/Proxy.h:Ljava/lang/reflect/InvocationHandler;</span><br><span class="line">       4: aload_0</span><br><span class="line">       5: getstatic     #81                 // Field m3:Ljava/lang/reflect/Method;</span><br><span class="line">       8: aconst_null</span><br><span class="line">       9: invokeinterface #28,  4           // InterfaceMethod java/lang/reflect/InvocationHandler.invoke:(Ljava/lang/Object;Ljava/lang/reflect/Method;[Ljava/lang/Object;)Ljava/lang/Object;</span><br><span class="line">      14: checkcast     #52                 // class java/lang/String</span><br><span class="line">      17: areturn</span><br><span class="line">      18: athrow</span><br><span class="line">      19: astore_1</span><br><span class="line">      20: new           #42                 // class java/lang/reflect/UndeclaredThrowableException</span><br><span class="line">      23: dup</span><br><span class="line">      24: aload_1</span><br><span class="line">      25: invokespecial #45                 // Method java/lang/reflect/UndeclaredThrowableException.&quot;&lt;init&gt;&quot;:(Ljava/lang/Throwable;)V</span><br><span class="line">      28: athrow</span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           0    18    18   Class java/lang/Error</span><br><span class="line">           0    18    18   Class java/lang/RuntimeException</span><br><span class="line">           0    18    19   Class java/lang/Throwable</span><br><span class="line"></span><br><span class="line">  static &#123;&#125; throws ;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 InvocationHandler 指的就是 AnnotationInvocationHandler，它是 Java 中专门用于处理注解的 handler，下面就来让我们看看这个类的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnnotationInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6182022883658399397L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;? extends Annotation&gt; type;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注解元素属性的键值对</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; memberValues;</span><br><span class="line"></span><br><span class="line">    AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; type, Map&lt;String, Object&gt; memberValues) &#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">        <span class="keyword">this</span>.memberValues = memberValues;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理类代理了 TestAnnotation 接口中的所有方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> </span>&#123;</span><br><span class="line">        String member = method.getName();</span><br><span class="line">        Class&lt;?&gt;[] paramTypes = method.getParameterTypes();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Handle Object and Annotation methods</span></span><br><span class="line">        <span class="comment">// 如果当前调用的是 toString、equals、hashCode、annotationType。AnnotationInvocationHandler 实例中已经预定义好了这些方法的实现，直接调用即可。</span></span><br><span class="line">        <span class="keyword">if</span> (member.equals(<span class="string">"equals"</span>) &amp;&amp; paramTypes.length == <span class="number">1</span> &amp;&amp;</span><br><span class="line">            paramTypes[<span class="number">0</span>] == Object.class)</span><br><span class="line">            <span class="keyword">return</span> equalsImpl(args[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">assert</span> paramTypes.length == <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (member.equals(<span class="string">"toString"</span>))</span><br><span class="line">            <span class="keyword">return</span> toStringImpl();</span><br><span class="line">        <span class="keyword">if</span> (member.equals(<span class="string">"hashCode"</span>))</span><br><span class="line">            <span class="keyword">return</span> hashCodeImpl();</span><br><span class="line">        <span class="keyword">if</span> (member.equals(<span class="string">"annotationType"</span>))</span><br><span class="line">            <span class="keyword">return</span> type;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Handle annotation member accessors</span></span><br><span class="line">        <span class="comment">// 从我们注解的 map 中获取这个注解属性对应的值，即通过方法名返回注解属性值。</span></span><br><span class="line">        Object result = memberValues.get(member);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IncompleteAnnotationException(type, member);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result <span class="keyword">instanceof</span> ExceptionProxy)</span><br><span class="line">            <span class="keyword">throw</span> ((ExceptionProxy) result).generateException();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result.getClass().isArray() &amp;&amp; Array.getLength(result) != <span class="number">0</span>)</span><br><span class="line">            result = cloneArray(result);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><ol><li>可重复注解</li></ol><p>创建容器注解 Persons，容器注解本身也是一个注解，是用来存放其他注解的地方。它必须要有一个 value 属性，属性类型是一个被 @Repeatable 注解过的注解数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Persons &#123;</span><br><span class="line">Person[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 @Repeatable 注解了 Person，而 @Repeatable 后面括号中的类是一个容器注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repeatable</span>(Persons.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Person &#123;</span><br><span class="line"><span class="function">String <span class="title">role</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给 Superman 这个类贴上多个角色标签。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Person</span>(role=<span class="string">"Painter"</span>)</span><br><span class="line"><span class="meta">@Person</span>(role=<span class="string">"Musician"</span>)</span><br><span class="line"><span class="meta">@Person</span>(role=<span class="string">"Actor"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Superman</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>测试用例注解<br>实现一个注解，用来跟踪一个项目中的用例。如果一个方法实现了某个用例的需求，那么可以为此方法加上该注解。于是，项目经理通过计算已经实现的用例，就可以很好的掌控项目的进展。而且把实现方法和用例绑定，如果要更新或修改系统的业务逻辑，维护该项目的开发人员也可以很容易的在代码中找到对应的用例。</li></ol><p>定义 UseCase 注解，id 表示用例编号，description 设置了默认值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> UseCase &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用例id</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用例描述</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">String <span class="title">description</span><span class="params">()</span> <span class="keyword">default</span> "no description"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义需求实现类 PasswordUtils，每一个方法都对应一个需求用例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PasswordUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@UseCase</span>(id = <span class="number">47</span> , description = <span class="string">"Passwords must contain at least one numeric"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validatePassword</span><span class="params">(String password)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password.matches(<span class="string">"\\w*\\d\\w*"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@UseCase</span>(id = <span class="number">48</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">encryptPassword</span><span class="params">(String password)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StringBuilder(password).reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@UseCase</span>(id = <span class="number">49</span>,description = <span class="string">"New passwords can't equal previously used ones"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkForNewPassword</span><span class="params">(List&lt;String&gt; prevPasswords, String password)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !prevPasswords.contains(password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有用来读取注解的工具，那注解也不会比注释更有用。使用注解的过程中，很重要的一部分就是创建与使用注解处理器。<br>下面实现了一个非常简单的注解处理器 UseCaseTracker ，将用它来读取 PasswordUtils 类，并使用反射机制查找 @UseCase 注解。<br>我们提供了一组 id 值，然后它会列出在 PasswordUtils 中找到的用例，以及缺失的用例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseCaseTracker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">trackUseCases</span><span class="params">(List&lt;Integer&gt; useCases, Class&lt;?&gt; cl)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Method m : cl.getDeclaredMethods()) &#123;</span><br><span class="line"><span class="comment">// 返回指定类型的注解对象</span></span><br><span class="line">UseCase uc = m.getAnnotation(UseCase.class);</span><br><span class="line"><span class="keyword">if</span> (uc != <span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"Found Use Case: "</span> + uc.id() + <span class="string">" "</span> + uc.description());</span><br><span class="line">useCases.remove(<span class="keyword">new</span> Integer(uc.id()));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (Integer i : useCases) &#123;</span><br><span class="line">System.out.println(<span class="string">"Warning: Missing use case-"</span> + i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">List&lt;Integer&gt; useCases = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Collections.addAll(useCases, <span class="number">47</span>, <span class="number">48</span>, <span class="number">49</span>, <span class="number">50</span>);</span><br><span class="line">trackUseCases(useCases, PasswordUtils.class);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Found Use Case: 47 Passwords must contain at least one numeric</span><br><span class="line">Found Use Case: 48 no description</span><br><span class="line">Found Use Case: 49 New passwords can&apos;t equal previously used ones</span><br><span class="line">Warning: Missing use case-50</span><br></pre></td></tr></table></figure><ol start="3"><li>利用注解生成SQL语句</li></ol><p>定义表名注解，它告诉处理器，你需要把我这个类生成一个数据库 DDL 语句。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DBTable &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数据库表表名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义数据库表字段约束的注解：是否为主键，是否可以为空，唯一性约束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Constraints &#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">primaryKey</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">allowNull</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">unique</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义表字段类型为 String 的注解：字符串长度，字段名， 字段约束。这里的字段约束就用到了嵌套注解的语法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(value = ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SQLString &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">len</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">Constraints <span class="title">constraints</span><span class="params">()</span> <span class="keyword">default</span> @Constraints</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义表字段类型为 Integer 的注解：字段名，字段约束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SQLInteger &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">Constraints <span class="title">constraints</span><span class="params">()</span> <span class="keyword">default</span> @Constraints</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个 Member 类，应用了以上定义的注解。类的注解 @DBTable 给定了值 MEMBER，它将会用来作为表的名字。字段属性 firstName 和 lastName 都被注解为 @SQLString 类型，并分别设置了长度为 30 和 50。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DBTable</span>(name = <span class="string">"MEMBER"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SQLString</span>(len = <span class="number">30</span>)</span><br><span class="line">String firstName;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SQLString</span>(len = <span class="number">50</span>)</span><br><span class="line">String lastName;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SQLInteger</span></span><br><span class="line">Integer age;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SQLString</span>(len = <span class="number">30</span>, constraints = <span class="meta">@Constraints</span>(primaryKey = <span class="keyword">true</span>))</span><br><span class="line">String handle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> memberCount;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getFirstName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> firstName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getLastName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> lastName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getHandle</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> handle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> handle;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现处理器 TableCreator ，它将读取一个类文件，检查其上的数据库表注解，并生成用来创建数据库表的 SQL 语句。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TableCreator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">String className = Member.class.getName();</span><br><span class="line">Class&lt;?&gt; cl = Class.forName(className);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查类上是否带有 @DBTable 注解</span></span><br><span class="line">DBTable dbtable = cl.getAnnotation(DBTable.class);</span><br><span class="line"><span class="keyword">if</span> (dbtable == <span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"No DbTable annotations in class "</span> + className);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提取 @DBTable 注解的 name</span></span><br><span class="line">String tableName = dbtable.name();</span><br><span class="line"><span class="comment">// If the name is empty , use the Class name:</span></span><br><span class="line"><span class="keyword">if</span> (tableName.length() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">tableName = cl.getName().toUpperCase();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; columnDefs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">// 遍历 Member 类的所有字段</span></span><br><span class="line"><span class="keyword">for</span> (Field field : cl.getDeclaredFields()) &#123;</span><br><span class="line">String columnName;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取字段属性上的所有注解</span></span><br><span class="line">Annotation[] annotations = field.getDeclaredAnnotations();</span><br><span class="line"><span class="keyword">if</span> (annotations.length &lt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>; <span class="comment">// Not a db table column</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (annotations[<span class="number">0</span>] <span class="keyword">instanceof</span> SQLInteger) &#123;</span><br><span class="line"><span class="comment">// 处理 @SQLInteger 注解的属性字段</span></span><br><span class="line">SQLInteger sInt = (SQLInteger) annotations[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// Use field name if name not specified</span></span><br><span class="line"><span class="keyword">if</span> (sInt.name().length() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">columnName = field.getName().toUpperCase();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">columnName = sInt.name();</span><br><span class="line">&#125;</span><br><span class="line">columnDefs.add(columnName + <span class="string">" INT"</span> + getConstraints(sInt.constraints()));</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotations[<span class="number">0</span>] <span class="keyword">instanceof</span> SQLString) &#123;</span><br><span class="line"><span class="comment">// 处理 @SQLString 注解的属性字段</span></span><br><span class="line">SQLString sString = (SQLString) annotations[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// Use field name if name not specified.</span></span><br><span class="line"><span class="keyword">if</span> (sString.name().length() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">columnName = field.getName().toUpperCase();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">columnName = sString.name();</span><br><span class="line">&#125;</span><br><span class="line">columnDefs.add(columnName + <span class="string">" VARCHAR("</span> + sString.len() + <span class="string">")"</span> + getConstraints(sString.constraints()));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StringBuilder createCommand = <span class="keyword">new</span> StringBuilder(<span class="string">"CREATE TABLE "</span> + tableName + <span class="string">"("</span>);</span><br><span class="line"><span class="keyword">for</span> (String columnDef : columnDefs) &#123;</span><br><span class="line">createCommand.append(<span class="string">"\n    "</span> + columnDef + <span class="string">","</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Remove trailing comma</span></span><br><span class="line">String tableCreate = createCommand.substring(<span class="number">0</span>, (createCommand.length() - <span class="number">1</span>)) + <span class="string">");"</span>;</span><br><span class="line">System.out.println(<span class="string">"Table.Creation SQL for "</span> + className + <span class="string">" is :\n "</span> + tableCreate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getConstraints</span><span class="params">(Constraints con)</span> </span>&#123;</span><br><span class="line">String constraints = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">if</span> (!con.allowNull()) &#123;</span><br><span class="line">constraints += <span class="string">" NOT NULL"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (con.primaryKey()) &#123;</span><br><span class="line">constraints += <span class="string">" PRIMARY KEY"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (con.unique()) &#123;</span><br><span class="line">constraints += <span class="string">" UNIQUE"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> constraints;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Table.Creation SQL for org.apache.flink.annotation.dbtable.Member is :</span><br><span class="line"> CREATE TABLE MEMBER(</span><br><span class="line">    FIRSTNAME VARCHAR(30),</span><br><span class="line">    LASTNAME VARCHAR(50),</span><br><span class="line">    AGE INT,</span><br><span class="line">    HANDLE VARCHAR(30) PRIMARY KEY);</span><br></pre></td></tr></table></figure><h2 id="flink中的注解"><a href="#flink中的注解" class="headerlink" title="flink中的注解"></a>flink中的注解</h2><p><img src="flink%E4%B8%AD%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3.png" alt></p><h3 id="docs相关注解"><a href="#docs相关注解" class="headerlink" title="docs相关注解"></a>docs相关注解</h3><ol><li>@ConfigGroup</li></ol><p>指定一组配置选项，组的名称将用作生成 HTML 文件名，keyPrefix 用于匹配配置项名称前缀。<br>如 @ConfigGroup(name = “firstGroup”, keyPrefix = “first”)，生成的 HTML 文件名为 firstGroup ，其中的配置项名称都是以 first 开头的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;&#125;)</span><br><span class="line"><span class="meta">@Internal</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ConfigGroup &#123;</span><br><span class="line"><span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">String <span class="title">keyPrefix</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>@ConfigGroups</li></ol><p>允许一个配置类中的配置项可以按照配置项名称前缀分成不同的组，生成多个 HTML 文件。<br>如：<br>@ConfigGroups(groups = {<br>        @ConfigGroup(name = “firstGroup”, keyPrefix = “first”),<br>        @ConfigGroup(name = “secondGroup”, keyPrefix = “second”)})<br>可以从配置类生成 3 个 HTML 文件，分别为 firstGroup、secondGroup、default，具体可以接着往下看，下面会有示例说明。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Internal</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ConfigGroups &#123;</span><br><span class="line">ConfigGroup[] groups() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面通过一个示例来说明这两个注解的用途。<br>查看测试类 ConfigOptionsDocGeneratorTest 中应用到 @ConfigGroups 和 @ConfigGroup 的单测 <code>testCreatingMultipleGroups</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCreatingMultipleGroups</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> List&lt;Tuple2&lt;ConfigGroup, String&gt;&gt; tables = ConfigOptionsDocGenerator.generateTablesForClass(</span><br><span class="line">TestConfigMultipleSubGroup.class);</span><br><span class="line"></span><br><span class="line">assertEquals(tables.size(), <span class="number">3</span>);</span><br><span class="line"><span class="keyword">final</span> HashMap&lt;String, String&gt; tablesConverted = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (Tuple2&lt;ConfigGroup, String&gt; table : tables) &#123;</span><br><span class="line">tablesConverted.put(table.f0 != <span class="keyword">null</span> ? table.f0.name() : <span class="string">"default"</span>, table.f1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TestConfigMultipleSubGroup</code> 类 mock 了一个配置项类：<br>@ConfigGroup(name = “firstGroup”, keyPrefix = “first”) 将 key 以 first 开头的 ConfigOption 归为 firstGroup，<br>@ConfigGroup(name = “secondGroup”, keyPrefix = “second”) 将 key 以 second 开头的 ConfigOption 归为 secondGroup。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigGroups</span>(groups = &#123;</span><br><span class="line"><span class="meta">@ConfigGroup</span>(name = <span class="string">"firstGroup"</span>, keyPrefix = <span class="string">"first"</span>),</span><br><span class="line"><span class="meta">@ConfigGroup</span>(name = <span class="string">"secondGroup"</span>, keyPrefix = <span class="string">"second"</span>)&#125;)</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TestConfigMultipleSubGroup</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ConfigOption&lt;Integer&gt; firstOption = ConfigOptions</span><br><span class="line">.key(<span class="string">"first.option.a"</span>)</span><br><span class="line">.defaultValue(<span class="number">2</span>)</span><br><span class="line">.withDescription(<span class="string">"This is example description for the first option."</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ConfigOption&lt;String&gt; secondOption = ConfigOptions</span><br><span class="line">.key(<span class="string">"second.option.a"</span>)</span><br><span class="line">.noDefaultValue()</span><br><span class="line">.withDescription(<span class="string">"This is long example description for the second option."</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ConfigOption&lt;Integer&gt; thirdOption = ConfigOptions</span><br><span class="line">.key(<span class="string">"third.option.a"</span>)</span><br><span class="line">.defaultValue(<span class="number">2</span>)</span><br><span class="line">.withDescription(<span class="string">"This is example description for the third option."</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ConfigOption&lt;String&gt; fourthOption = ConfigOptions</span><br><span class="line">.key(<span class="string">"fourth.option.a"</span>)</span><br><span class="line">.noDefaultValue()</span><br><span class="line">.withDescription(<span class="string">"This is long example description for the fourth option."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再看下 <code>ConfigOptionsDocGenerator.generateTablesForClass(Class&lt;?&gt; optionsClass)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@VisibleForTesting</span></span><br><span class="line"><span class="keyword">static</span> List&lt;Tuple2&lt;ConfigGroup, String&gt;&gt; generateTablesForClass(Class&lt;?&gt; optionsClass) &#123;</span><br><span class="line"><span class="comment">// 获取 optionsClass 类上定义的 @ConfigGroups</span></span><br><span class="line">ConfigGroups configGroups = optionsClass.getAnnotation(ConfigGroups.class);</span><br><span class="line"><span class="comment">// 抽取 optionsClass 中的所有 ConfigOption 配置项</span></span><br><span class="line">List&lt;OptionWithMetaInfo&gt; allOptions = extractConfigOptions(optionsClass);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历 @ConfigGroups 注解中的 ConfigGroup[] groups()</span></span><br><span class="line">List&lt;Tuple2&lt;ConfigGroup, String&gt;&gt; tables;</span><br><span class="line"><span class="keyword">if</span> (configGroups != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 解析 optionsClass 上的 ConfigGroup 注解，即是有分组的。另外一个是默认的 ConfigGroup</span></span><br><span class="line">tables = <span class="keyword">new</span> ArrayList&lt;&gt;(configGroups.groups().length + <span class="number">1</span>);</span><br><span class="line">Tree tree = <span class="keyword">new</span> Tree(configGroups.groups(), allOptions);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (ConfigGroup group : configGroups.groups()) &#123;</span><br><span class="line">List&lt;OptionWithMetaInfo&gt; configOptions = tree.findConfigOptions(group);</span><br><span class="line"><span class="comment">// 按照 ConfigOption 的 key 进行排序</span></span><br><span class="line"> sortOptions(configOptions);</span><br><span class="line">tables.add(Tuple2.of(group, toHtmlTable(configOptions)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有 @ConfigGroup 前缀都匹配不上的其他 ConfigOption 归为 default 组</span></span><br><span class="line">List&lt;OptionWithMetaInfo&gt; configOptions = tree.getDefaultOptions();</span><br><span class="line">sortOptions(configOptions);</span><br><span class="line">tables.add(Tuple2.of(<span class="keyword">null</span>, toHtmlTable(configOptions)));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">sortOptions(allOptions);</span><br><span class="line">tables = Collections.singletonList(Tuple2.of(<span class="keyword">null</span>, toHtmlTable(allOptions)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> tables;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行单测 <code>testCreatingMultipleGroups</code> 的输出结果如下：<br>firstGroup 配置项组里的配置项名称都是以 first 为前缀的。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">class</span>=<span class="string">"table table-bordered"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">"text-left"</span> <span class="attr">style</span>=<span class="string">"width: 20%"</span>&gt;</span>Key<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">"text-left"</span> <span class="attr">style</span>=<span class="string">"width: 15%"</span>&gt;</span>Default<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">"text-left"</span> <span class="attr">style</span>=<span class="string">"width: 10%"</span>&gt;</span>Type<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">"text-left"</span> <span class="attr">style</span>=<span class="string">"width: 55%"</span>&gt;</span>Description<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">h5</span>&gt;</span>first.option.a<span class="tag">&lt;/<span class="name">h5</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">style</span>=<span class="string">"word-wrap: break-word;"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>Integer<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>This is example description for the first option.<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>secondGroup 配置项组里的配置项名称都是以 second 为前缀的。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">class</span>=<span class="string">"table table-bordered"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">"text-left"</span> <span class="attr">style</span>=<span class="string">"width: 20%"</span>&gt;</span>Key<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">"text-left"</span> <span class="attr">style</span>=<span class="string">"width: 15%"</span>&gt;</span>Default<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">"text-left"</span> <span class="attr">style</span>=<span class="string">"width: 10%"</span>&gt;</span>Type<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">"text-left"</span> <span class="attr">style</span>=<span class="string">"width: 55%"</span>&gt;</span>Description<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">h5</span>&gt;</span>second.option.a<span class="tag">&lt;/<span class="name">h5</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">style</span>=<span class="string">"word-wrap: break-word;"</span>&gt;</span>(none)<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>String<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>This is long example description for the second option.<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>TestConfigMultipleSubGroup 中的其他配置项都是没有分组的，默认都放到 default 组中。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">class</span>=<span class="string">"table table-bordered"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">"text-left"</span> <span class="attr">style</span>=<span class="string">"width: 20%"</span>&gt;</span>Key<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">"text-left"</span> <span class="attr">style</span>=<span class="string">"width: 15%"</span>&gt;</span>Default<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">"text-left"</span> <span class="attr">style</span>=<span class="string">"width: 10%"</span>&gt;</span>Type<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">"text-left"</span> <span class="attr">style</span>=<span class="string">"width: 55%"</span>&gt;</span>Description<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">h5</span>&gt;</span>fourth.option.a<span class="tag">&lt;/<span class="name">h5</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">style</span>=<span class="string">"word-wrap: break-word;"</span>&gt;</span>(none)<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>String<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>This is long example description for the fourth option.<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">h5</span>&gt;</span>third.option.a<span class="tag">&lt;/<span class="name">h5</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">style</span>=<span class="string">"word-wrap: break-word;"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>Integer<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>This is example description for the third option.<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Documentation 类中定义了修改文档生成器行为的注解结合，包括 @OverrideDefault、@CommonOption、@TableOption、@ExcludeFromDocumentation。下面依次介绍。</p><ol start="3"><li>@Documentation.OverrideDefault</li></ol><p>作用在 ConfigOption 上的注解，覆盖其默认值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Internal</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> OverrideDefault &#123;</span><br><span class="line"><span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面通过一个示例来说明这个注解的用途。<br>查看测试类 ConfigOptionsDocGeneratorTest 中应用到 @Documentation.OverrideDefault 的单测 <code>testOverrideDefault</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testOverrideDefault</span><span class="params">()</span> </span>&#123;</span><br><span class="line">String htmlTable = ConfigOptionsDocGenerator.generateTablesForClass(TestConfigGroupWithOverriddenDefault.class).get(<span class="number">0</span>).f1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TestConfigGroupWithOverriddenDefault</code> 类 mock 了一个配置项类，每个配置项都使用了 @Documentation.OverrideDefault 注解覆盖配置项的默认值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TestConfigGroupWithOverriddenDefault</span> </span>&#123;</span><br><span class="line"><span class="meta">@Documentation</span>.OverrideDefault(<span class="string">"default_1"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ConfigOption&lt;Integer&gt; firstOption = ConfigOptions</span><br><span class="line">.key(<span class="string">"first.option.a"</span>)</span><br><span class="line">.defaultValue(<span class="number">2</span>)</span><br><span class="line">.withDescription(<span class="string">"This is example description for the first option."</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">@Documentation</span>.OverrideDefault(<span class="string">"default_2"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ConfigOption&lt;String&gt; secondOption = ConfigOptions</span><br><span class="line">.key(<span class="string">"second.option.a"</span>)</span><br><span class="line">.noDefaultValue()</span><br><span class="line">.withDescription(<span class="string">"This is long example description for the second option."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行单测 <code>testOverrideDefault</code> 的输出结果如下：<br>将 firstOption 的默认值覆盖成了 default_1，secondOption 原先没有默认值，被设置成了 default_2。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">class</span>=<span class="string">"table table-bordered"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">"text-left"</span> <span class="attr">style</span>=<span class="string">"width: 20%"</span>&gt;</span>Key<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">"text-left"</span> <span class="attr">style</span>=<span class="string">"width: 15%"</span>&gt;</span>Default<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">"text-left"</span> <span class="attr">style</span>=<span class="string">"width: 10%"</span>&gt;</span>Type<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">"text-left"</span> <span class="attr">style</span>=<span class="string">"width: 55%"</span>&gt;</span>Description<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">h5</span>&gt;</span>first.option.a<span class="tag">&lt;/<span class="name">h5</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">style</span>=<span class="string">"word-wrap: break-word;"</span>&gt;</span>default_1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>Integer<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>This is example description for the first option.<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">h5</span>&gt;</span>second.option.a<span class="tag">&lt;/<span class="name">h5</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">style</span>=<span class="string">"word-wrap: break-word;"</span>&gt;</span>default_2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>String<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>This is long example description for the second option.<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>@Documentation.CommonOption</li></ol><p>作用在 ConfigOption 上的注解，使其包含在 “Common Options” 片段中，<br>按 position 值排序，position 值小的配置项排在前面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Internal</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CommonOption &#123;</span><br><span class="line"><span class="keyword">int</span> POSITION_MEMORY = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> POSITION_PARALLELISM_SLOTS = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> POSITION_FAULT_TOLERANCE = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">int</span> POSITION_HIGH_AVAILABILITY = <span class="number">40</span>;</span><br><span class="line"><span class="keyword">int</span> POSITION_SECURITY = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">position</span><span class="params">()</span> <span class="keyword">default</span> Integer.MAX_VALUE</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面通过一个示例来说明这个注解的用途。<br>查看测试类 ConfigOptionsDocGeneratorTest 中应用到 @Documentation.CommonOption 的单测 <code>testCommonOptions</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCommonOptions</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line"><span class="keyword">final</span> String projectRootDir = System.getProperty(<span class="string">"rootDir"</span>);</span><br><span class="line"><span class="keyword">final</span> String outputDirectory = TMP.newFolder().getAbsolutePath();</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> OptionsClassLocation[] locations = <span class="keyword">new</span> OptionsClassLocation[] &#123;</span><br><span class="line"><span class="keyword">new</span> OptionsClassLocation(<span class="string">"flink-docs"</span>, TestCommonOptions.class.getPackage().getName())</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ConfigOptionsDocGenerator.generateCommonSection(projectRootDir, outputDirectory, locations, <span class="string">"src/test/java"</span>);</span><br><span class="line">Formatter formatter = <span class="keyword">new</span> HtmlFormatter();</span><br><span class="line">String output = FileUtils.readFile(Paths.get(outputDirectory, ConfigOptionsDocGenerator.COMMON_SECTION_FILE_NAME).toFile(), StandardCharsets.UTF_8.name());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TestCommonOptions</code> 类 mock 了一个配置项类：<br>COMMON_OPTION 使用了 @Documentation.CommonOption 注解，position 使用默认值为 Integer.MAX_VALUE，<br>COMMON_POSITIONED_OPTION 也是用了 @Documentation.CommonOption 注解，position 值指定为2，这个配置项肯定排在 COMMON_OPTION 前面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCommonOptions</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Documentation</span>.CommonOption</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ConfigOption&lt;Integer&gt; COMMON_OPTION = ConfigOptions</span><br><span class="line">.key(<span class="string">"first.option.a"</span>)</span><br><span class="line">.defaultValue(<span class="number">2</span>)</span><br><span class="line">.withDescription(<span class="string">"This is the description for the common option."</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ConfigOption&lt;String&gt; GENERIC_OPTION = ConfigOptions</span><br><span class="line">.key(<span class="string">"second.option.a"</span>)</span><br><span class="line">.noDefaultValue()</span><br><span class="line">.withDescription(<span class="string">"This is the description for the generic option."</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">@Documentation</span>.CommonOption(position = <span class="number">2</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ConfigOption&lt;Integer&gt; COMMON_POSITIONED_OPTION = ConfigOptions</span><br><span class="line">.key(<span class="string">"third.option.a"</span>)</span><br><span class="line">.defaultValue(<span class="number">3</span>)</span><br><span class="line">.withDescription(<span class="string">"This is the description for the positioned common option."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行单测 <code>testCommonOptions</code> 的输出结果如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">class</span>=<span class="string">"table table-bordered"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">"text-left"</span> <span class="attr">style</span>=<span class="string">"width: 20%"</span>&gt;</span>Key<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">"text-left"</span> <span class="attr">style</span>=<span class="string">"width: 15%"</span>&gt;</span>Default<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">"text-left"</span> <span class="attr">style</span>=<span class="string">"width: 10%"</span>&gt;</span>Type<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">"text-left"</span> <span class="attr">style</span>=<span class="string">"width: 55%"</span>&gt;</span>Description<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">h5</span>&gt;</span>third.option.a<span class="tag">&lt;/<span class="name">h5</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">style</span>=<span class="string">"word-wrap: break-word;"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>Integer<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>This is the description for the positioned common option.<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">h5</span>&gt;</span>first.option.a<span class="tag">&lt;/<span class="name">h5</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">style</span>=<span class="string">"word-wrap: break-word;"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>Integer<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>This is the description for the common option.<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="5"><li>@Documentation.TableOption</li></ol><p>作用于 table 配置项上，用于添加元数据标签，配置执行模式（批处理、流式处理、两者兼有）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Internal</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TableOption &#123;</span><br><span class="line"><span class="function">ExecMode <span class="title">execMode</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看下 <code>ConfigOptionsDocGenerator</code> 类中的 toHtmlString 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">toHtmlString</span><span class="params">(<span class="keyword">final</span> OptionWithMetaInfo optionWithMetaInfo)</span> </span>&#123;</span><br><span class="line">ConfigOption&lt;?&gt; option = optionWithMetaInfo.option;</span><br><span class="line">String defaultValue = stringifyDefault(optionWithMetaInfo);</span><br><span class="line">String type = typeToHtml(optionWithMetaInfo);</span><br><span class="line">Documentation.TableOption tableOption = optionWithMetaInfo.field.getAnnotation(Documentation.TableOption.class);</span><br><span class="line">StringBuilder execModeStringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">if</span> (tableOption != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 如果 ConfigOption 上有 @Documentation.TableOption 注解，则读取它的 execMode 字段，拼接到 html 内容中。</span></span><br><span class="line">Documentation.ExecMode execMode = tableOption.execMode();</span><br><span class="line"><span class="keyword">if</span> (Documentation.ExecMode.BATCH_STREAMING.equals(execMode)) &#123;</span><br><span class="line">execModeStringBuilder.append(<span class="string">"&lt;br&gt; &lt;span class=\"label label-primary\"&gt;"</span>)</span><br><span class="line">.append(Documentation.ExecMode.BATCH.toString())</span><br><span class="line">.append(<span class="string">"&lt;/span&gt; &lt;span class=\"label label-primary\"&gt;"</span>)</span><br><span class="line">.append(Documentation.ExecMode.STREAMING.toString())</span><br><span class="line">.append(<span class="string">"&lt;/span&gt;"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">execModeStringBuilder.append(<span class="string">"&lt;br&gt; &lt;span class=\"label label-primary\"&gt;"</span>)</span><br><span class="line">.append(execMode.toString())</span><br><span class="line">.append(<span class="string">"&lt;/span&gt;"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span> +</span><br><span class="line"><span class="string">"        &lt;tr&gt;\n"</span> +</span><br><span class="line"><span class="string">"            &lt;td&gt;&lt;h5&gt;"</span> + escapeCharacters(option.key()) + <span class="string">"&lt;/h5&gt;"</span> + execModeStringBuilder.toString() + <span class="string">"&lt;/td&gt;\n"</span> +</span><br><span class="line"><span class="string">"            &lt;td style=\"word-wrap: break-word;\"&gt;"</span> + escapeCharacters(addWordBreakOpportunities(defaultValue)) + <span class="string">"&lt;/td&gt;\n"</span> +</span><br><span class="line"><span class="string">"            &lt;td&gt;"</span> + type + <span class="string">"&lt;/td&gt;\n"</span> +</span><br><span class="line"><span class="string">"            &lt;td&gt;"</span> + formatter.format(option.description()) + <span class="string">"&lt;/td&gt;\n"</span> +</span><br><span class="line"><span class="string">"        &lt;/tr&gt;\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>@Documentation.ExcludeFromDocumentation</li></ol><p>作用于 ConfigOption 配置项，用于从最终生成的 HTML 文档中移除配置项。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Internal</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ExcludeFromDocumentation &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The optional reason why the config option is excluded from documentation.</span></span><br><span class="line"><span class="comment"> * 解释下从文档中移除配置项的原因</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面通过一个示例来说明这个注解的用途。<br>查看测试类 ConfigOptionsDocGeneratorTest 中应用到 @Documentation.ExcludeFromDocumentation 的单测 <code>testConfigOptionExclusion</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConfigOptionExclusion</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> String htmlTable = ConfigOptionsDocGenerator.generateTablesForClass(TestConfigGroupWithExclusion.class).get(<span class="number">0</span>).f1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TestConfigGroupWithExclusion</code> 类 mock 了一个配置项类：<br>excludedOption 使用了 @Documentation.ExcludeFromDocumentation 注解，在生成的 HTML 文档中它将被移除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TestConfigGroupWithExclusion</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ConfigOption&lt;Integer&gt; firstOption = ConfigOptions</span><br><span class="line">.key(<span class="string">"first.option.a"</span>)</span><br><span class="line">.defaultValue(<span class="number">2</span>)</span><br><span class="line">.withDescription(<span class="string">"This is example description for the first option."</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">@Documentation</span>.ExcludeFromDocumentation</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ConfigOption&lt;String&gt; excludedOption = ConfigOptions</span><br><span class="line">.key(<span class="string">"excluded.option.a"</span>)</span><br><span class="line">.noDefaultValue()</span><br><span class="line">.withDescription(<span class="string">"This should not be documented."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行单测 <code>testConfigOptionExclusion</code> 的输出结果如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">class</span>=<span class="string">"table table-bordered"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">"text-left"</span> <span class="attr">style</span>=<span class="string">"width: 20%"</span>&gt;</span>Key<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">"text-left"</span> <span class="attr">style</span>=<span class="string">"width: 15%"</span>&gt;</span>Default<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">"text-left"</span> <span class="attr">style</span>=<span class="string">"width: 10%"</span>&gt;</span>Type<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">"text-left"</span> <span class="attr">style</span>=<span class="string">"width: 55%"</span>&gt;</span>Description<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">h5</span>&gt;</span>first.option.a<span class="tag">&lt;/<span class="name">h5</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">style</span>=<span class="string">"word-wrap: break-word;"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>Integer<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>This is example description for the first option.<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="其他标记注解"><a href="#其他标记注解" class="headerlink" title="其他标记注解"></a>其他标记注解</h3><p>关于这几种标记注解，源码中暂时还没有找到相关测试用例，后续补充。</p><ol><li>@Experimental</li></ol><p>表示标记对象是试验使用的注解，带有此注解的类是没有经过严格测试和不稳定的，可能在以后的版本中被修改或移除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD, ElementType.FIELD, ElementType.CONSTRUCTOR &#125;)</span><br><span class="line"><span class="meta">@Public</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Experimental &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>@Internal</li></ol><p>将稳定的公共的api注解为内部开发者api，内部开发者api是稳定的，面向Flink内部，可能随着版本变化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target</span>(&#123; ElementType.TYPE, ElementType.METHOD, ElementType.CONSTRUCTOR &#125;)</span><br><span class="line"><span class="meta">@Public</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Internal &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>@Public</li></ol><p>标注类为开放的，稳定的。<br>类、方法、属性被这个这个注解修饰时，表示在小版本迭代(1.0,1.1,1.2)中，都维持稳定，应用程序将根据同一大版本进行编译。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Public</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Public &#123;&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>@PublicEvolving</li></ol><p>带有此注解的类和方法用于公共使用，并且具有稳定的行为。但是，它们的接口和签名不被认为是稳定的，并且当跨版本时可能会变化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target</span>(&#123; ElementType.TYPE, ElementType.METHOD, ElementType.FIELD, ElementType.CONSTRUCTOR &#125;)</span><br><span class="line"><span class="meta">@Public</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> PublicEvolving &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>@VisibleForTesting</li></ol><p>标注有些方法、属性、构造函数、类等在 test 阶段可见，用于测试。<br>例如，当方法是 private 的，不打算在外部去调用的，但是有些内部测试需要访问它，所以加上 VisibleForTesting 注解进行内部测试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target</span>(&#123; ElementType.TYPE, ElementType.METHOD, ElementType.FIELD, ElementType.CONSTRUCTOR &#125;)</span><br><span class="line"><span class="meta">@Internal</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> VisibleForTesting &#123;&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将先介绍下java注解的实现，再说明下Flink自定义的几个注解及其使用。&lt;/p&gt;
    
    </summary>
    
      <category term="Flink" scheme="http://yoursite.com/categories/Flink/"/>
    
    
  </entry>
  
</feed>
